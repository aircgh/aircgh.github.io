{"version":3,"file":"index-BeypnKhb.js","sources":["../../node_modules/stac-node-validator/node_modules/stac-js/src/utils.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/geo.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/object.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/http.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/mediatypes.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/reference.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/link.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/hypermedia.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/apicollection.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/band.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/asset.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/locales.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/stac.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/cataloglike.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/catalog.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/datetime.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/collection.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/collectioncollection.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/item.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/itemcollection.js","../../node_modules/stac-node-validator/node_modules/stac-js/src/index.js"],"sourcesContent":["/**\n * Checks whether a variable is a string and contains at least one character.\n * \n * @param {*} string - A variable to check.\n * @returns {boolean} - `true` is the given variable is a string with length > 0, `false` otherwise.\n */\nexport function hasText(string) {\n  return (typeof string === 'string' && string.length > 0);\n}\n\n/**\n * Ensures a number is between a minimum and maximum value, but with a delta.\n * \n * @param {number} num The number to check.\n * @param {number} min The minimum value.\n * @param {number} max The maximum value.\n * @param {number} delta The delta that the number is allowed to be larger or smaller.\n * @returns {number|null}\n */\nexport function ensureNumber(num, min, max, delta = 0.00000001) {\n  if (typeof num !== 'number') {\n    return null;\n  }\n  const min2 = min - delta;\n  const max2 = max + delta;\n  if (num < min2 || num > max2) {\n    return null;\n  }\n\n  return Math.min(Math.max(num, min), max);\n}\n\n/**\n * Checks whether a variable is a real object or not.\n * \n * This is a more strict version of `typeof x === 'object'` as this example would also succeed for arrays and `null`.\n * This function only returns `true` for real objects and not for arrays, `null` or any other data types.\n * \n * @param {*} obj - A variable to check.\n * @returns {boolean} - `true` is the given variable is an object, `false` otherwise.\n */\nexport function isObject(obj) {\n  return (typeof obj === 'object' && obj === Object(obj) && !Array.isArray(obj));\n}\n\n/**\n * Merges any number of arrays of objects.\n * \n * @param  {...Array.<Object>} bands \n * @returns {Array.<Object>}\n */\nexport function mergeArraysOfObjects(...bands) {\n  bands = bands.filter(arr => Array.isArray(arr));\n  if (bands.length > 1) {\n    let length = Math.max(...bands.map(arr => arr.length));\n    let merged = [];\n    for(let i = 0; i < length; i++) {\n      merged.push(Object.assign({}, ...bands.map(band => band[i])));\n    }\n    return merged;\n  }\n  else if (bands.length === 1) {\n    return bands[0];\n  }\n  return [];\n}\n\n/**\n * Get minimum values for the STAC data types.\n * \n * Currently only supports int types.\n * \n * @private\n * @todo Add float support\n * @param {string} str Data type\n * @returns {number|null} Minimum value\n */\nexport function getMinForDataType(str) {\n  switch(str) {\n    case \"int8\":\n      return -128;\n    case \"int16\":\n      return -32768;\n    case \"int32\":\n      return -2147483648;\n  }\n  if (str.startsWith(\"u\")) {\n    return 0;\n  }\n  return null;\n}\n\n/**\n * Get maximum values for the STAC data types.\n * \n * Currently only supports int types.\n * \n * @private\n * @todo Add float support\n * @param {string} str Data type\n * @returns {number|null} Maximum value\n */\nexport function getMaxForDataType(str) {\n  switch(str) {\n    case \"int8\":\n      return 127;\n    case \"uint8\":\n      return 255;\n    case \"int16\":\n      return 32767;\n    case \"uint16\":\n      return 65535;\n    case \"int32\":\n      return 2147483647;\n    case \"uint32\":\n      return 4294967295;\n  }\n  return null;\n}\n\n\n/**\n * Gets the reported minimum and maximum values for a STAC object.\n * \n * Searches through different extension fields in raster, classification, and file.\n * \n * @param {StacObject} object \n * @returns {Statistics}\n */\nexport function getMinMaxValues(object) {\n  /**\n   * Statistics\n   * \n   * @typedef {Object} Statistics\n   * @property {number|null} minimum Minimum value\n   * @property {number|null} maximum Maximum value\n   */\n  const stats = {\n    minimum: null,\n    maximum: null\n  };\n\n  // Checks whether the stats object is completely filled\n  const isComplete = obj => obj.minimum !== null && obj.maximum !== null;\n\n  // data sources: raster (statistics, histogram, data_type), classification, file (values, data_type)\n  const statistics = object.getMetadata(\"statistics\");\n  if (isObject(statistics)) {\n    if (typeof statistics.minimum === 'number') {\n      stats.minimum = statistics.minimum;\n    }\n    if (typeof statistics.maximum === 'number') {\n      stats.maximum = statistics.maximum;\n    }\n    if (isComplete(stats)) {\n      return stats;\n    }\n  }\n\n  const histogram = object.getMetadata(\"raster:histogram\");\n  if (isObject(histogram)) {\n    if (typeof histogram.min === 'number') {\n      stats.minimum = histogram.min;\n    }\n    if (typeof histogram.max === 'number') {\n      stats.maximum = histogram.max;\n    }\n    if (isComplete(stats)) {\n      return stats;\n    }\n  }\n\n  const classification = object.getMetadata(\"classification:classes\");\n  if (Array.isArray(classification)) {\n    classification.reduce((obj, cls) => {\n      obj.minimum = Math.min(obj.minimum, cls.value);\n      obj.maximum = Math.max(obj.maximum, cls.value);\n      return obj;\n    }, stats);\n    if (isComplete(stats)) {\n      return stats;\n    }\n  }\n\n  const values = object.getMetadata(\"file:values\");\n  if (Array.isArray(values)) {\n    values.reduce((obj, map) => {\n      obj.minimum = Math.min(obj.minimum, ...map.values);\n      obj.maximum = Math.max(obj.maximum, ...map.values);\n      return obj;\n    }, stats);\n    if (isComplete(stats)) {\n      return stats;\n    }\n  }\n\n  const data_type = object.getMetadata(\"data_type\");\n  if (data_type) {\n    stats.minimum = getMinForDataType(data_type);\n    stats.maximum = getMaxForDataType(data_type);\n  }\n\n  return stats;\n}\n\n/**\n * Gets the reported no-data values for a STAC Object.\n * \n * Searches through different extension fields in nodata, classification, and file.\n * \n * @param {StacObject} object \n * @returns {Array.<*>}\n */\nexport function getNoDataValues(object) {\n  // data sources: raster (nodata), classification (nodata flag), file (nodata)\n  let nodata = [];\n  const common = object.getMetadata(\"nodata\");\n  if (typeof common !== 'undefined') {\n    nodata.push(common);\n  }\n  else {\n    const file = object.getMetadata(\"file:nodata\");\n    if (typeof file !== 'undefined') {\n      nodata = file;\n    }\n    else {\n      const classification = object.getMetadata(\"classification:classes\");\n      if (Array.isArray(classification)) {\n        nodata = classification\n          .filter(cls => Boolean(cls.nodata))\n          .map(cls => cls.value);\n      }\n    }\n  }\n\n  return nodata.map(value => {\n    if (value === \"nan\") {\n      return NaN;\n    }\n    else if (value === \"+inf\") {\n      return +Infinity;\n    }\n    else if (value === \"-inf\") {\n      return -Infinity;\n    }\n    else {\n      return value;\n    }\n  });\n}\n","import { ensureNumber, isObject } from \"./utils.js\";\n\nfunction toObject(bbox) {\n  let hasZ = bbox.length >= 6;\n  let west = bbox[0];\n  let east = bbox[hasZ ? 3 : 2];\n  let south = bbox[1];\n  let north = bbox[hasZ ? 4 : 3];\n  let obj = { west, east, south, north };\n  if (hasZ) {\n    obj.base = bbox[2];\n    obj.height = bbox[5];\n  }\n  return obj;\n}\n\nfunction bboxToCoords(bbox) {\n  let { west, east, south, north } = toObject(bbox);\n  return [\n    [\n      [west, north],\n      [west, south],\n      [east, south],\n      [east, north],\n      [west, north]\n    ]\n  ];\n}\n\n/**\n * Returns the center of the STAC entity.\n * \n * @param {BoundingBox|null} bbox \n * @returns {Point|null}\n */\nexport function centerOfBoundingBox(bbox) {\n  bbox = ensureBoundingBox(bbox, true);\n  if (!bbox) {\n    return null;\n  }\n  let obj = toObject(bbox);\n  let point = [];\n  // todo: implement also for bboxes that cross the boundaries at the poles\n  if (isAntimeridianBoundingBox(bbox)) {\n    let x = (obj.west + 360 + obj.east) / 2;\n    if (x > 180) {\n      x -= 360;\n    }\n    point.push(x);\n  }\n  else {\n    point.push((obj.west + obj.east) / 2);\n  }\n  point.push((obj.south + obj.north) / 2); // y\n  if (typeof obj.base !== 'undefined') {\n    point.push((obj.base + obj.height) / 2); // z\n  }\n  return point;\n}\n\nfunction fixGeoJsonGoordinates(coords) {\n  if (Array.isArray(coords[0])) {\n    // Handle nested coordinates (e.g., MultiPolygons, LineStrings)\n    return coords.map(fixGeoJsonGoordinates);\n  }\n  // Fix individual coordinate [longitude, latitude]\n  const [lon, lat] = coords;\n  return [ensureNumber(lon, -180, 180), ensureNumber(lat, -90, 90)];\n}\n\n/**\n * Fix coordinates in a GeoJSON object to be within the CRS range.\n * \n * Function works in-place.\n * \n * @param {Object} geojson - The GeoJSON object to be checked.\n * @returns {Object} The fixed GeoJSON object.\n */\nexport function fixGeoJson(geojson) {\n  if (!isObject(geojson)) {\n    return geojson;\n  }\n  if (geojson.bbox) {\n    geojson.bbox = ensureBoundingBox(geojson.bbox);\n  }\n  if (geojson.type === \"FeatureCollection\") {\n    geojson.features.forEach((feature) => fixGeoJson(feature));\n  }\n  else if (geojson.type === \"Feature\") {\n    geojson.geometry = fixGeoJson(geojson.geometry);\n  }\n  else if (geojson.type === \"GeometryCollection\") {\n    geojson.geometries.forEach((geometry) => fixGeoJson(geometry));\n  }\n  else if (geojson.coordinates) {\n    geojson.coordinates = fixGeoJsonGoordinates(geojson.coordinates);\n  }\n  return geojson;\n}\n\n/**\n * Converts one or more bounding boxes to a GeoJSON Feature.\n * \n * The Feature contains a Polygon or MultiPolygon based on the given number of valid bounding boxes.\n * \n * @param {BoundingBox|Array.<BoundingBox>} bboxes \n * @returns {Object|null}\n */\nexport function toGeoJSON(bboxes) {\n  if (bboxes.every(c => typeof c === 'number')) {\n    // Wrap a single bounding box into an array\n    bboxes = [bboxes];\n  }\n\n  bboxes = bboxes\n    .map(bbox => ensureBoundingBox(bbox))\n    // Remove invalid bounding boxes\n    .filter(bbox => bbox !== null);\n\n  // Return if no valid bbox is given\n  if (!Array.isArray(bboxes) || bboxes.length === 0) {\n    return null;\n  }\n\n  let coordinates = bboxes.reduce((list, bbox) => {\n    // todo: implement also for bboxes that cross the boundaries at the poles\n    // see https://github.com/DanielJDufour/bbox-fns/blob/main/split.js\n    if (isAntimeridianBoundingBox(bbox)) {\n      let { west, east, south, north } = toObject(bbox);\n      list.push(bboxToCoords([-180, south, east, north]));\n      list.push(bboxToCoords([west, south, 180, north]));\n    }\n    else {\n      list.push(bboxToCoords(bbox));\n    }\n    return list;\n  }, []);\n\n  let geometry = null;\n  if (coordinates.length === 1) {\n    geometry = {\n      type: \"Polygon\",\n      coordinates: coordinates[0]\n    };\n  }\n  else if (coordinates.length > 1) {\n    geometry = {\n      type: \"MultiPolygon\",\n      coordinates\n    };\n  }\n  if (geometry) {\n    return {\n      type: \"Feature\",\n      geometry,\n      properties: {}\n    };\n  }\n}\n\n/**\n * Ensure this is a valid bounding box.\n * \n * This function will ensure that the given bounding box is valid and otherwise return `null`.\n * \n * If the bounding box is 3D, the function will return `null` unless `allow3D` is set to `true`.\n * \n * @param {BoundingBox|Array.<number>} bbox The bounding box to check.\n * @param {boolean} allow3D - Whether to allow 3D bounding boxes or not.\n * @returns {BoundingBox|null}\n */\nexport function ensureBoundingBox(bbox, allow3D = false) {\n  if (!Array.isArray(bbox) || ![4,6].includes(bbox.length)) {\n    return null;\n  }\n\n  let { west, east, south, north, base, height } = toObject(bbox);\n  // Some bounding boxes are slightly too large (due to floating point errors).\n  // So you may get 90.00000001 instead of 90. To avoid this, we allow for a small delta.\n  west = ensureNumber(west, -180, 180);\n  south = ensureNumber(south, -90, 90);\n  east = ensureNumber(east, -180, 180);\n  north = ensureNumber(north, -90, 90);\n  if (allow3D && bbox.length === 6) {\n    bbox = [west, south, base, east, north, height];\n  }\n  else {\n    bbox = [west, south, east, north];\n  }\n  if (bbox.some(n => n === null)) {\n    return null;\n  }\n  return bbox;\n}\n\n/**\n * Checks whether the given bounding box crosses the antimeridian.\n * \n * @param {BoundingBox} bbox \n * @returns {boolean}\n */\nexport function isAntimeridianBoundingBox(bbox) {\n  bbox = ensureBoundingBox(bbox);\n  if (!bbox) {\n    return false;\n  }\n  \n  let { west, east } = toObject(bbox);\n  return west > east;\n}\n\n/**\n * Compute the union of a list of bounding boxes.\n * \n * The function ignores any invalid bounding boxes or values for the third dimension.\n * \n * @param {Array.<BoundingBox|null>} bboxes \n * @returns {BoundingBox|null}\n * @see {ensureBoundingBox}\n */\nexport function unionBoundingBox(bboxes) {\n  if (!Array.isArray(bboxes) || bboxes.length === 0) {\n    return null;\n  }\n\n  const extrema = {\n    west: null,\n    south: null,\n    east: null,\n    north: null,\n  };\n  const min = ['west', 'south'];\n  for(let bbox of bboxes) {\n    bbox = ensureBoundingBox(bbox);\n    if (!bbox) {\n      continue;\n    }\n    const obj = toObject(bbox);\n    for(const key in obj) {\n      if (extrema[key] === null) {\n        extrema[key] = obj[key];\n      }\n      else {\n        const fn = min.includes(key) ? Math.min : Math.max;\n        extrema[key] = fn(extrema[key], obj[key]);\n      }\n    }\n  }\n\n  let bbox = [extrema.west, extrema.south, extrema.east, extrema.north];\n  return ensureBoundingBox(bbox);\n}\n","import { centerOfBoundingBox } from './geo.js';\nimport { isObject } from './utils.js';\n\n/**\n * Base class for STAC objects.\n * \n * Don't instantiate this class!\n * \n * @interface\n * @param {Object} data The STAC object\n * @param {Object.<string, function>} keyMap Keys and functions that convert the values to stac-js objects.\n * @param {Array.<string>} privateKeys Keys that are private members of the stac-js objects (for cloning and export).\n */\nclass STACObject {\n\n  constructor(data, keyMap = {}, privateKeys = []) {\n    if (!isObject(data)) {\n      throw new Error('Given data is not an object');\n    }\n\n    if (data instanceof STACObject) {\n      for(let key of privateKeys) {\n        this[key] = data[key];\n      }\n      data = data.toJSON();\n    }\n\n    // Map with functions that convert properties to stac-js objects\n    this._keyMap = keyMap;\n    // Array with keys that are used internally and should be cloned\n    this._privateKeys = ['_keyMap', '_privateKeys'].concat(privateKeys);\n\n    // Assign the data to the object\n    for (let key in data) {\n      if (typeof this[key] === 'undefined') {\n        if (key in keyMap) {\n          this[key] = keyMap[key](data[key], this);\n        }\n        else {\n          this[key] = data[key];\n        }\n      }\n    }\n  }\n\n  /**\n   * Check whether this given object is a STAC Item.\n   * \n   * @returns {boolean} `true` if the object is a STAC Item, `false` otherwise.\n   */\n  isItem() {\n    return this.type === 'Feature';\n  }\n\n  /**\n   * Check whether this given object is a STAC Catalog.\n   * \n   * @returns {boolean} `true` if the object is a STAC Catalog, `false` otherwise.\n   */\n  isCatalog() {\n    return this.type === 'Catalog';\n  }\n\n  /**\n   * Check whether this given object is \"catalog-like\", i.e. a Catalog or Collection.\n   * \n   * @returns {boolean} `true` if the object is a \"catalog-like\", `false` otherwise.\n   */\n  isCatalogLike() {\n    return this.isCatalog() || this.isCollection();\n  }\n\n  /**\n   * Check whether this given object is a STAC Collection.\n   * \n   * @returns {boolean} `true` if the object is a STAC Collection, `false` otherwise.\n   */\n  isCollection() {\n    return this.type === 'Collection';\n  }\n\n  /**\n   * Check whether this given object is a STAC ItemCollection.\n   * \n   * @returns {boolean} `true` if the object is a STAC ItemCollection, `false` otherwise.\n   */\n  isItemCollection() {\n    return this.type === 'FeatureCollection';\n  }\n\n  /**\n   * Check whether this given object is a STAC Collection of Collections (i.e. API Collections).\n   * \n   * @returns {boolean} `true` if the object is a STAC CollectionCollection, `false` otherwise.\n   */\n  isCollectionCollection() {\n    return false;\n  }\n\n  /**\n   * Check whether this given object is a STAC Asset.\n   * \n   * @returns {boolean} `true` if the object is a STAC Asset, `false` otherwise.\n   */\n  isAsset() {\n    return false;\n  }\n\n  /**\n   * Check whether this given object is a STAC Link.\n   * \n   * @returns {boolean} `true` if the object is a STAC Link, `false` otherwise.\n   */\n  isLink() {\n    return false;\n  }\n\n  /**\n   * Check whether this given object is a STAC Band.\n   * \n   * @returns {boolean} `true` if the object is a STAC Band, `false` otherwise.\n   */\n  isBand() {\n    return false;\n  }\n\n  /**\n   * Returns the type of the STAC object.\n   * \n   * One of:\n   * - Asset\n   * - Catalog\n   * - Collection\n   * - CollectionCollection\n   * - Item\n   * - ItemCollection\n   * - Link\n   * - Band\n   * @abstract\n   * @returns {string}\n   */\n  getObjectType() {\n    return;\n  }\n\n  /**\n   * Gets the absolute URL of the STAC entity (if provided explicitly or available from the self link).\n   * \n   * @param {boolean} stringify If `true` (default), a string is returned, otherwise a URI object.\n   * @returns {string|null} Absolute URL\n   */\n  getAbsoluteUrl(stringify = true) { // eslint-disable-line no-unused-vars\n    return null;\n  }\n\n  /**\n   * Returns the metadata for the STAC entity.\n   * \n   * @param {string} field Field name\n   * @returns {*}\n   */\n  getMetadata(field) {\n    return this[field];\n  }\n\n  /**\n   * Returns a GeoJSON Feature or FeatureCollection for this STAC object.\n   * \n   * @returns {Object|null} GeoJSON object or `null`\n   */\n  toGeoJSON() {\n    return null;\n  }\n\n  /**\n   * Returns a single bounding box for the STAC entity.\n   * \n   * @returns {BoundingBox|null}\n   */\n  getBoundingBox() {\n    return null;\n  }\n\n  /**\n   * Returns the center of the STAC entity.\n   * \n   * @returns {BoundingBox|null}\n   */\n  getCenter() {\n    return centerOfBoundingBox(this.getBoundingBox());\n  }\n\n  /**\n   * Returns a list of bounding boxes for the STAC entity.\n   * \n   * @returns {Array.<BoundingBox>}\n   */\n  getBoundingBoxes() {\n    return [];\n  }\n\n  /**\n   * Returns a plain object for JSON export.\n   * \n   * @returns {Object} Plain object\n   */\n  toJSON() {\n    let obj = {};\n    Object.keys(this).forEach(key => {\n      if (typeof this[key] === 'function' || this._privateKeys.includes(key)) {\n        return;\n      }\n      let v = this[key];\n      if (key in this._keyMap) {\n        let v2 = Array.isArray(v) ? [] : {};\n        for(let key in v) {\n          if (typeof v[key].toJSON === 'function') {\n            v2[key] = v[key].toJSON();\n          }\n          else {\n            v2[key] = v[key];\n          }\n        }\n        v = v2;\n      }\n      obj[key] = v;\n    });\n    return obj;\n  }\n  \n}\n\nexport default STACObject;\n","import URI from 'urijs';\n\n/**\n * Protocols supported by browsers (http and https).\n * \n * @type {Array.<string>}\n */\nexport const browserProtocols = [\n  'http',\n  'https'\n];\n\n/**\n * \n * @todo\n * @param {string} href \n * @param {string} baseUrl \n * @param {boolean} stringify \n * @returns {string|URI}\n */\nexport function toAbsolute(href, baseUrl, stringify = true) {\n  return normalizeUri(href, baseUrl, false, stringify);\n}\n\n/**\n * \n * @todo\n * @param {string} href \n * @param {string|null} baseUrl \n * @param {boolean} noParams \n * @param {boolean} stringify \n * @returns {string|URI}\n */\nexport function normalizeUri(href, baseUrl = null, noParams = false, stringify = true) {\n  // Parse URL and make absolute, if required\n  let uri = URI(href);\n  if (baseUrl && uri.is(\"relative\")) { // Don't convert GDAL VFS URIs: https://github.com/radiantearth/stac-browser/issues/116\n    // Avoid that baseUrls that have a . in the last parth part will be removed (e.g. https://example.com/api/v1.0 )\n    let baseUri = URI(baseUrl);\n    let baseUriPath = baseUri.path();\n    if (!baseUriPath.endsWith('/') && !baseUriPath.endsWith('.json')) {\n      baseUri.path(baseUriPath + '/');\n    }\n    uri = uri.absoluteTo(baseUri);\n  }\n  // Normalize URL and remove trailing slash from path\n  // to avoid handling the same resource twice\n  uri.normalize();\n  if (noParams) {\n    uri.query(\"\");\n    uri.fragment(\"\");\n  }\n  return stringify ? uri.toString() : uri;\n}\n","/**\n * The GeoJSON media type.\n * \n * @type {string}\n */\nexport const geojsonMediaType = 'application/geo+json';\n\n/**\n * All STAC media types (JSON + GeoJSON).\n * \n * @type {Array.<string>}\n */\nexport const stacMediaTypes = [\n  'application/json',\n  geojsonMediaType,\n  'text/json'\n];\n\n/**\n * All image media types that Web Browsers can show (GIF, JPEG, PNG, WebP).\n * \n * @type {Array.<string>}\n */\nexport const browserImageTypes = [\n  'image/gif',\n  'image/jpeg',\n  'image/apng',\n  'image/png',\n  'image/webp'\n];\n\n/**\n * All Cloud Optimized GeoTiff media types.\n * \n * @type {Array.<string>}\n */\nexport const cogMediaTypes = [\n  'image/tiff; application=geotiff; profile=cloud-optimized',\n  'image/vnd.stac.geotiff; cloud-optimized=true'\n];\n\n/**\n * All GeoTiff media types (including COG media types).\n * \n * @type {Array.<string>}\n */\nexport const geotiffMediaTypes = [\n  'application/geotiff',\n  'image/tiff; application=geotiff',\n  'image/vnd.stac.geotiff',\n].concat(cogMediaTypes);\n\n/**\n * All image media types combined (Web Browser + GeoTiff).\n * \n * @type {Array.<string>}\n */\nexport const imageMediaTypes = browserImageTypes.concat(geotiffMediaTypes);\n\n/**\n * Checks whether a given media type is in the list of media types.\n * \n * @param {string|undefined} type The potential media type.\n * @param {string|Array.<string>} allowedTypes A list of allowed media types (or a single media type as string).\n * @param {boolean} allowUndefined If set to `true`, returns `true` if `undefined` is passed as `type`.\n * @returns {boolean} `true` if the media type is allowed, `false` otherwise.\n */\nexport function isMediaType(type, allowedTypes, allowUndefined = false) {\n  if (!Array.isArray(allowedTypes)) {\n    allowedTypes = [allowedTypes];\n  }\n  if (allowUndefined && typeof type === 'undefined') {\n    return true;\n  }\n  else if (typeof type !== 'string') {\n    return false;\n  }\n  else {\n    allowedTypes = allowedTypes.map(type => type.toLowerCase());\n    return allowedTypes.includes(type.toLowerCase());\n  }\n}\n\n/**\n * Checks whether the given media type is a STAC media type (JSON or GeoJSON).\n * \n * @param {string|undefined} type The potential media type.\n * @param {boolean} allowUndefined If set to `true`, returns `true` if `undefined` is passed as `type`.\n * @returns {boolean} `true` if the media type is a STAC media type, `false` otherwise.\n */\nexport function isStacMediaType(type, allowUndefined = false) {\n  return isMediaType(type, stacMediaTypes, allowUndefined);\n}\n","import { browserProtocols, toAbsolute } from './http.js';\nimport { cogMediaTypes, geotiffMediaTypes, isMediaType } from \"./mediatypes.js\";\nimport { hasText } from './utils.js';\nimport STACObject from './object.js';\nimport { browserImageTypes } from './mediatypes.js';\nimport URI from 'urijs';\n\n/**\n * A STAC reference as base for Assets and Links.\n * \n * Don't instantiate this class!\n * \n * @interface\n * @property {string} href\n * @property {?string} type\n * \n * @param {Object} data The STAC API Collection object\n * @param {STAC|null} context The object that contains the reference\n * @param {Object.<string, function>} keyMap Keys and functions that convert the values to stac-js objects.\n * @param {Array.<string>} privateKeys Keys that are private members of the stac-js objects (for cloning and export).\n */\nclass STACReference extends STACObject {\n\n  constructor(data, context = null, keyMap = {}, privateKeys = []) {\n    super(data, keyMap, ['_context'].concat(privateKeys));\n    if (!this._context) {\n      this._context = context;\n    }\n  }\n\n  /**\n   * Gets the URL of the reference as absolute URL.\n   * \n   * @param {boolean} stringify If `true` (default), a string is returned, otherwise a URI object.\n   * @returns {URI|string|null}\n   */\n  getAbsoluteUrl(stringify = true) {\n    if (this._context) {\n      return toAbsolute(this.href, this._context.getAbsoluteUrl(), stringify);\n    }\n    else if (this.href.includes('://')) {\n      return stringify ? this.href : URI(this.href);\n    }\n    return null;\n  }\n\n  /**\n   * Returns the STAC entity that contains the reference.\n   * \n   * @returns {STAC|null}\n   */\n  getContext() {\n    return this._context;\n  }\n\n  /**\n   * Checks whether a given reference can be displayed by a browser.\n   * \n   * A browser can usually display an image if it is a specific file format (e.g. JPEG, PNG, ...) and is served over HTTP(S).\n   * \n   * @returns {boolean} `true` if a browser can display the given reference, `false` otherwise.\n   * @see {canBrowserDisplayImage}\n   */\n  canBrowserDisplayImage(allowUndefined = false) {\n    if (typeof this.href !== 'string') {\n      return false;\n    }\n    else if (!allowUndefined && typeof this.type === 'undefined') {\n      return false;\n    }\n    let uri = this.getAbsoluteUrl(false);\n    if (!uri) {\n      uri = URI(this.href);\n    }\n    const protocol = uri.protocol().toLowerCase();\n    const extension = uri.suffix().toLowerCase();\n    if (hasText(protocol) && !browserProtocols.includes(protocol)) {\n      return false;\n    }\n    else if (hasText(this.type) && browserImageTypes.includes(this.type.toLowerCase())) {\n      return true;\n    }\n    else if (typeof this.type === 'undefined' && hasText(extension) && (extension === 'jpg' || browserImageTypes.includes('image/' + extension))) {\n      return true;\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Checks whether this entity is of a specific type.\n   * \n   * @param {string|Array.<string>} types One or more media types.\n   * @returns {boolean} `true` is this entity is one of the given types, `false` otherwise.\n   */\n  isType(types) { // string or array of strings\n    return hasText(this.type) && isMediaType(this.type, types);\n  }\n\n  /**\n   * Checks whether this entity is a GeoTiff (including COGs).\n   * \n   * @returns {boolean} `true` is this entity is a GeoTiff, `false` otherwise.\n   */\n  isGeoTIFF() {\n    return this.isType(geotiffMediaTypes);\n  }\n\n  /**\n   * Checks whether this entity is a COG (excluding pure GeoTiffs).\n   * \n   * @returns {boolean} `true` is this entity is a COG, `false` otherwise.\n   */\n  isCOG() {\n    return this.isType(cogMediaTypes);\n  }\n\n  /**\n   * Checks whether the entity is accessible via HTTP or HTTPS.\n   * \n   * Returns `null` if no URI is available, otherwise a `boolean` value.\n   * \n   * @returns {boolean|null} `true` is this entity is available via HTTP or HTTPS, `false` or `null` otherwise.\n   */\n  isHTTP() {\n    let uri = this.getAbsoluteUrl(false);\n    if (!uri) {\n      return null;\n    }\n    const protocol = uri.protocol().toLowerCase();\n    return hasText(protocol) && browserProtocols.includes(protocol);\n  }\n\n  /**\n   * Returns whether the entity is a preview image.\n   * \n   * @returns {boolean} `true` if the entity is a preview, `false` otherwise.\n   */\n  isPreview() {\n    return false;\n  }\n  \n}\n\nexport default STACReference;\n","import STACReference from './reference.js';\nimport { isObject } from './utils.js';\n\n/**\n * A STAC Link object.\n * \n * You can access all properties of the given STAC Link object directly, e.g. `link.href`.\n * \n * @class\n * @property {string} href\n * @property {string} rel\n * @property {?string} type\n * @property {?string} title\n * @property {?string} method\n * @property {?Object.<string, string>} headers\n * @property {?Object} body\n * @property {?boolean} merge\n * \n * @param {Object|Link} data The STAC Link object\n * @param {STAC|null} context The object that contains the link\n */\nclass Link extends STACReference {\n\n  constructor(data, context = null) {\n    super(data, context);\n  }\n  \n  /**\n   * Check whether this given object is a STAC LInk.\n   * \n   * @returns {boolean} `true` if the object is a STAC Link, `false` otherwise.\n   */\n  isLink() {\n    return true;\n  }\n\n  /**\n   * Returns the type of the STAC object, here: 'Link'.\n   * \n   * @returns {string}\n   */\n  getObjectType() {\n    return \"Link\";\n  }\n\n  /**\n   * Returns whether the link is a preview image.\n   * \n   * @returns {boolean} `true` if the link is a preview, `false` otherwise.\n   */\n  isPreview() {\n    return this.rel === 'preview';\n  }\n\n\n  /**\n   * Converts an array of STAC Links into an array of stac-js Links.\n   * \n   * @param {Array.<Object>} links Links\n   * @param {STAC|null} context The object that contains the links\n   * @returns {Array.<Link>} Improved Links\n   */\n  static fromLinks(links, context = null) {\n    if(!Array.isArray(links)) {\n      return [];\n    }\n    return links.map(link => isObject(link) ? new Link(link, context) : link);\n  }\n\n}\n\nexport default Link;\n","import STACObject from './object.js';\nimport Link from './link.js';\nimport { isStacMediaType } from './mediatypes.js';\nimport { hasText, isObject } from './utils.js';\nimport URI from 'urijs';\n\n\n/**\n * STAC Hypermedia class for STAC objects.\n * \n * Don't instantiate this class!\n * \n * @interface\n * @property {Array.<Link>} links\n * \n * @param {Object} data The STAC object\n * @param {string|null} absoluteUrl Absolute URL of the STAC object\n * @param {Object.<string, function>} keyMap Keys and functions that convert the values to stac-js objects.\n * @param {Array.<string>} privateKeys Keys that are private members of the stac-js objects (for cloning and export).\n */\nclass STACHypermedia extends STACObject {\n\n  constructor(data, absoluteUrl = null, keyMap = {}, privateKeys = []) {\n    super(\n      data,\n      Object.assign({ links: Link.fromLinks }, keyMap),\n      ['_url'].concat(privateKeys)\n    );\n\n    // Set or detect the URL of the STAC entity\n    if (!this._url) {\n      this._url = absoluteUrl;\n      if (!this._url) {\n        let self = this.getSelfLink();\n        if (self) {\n          this._url = self.href;\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets the absolute URL of the STAC entity (if provided explicitly or available from the self link).\n   * \n   * @param {boolean} stringify If `true` (default), a string is returned, otherwise a URI object.\n   * @returns {string|null} Absolute URL\n   */\n  getAbsoluteUrl(stringify = true) {\n    return stringify ? this._url : URI(this._url);\n  }\n\n  /**\n   * Sets the absolute URL of the STAC entity.\n   * \n   * @param {string} url Absolute URL\n   */\n  setAbsoluteUrl(url) {\n    this._url = url;\n  }\n\n  /**\n   * \n   * @todo\n   * @param {string} rel \n   * @param {boolean} allowUndefined \n   * @returns {Array.<Link>}\n   */\n  getStacLinksWithRel(rel, allowUndefined = true) {\n    return this.getLinksWithRels([rel])\n      .filter(link => isStacMediaType(link.type, allowUndefined));\n  }\n\n  /**\n   * \n   * @todo\n   * @param {string} rel \n   * @param {boolean} allowUndefined \n   * @returns {Link} \n   */\n  getStacLinkWithRel(rel, allowUndefined = true) {\n    const links = this.getStacLinksWithRel(rel, allowUndefined);\n    if (links.length > 0) {\n      return links[0];\n    }\n    else {\n      return null;\n    }\n  }\n  \n  /**\n   * \n   * @todo\n   * @returns {Array.<Link>}\n   */\n  getLinks() {\n    return Array.isArray(this.links) ? this.links.filter(link => isObject(link) && hasText(link.href)) : [];\n  }\n\n  /**\n   * \n   * @todo\n   * @param {string} rel \n   * @returns {Link} \n   */\n  getLinkWithRel(rel) {\n    return this.getLinks().find(link => link.rel === rel) || null;\n  }\n\n  /**\n   * \n   * @todo\n   * @param {Array.<string>} rels \n   * @returns {Array.<Link>} \n   */\n  getLinksWithRels(rels) {\n    return this.getLinks().filter(link => rels.includes(link.rel));\n  }\n\n  /**\n   * \n   * @todo\n   * @param {Array.<string>} rels \n   * @returns {Array.<Link>} \n   */\n  getLinksWithOtherRels(rels) {\n    return this.getLinks().filter(link => !rels.includes(link.rel));\n  }\n\n  /**\n   * Returns the self link, if present.\n   * \n   * @returns {Link|null} The self link\n   */\n  getSelfLink() {\n    return this.getStacLinkWithRel('self');\n  }\n\n  /**\n   * Returns the root link, if present.\n   * \n   * @returns {Link|null} The root link\n   */\n  getRootLink() {\n    return this.getStacLinkWithRel('root');\n  }\n\n  /**\n   * Returns the parent link, if present.\n   * \n   * @returns {Link|null} The parent link\n   */\n  getParentLink() {\n    return this.getStacLinkWithRel('parent');\n  }\n  \n}\n\nexport default STACHypermedia;\n","import STACHypermedia from './hypermedia.js';\n\n/**\n * A STAC API Collection (i.e. an ItemCollection or a CollectionCollection)\n * \n * You can access all properties of the given STAC Catalog object directly, e.g. `collection.links`.\n * \n * Don't instantiate this class!\n * \n * @interface\n * @param {Object} data The STAC API Collection object\n * @param {string|null} absoluteUrl Absolute URL of the STAC Item Collection\n * @param {Object.<string, function>} keyMap Keys and functions that convert the values to stac-js objects.\n * @param {Array.<string>} privateKeys Keys that are private members of the stac-js objects (for cloning and export).\n */\nclass APICollection extends STACHypermedia {\n\n  constructor(data, absoluteUrl = null, keyMap = {}, privateKeys = []) {\n    super(data, absoluteUrl, keyMap, privateKeys);\n  }\n\n  /**\n   * Returns all STAC entities in this list.\n   * \n   * @returns {Array.<STAC>} All STAC entities\n   */\n  getAll() {\n    return [];\n  }\n\n}\n\nexport default APICollection;\n","import { getMinMaxValues, getNoDataValues } from \"./utils.js\";\nimport STACObject from './object.js';\n\n/**\n * A STAC Band.\n * \n * You can access all properties of the given STAC Band object directly, e.g., `band.name`.\n * \n * @class\n * @property {string} name\n * \n * @param {Object|Band} data The STAC Band object\n * @param {number|string} index The band index\n * @param {Collection|Item|Asset|null} context The object that contains the band\n */\nclass Band extends STACObject {\n\n  constructor(data, index = null, context = null) {\n    super(data, {}, ['_index', '_context']);\n    if (typeof this._index !== 'number') {\n      this._index = typeof index === 'string' ? parseInt(index, 10) : index;\n    }\n    if (!this._context) {\n      this._context = context;\n    }\n  }\n\n  /**\n   * Returns the STAC entity that contains the band.\n   * \n   * @returns {Collection|Item|Asset|null}\n   */\n  getContext() {\n    return this._context;\n  }\n\n  /**\n   * Returns the type of the STAC object, here: 'Band'.\n   * \n   * @returns {string}\n   */\n  getObjectType() {\n    return \"Band\";\n  }\n\n  /**\n   * Check whether this given object is a STAC Band.\n   * \n   * @returns {boolean} `true` if the object is a STAC Band, `false` otherwise.\n   */\n  isBand() {\n    return true;\n  }\n\n  /**\n   * Returns the index of the band.\n   * \n   * @returns {number|null} Index of the band\n   */\n  getIndex() {\n    return this._index;\n  }\n\n  /**\n   * Returns the metadata for the given field name.\n   * \n   * Returns the metadata from the asset, if present.\n   * Otherwise, returns the metadata from calling `getMetadata()` on the STAC entity that contains the asset.\n   * \n   * @param {string} field Field name\n   * @returns {*} The value of the field\n   */\n  getMetadata(field) {\n    if (typeof this[field] !== 'undefined') {\n      return this[field];\n    }\n    if (this._context) {\n      return this._context.getMetadata(field);\n    }\n    return undefined;\n  }\n\n  /**\n   * Gets the reported minimum and maximum values for a band.\n   * \n   * Searches through different extension fields in raster, classification, and file.\n   * \n   * @returns {Statistics}\n   */\n  getMinMaxValues() {\n    return getMinMaxValues(this);\n  }\n\n  /**\n   * Gets the reported no-data values for a band.\n   * \n   * Searches through different extension fields in raster, classification, and file.\n   * \n   * @returns {Array.<*>}\n   */\n  getNoDataValues() {\n    return getNoDataValues(this);\n  }\n\n  /**\n   * Converts an object of STAC Bands into an array of stac-js Bands.\n   * \n   * @param {Array.<Object>} bands Bands\n   * @param {Collection|Item|Asset|null} context The object that contains the bands\n   * @returns {Array.<Band>} Improved Bands\n   */\n  static fromBands(bands, context = null) {\n    let newBands = [];\n    if(Array.isArray(bands)) {\n      for(let i in bands) {\n        const b = bands[i];\n        const newBand = b instanceof Band ? b : new Band(b, i, context);\n        newBands.push(newBand);\n      }\n    }\n    return newBands;\n  }\n\n}\n\nexport default Band;\n","import { getMinMaxValues, getNoDataValues, hasText, isObject } from \"./utils.js\";\nimport STACReference from './reference.js';\nimport Band from \"./band.js\";\n\nconst NO_INHERITANCE = [\n  'created',\n  'updated',\n  'published',\n  'expires',\n  'unpublished',\n  'bands'\n];\n\n/**\n * A STAC Asset or Item Asset Definition.\n * \n * You can access all properties of the given STAC Asset object directly, e.g., `asset.href`.\n * \n * @class\n * @property {string} href\n * @property {?string} title\n * @property {?string} description\n * @property {?string} type\n * @property {?Array.<string>} roles\n * \n * @param {Object|Asset} data The STAC Asset object\n * @param {string} key The asset key\n * @param {Collection|Item|null} context The object that contains the asset\n */\nclass Asset extends STACReference {\n\n  constructor(data, key = null, context = null) {\n    const keyMap = {\n      bands: Band.fromBands,\n      alternate: Asset.fromAssets\n    };\n    super(data, context, keyMap, ['_key']);\n    if (!this._key) {\n      this._key = key;\n    }\n  }\n\n  /**\n   * Returns the type of the STAC object, here: 'Asset'.\n   * \n   * @returns {string}\n   */\n  getObjectType() {\n    return \"Asset\";\n  }\n\n  /**\n   * Check whether this given object is a STAC Asset.\n   * \n   * @returns {boolean} `true` if the object is a STAC Asset, `false` otherwise.\n   */\n  isAsset() {\n    return true;\n  }\n\n  /**\n   * Gets the URL of the asset as absolute URL.\n   * \n   * @param {boolean} stringify If `true` (default), a string is returned, otherwise a URI object.\n   * @returns {URI|string|null}\n   */\n  getAbsoluteUrl(stringify = true) {\n    if (this.isDefinition()) {\n      return null;\n    }\n    return super.getAbsoluteUrl(stringify);\n  }\n\n  /**\n   * Returns the key of the asset.\n   * \n   * @returns {string|null} Key of the asset\n   */\n  getKey() {\n    return this._key;\n  }\n\n  /**\n   * Returns the metadata for the given field name.\n   * \n   * Returns the metadata from the asset, if present.\n   * Otherwise, returns the metadata from calling `getMetadata()` on the STAC entity that contains the asset.\n   * \n   * @param {string} field Field name\n   * @returns {*} The value of the field\n   */\n  getMetadata(field) {\n    if (typeof this[field] !== 'undefined') {\n      return this[field];\n    }\n    // Check whether this is an alternate asset\n    if (this._context instanceof Asset) {\n      return this._context.getMetadata(field);\n    }\n    // This should be a Collection or Item, we can inherit most fields\n    if (this._context && !NO_INHERITANCE.includes(field)) {\n      return this._context.getMetadata(field);\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns the bands for the asset.\n   * \n   * @returns {Array.<Band>}\n   */\n  getBands() {\n    return this.bands || [];\n  }\n\n  /**\n   * The RGB bands.\n   * \n   * @typedef {Object} VisualBands\n   * @property {Band} red The red band with its index\n   * @property {Band} green The green band with its index\n   * @property {Band} blue The blue band with its index\n   */\n\n  /**\n   * Find the RGB bands.\n   * \n   * @returns {VisualBands|null} Object with the RGB bands or null\n   */\n  findVisualBands() {\n    const rgb = {\n      red: null,\n      green: null,\n      blue: null\n    };\n    const bands = this.getBands();\n    for(const key in bands) {\n      const index = parseInt(key, 10); // for loop may return strings as keys\n      const band = bands[index];\n      if (isObject(band) && hasText(band['eo:common_name']) && band['eo:common_name'] in rgb) {\n        rgb[band['eo:common_name']] = band;\n      }\n    }\n    const complete = Object.values(rgb).every(o => o !== null);\n    return complete ? rgb : null;\n  }\n\n  /**\n   * Returns the band for the given criteria.\n   * \n   * Searches the given `property` (default: `name`) for the given value(s).\n   * \n   * @param {*} value A single value to find or a list of values to find one of.\n   * @param {string} property The property in the bands to match against.\n   * @returns {Band|null}\n   * @see {getBands}\n   */\n  findBand(value, property = 'name') {\n    if (!Array.isArray(value)) {\n      value = [value];\n    }\n    const bands = this.getBands();\n    const index = bands.findIndex(band => isObject(band) && value.includes(band[property]));\n    if (index >= 0) {\n      return bands[index];\n    }\n    return null;\n  }\n\n  /**\n   * Returns the band for the given band index.\n   * \n   * Passes through the (band) objects.\n   * \n   * @param {number|Object} band\n   * @returns {Object|null}\n   * @see {getBands}\n   */\n  getBand(band) {\n    if (isObject(band) || band === null) {\n      return band;\n    }\n    const bands = this.getBands();\n    return bands[band] || null;\n  }\n\n  /**\n   * Gets the reported minimum and maximum values for an asset.\n   * \n   * Searches through different extension fields in raster, classification, and file.\n   * \n   * @returns {Statistics}\n   */\n  getMinMaxValues() {\n    return getMinMaxValues(this);\n  }\n\n  /**\n   * Gets the reported no-data values for an asset.\n   * \n   * Searches through different extension fields in nodata, classification, and file.\n   * \n   * @returns {Array.<*>}\n   */\n  getNoDataValues() {\n    return getNoDataValues(this);\n  }\n\n  /**\n   * Returns whether this asset is an Item Asset definition (i.e., doesn't have an href) or not.\n   * \n   * @returns {boolean} `true` if this asset is an Item Asset definition, `false` otherwise.\n   */\n  isDefinition() { // \n    return !hasText(this.href);\n  }\n\n  /**\n   * Checks whether the asset is accessible via HTTP or HTTPS.\n   * \n   * Returns `null` for item asset definitions, otherwise a `boolean` value.\n   * \n   * @returns {boolean|null} `true` if this asset is available via HTTP or HTTPS, `false` or `null` otherwise.\n   */\n  isHTTP() {\n    if (this.isDefinition()) {\n      return null;\n    }\n    return super.isHTTP();\n  }\n\n  /**\n   * Returns whether the asset is a preview image (thumbnail / overview).\n   * \n   * An asset is a preview if one of the roles is 'thumbnail' or 'overview'.\n   * it is also a preview if the key is 'thumbnail' or 'overview'.\n   * \n   * @returns {boolean} `true` if the asset is a preview, `false` otherwise.\n   */\n  isPreview() {\n    const roles = ['thumbnail', 'overview'];\n    if (roles.includes(this.getKey())) {\n      return true;\n    }\n    return Array.isArray(this.roles) && this.roles.some(role => roles.includes(role));\n  }\n\n  /**\n   * Checks whether this asset has a specific role assigned.\n   * \n   * @param {string|Array.<string>} roles One or more roles.\n   * @param {boolean} includeKey Also returns `true` if the asset key equals to one of the given roles.\n   * @returns {boolean} `true` if this asset is one of the given roles (or key), `false` otherwise.\n   */\n  hasRole(roles, includeKey = false) { // string or array of strings\n    if (!Array.isArray(roles)) {\n      roles = [roles];\n    }\n    if (includeKey && roles.includes(this.getKey())) {\n      return true;\n    }\n    return Array.isArray(this.roles) && (Boolean(this.roles.find(role => roles.includes(role))));\n  }\n\n  /**\n   * Converts an object of STAC Assets into an object of stac-js Assets.\n   * \n   * @param {Object.<string, Object>} assets Assets\n   * @param {Collection|Item|null} context The object that contains the assets\n   * @returns {Object.<string, Asset>} Improved Assets\n   */\n  static fromAssets(assets, context = null) {\n    let newAssets = {};\n    if(isObject(assets)) {\n      for(let i in assets) {\n        const a = assets[i];\n        const newAsset = a instanceof Asset ? a : new Asset(a, i, context);\n        newAssets[i] = newAsset;\n      }\n    }\n    return newAssets;\n  }\n\n}\n\nexport default Asset;\n","// This code is based on https://github.com/cherry-projects/locale-id\r\n// Due to the \"heavy\" dependencies, it has been slimmed down\r\n\r\n// http://userguide.icu-project.org/locale\r\nexport default function parse(locale) {\r\n  if (!locale) {\r\n    return undefined;\r\n  }\r\n\r\n  // extract keyword\r\n  const stringLocale = String(locale);\r\n  const keywordPos = stringLocale.indexOf('@');\r\n\r\n  const keyword = keywordPos !== -1\r\n    ? stringLocale.substr(keywordPos + 1)\r\n    : undefined;\r\n\r\n  const localeWithoutKeyword = keywordPos !== -1\r\n    ? stringLocale.substr(0, keywordPos)\r\n    : stringLocale;\r\n\r\n  // en-us => en_us\r\n  const parts = String(localeWithoutKeyword)\r\n    .replace(/-/g, '_')\r\n    .split('_');\r\n\r\n  if (!parts.length || parts.length > 4) {\r\n    return undefined;\r\n  }\r\n\r\n  const language = parts.shift();\r\n  if (!language) {\r\n    return undefined;\r\n  }\r\n\r\n  const retVar = {\r\n    keyword,\r\n    language: language.toLowerCase(),\r\n  };\r\n\r\n  if (!parts.length) {\r\n    return retVar;\r\n  }\r\n\r\n  if (parts.length === 3) {\r\n    const variant = parts.pop();\r\n    if (variant) {\r\n      retVar.variant = variant.toUpperCase();\r\n    }\r\n  }\r\n\r\n  let country = parts.pop();\r\n  if (country.length > 3) {\r\n    retVar.keyword = country;\r\n\r\n    country = parts.pop();\r\n  }\r\n\r\n  if (country) {\r\n    retVar.country = country.toUpperCase();\r\n  }\r\n\r\n  if (!parts.length) {\r\n    return retVar;\r\n  }\r\n\r\n  const script = parts.pop();\r\n  if (typeof script === 'string' && script.length >= 1) {\r\n    retVar.script = script[0].toUpperCase() + script.substring(1).toLowerCase();\r\n  }\r\n\r\n  return retVar;\r\n}\r\n\r\nexport function normalize(locale, delimeter = '_') {\r\n  const obj = parse(locale);\r\n  if (!obj) {\r\n    return obj;\r\n  }\r\n\r\n  let result = obj.language;\r\n\r\n  if (obj.script) {\r\n    result += `${delimeter}${obj.script}`;\r\n  }\r\n\r\n  if (obj.country) {\r\n    result += `${delimeter}${obj.country}`;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nconst splitAcceptLanguageRegEx = /([a-z]{1,8}(-[a-z]{1,8})?)\\s*(;\\s*q\\s*=\\s*(1|0\\.[0-9]+))?/ig;\r\nconst acceptLanguageItemRegEx = /^([a-z]{1,8}(-[a-z]{1,8})?)/i;\r\n\r\nexport function normalizeAcceptLanguage(acceptLanguage) {\r\n  const returnItems = [];\r\n  if (!acceptLanguage) {\r\n    return returnItems;\r\n  }\r\n\r\n  const items = acceptLanguage.match(splitAcceptLanguageRegEx) || [];\r\n  items.forEach(acceptLanguageItem => {\r\n    const matches = acceptLanguageItem.match(acceptLanguageItemRegEx) || [];\r\n    const locale = normalize(matches[0]);\r\n    if (locale) {\r\n      returnItems.push(locale);\r\n    }\r\n  });\r\n\r\n  return returnItems;\r\n}\r\n\r\nexport function prepareSupported(supported) {\r\n  const lgs = {};\r\n\r\n  supported.forEach(supportedLocale => {\r\n    const { language, country } = parse(supportedLocale);\r\n    if (!language) {\r\n      throw new Error(`Locale ${supportedLocale} is not parsable`);\r\n    }\r\n\r\n    if (!lgs[language]) {\r\n      lgs[language] = {\r\n        countries: {},\r\n        firstCountry: undefined,\r\n        main: undefined,\r\n      };\r\n    }\r\n\r\n    const lg = lgs[language];\r\n    if (country) {\r\n      lg.countries[country] = supportedLocale;\r\n\r\n      if (!lg.firstCountry) {\r\n        lg.firstCountry = supportedLocale;\r\n      }\r\n    } else {\r\n      lg.main = supportedLocale;\r\n    }\r\n  });\r\n\r\n  return lgs;\r\n}\r\n\r\nexport function getBest(supported, locale, defaultLocale, getAnyCountry) {\r\n  const lgs = Array.isArray(supported) ? prepareSupported(supported) : supported;\r\n\r\n  // return defaultLocale if current locale is undefined\r\n  if (!locale && defaultLocale) {\r\n    return getBest(supported, defaultLocale, undefined, getAnyCountry);\r\n  }\r\n\r\n  if (!locale) {\r\n    return undefined;\r\n  }\r\n\r\n  const { language, country } = parse(locale);\r\n  if (!language) {\r\n    return defaultLocale;\r\n  }\r\n\r\n  // selected locale is not supported\r\n  if (!lgs[language]) {\r\n    if (locale === defaultLocale) {\r\n      return undefined;\r\n    }\r\n\r\n    return getBest(supported, defaultLocale, null, getAnyCountry);\r\n  }\r\n\r\n  const { countries, main = defaultLocale, firstCountry } = lgs[language];\r\n  if (!countries || !country) {\r\n    if (getAnyCountry && firstCountry) {\r\n      return firstCountry;\r\n    }\r\n\r\n    return main;\r\n  }\r\n\r\n  if (getAnyCountry && firstCountry) {\r\n    return countries[country] ? countries[country] : firstCountry;\r\n  }\r\n\r\n  return countries[country] ? countries[country] : main;\r\n}\r\n","import { geotiffMediaTypes, isMediaType } from './mediatypes.js';\nimport { isObject, hasText } from './utils.js';\nimport STACHypermedia from './hypermedia.js';\nimport { getBest } from './locales.js';\n\n/**\n * Class for STAC spec entities (Item, Catalog and Collection).\n * \n * Don't instantiate this class!\n * \n * @interface\n * @param {Object} data The STAC object\n * @param {string|null} absoluteUrl Absolute URL of the STAC object\n * @param {Object.<string, function>} keyMap Keys and functions that convert the values to stac-js objects.\n * @param {Array.<string>} privateKeys Keys that are private members of the stac-js objects (for cloning and export).\n */\nclass STAC extends STACHypermedia {\n\n  constructor(data, absoluteUrl = null, keyMap = {}, privateKeys = []) {\n    super(data, absoluteUrl, keyMap, privateKeys);\n  }\n\n  /**\n   * Returns a single temporal extent for the STAC entity.\n   * \n   * @returns {Array.<Date|null>|null}\n   */\n  getTemporalExtent() {\n    return null;\n  }\n\n  /**\n   * Returns the temporal extent(s) for the STAC entity.\n   * \n   * @returns {Array.<Array.<Date|null>>}\n   */\n  getTemporalExtents() {\n    return [];\n  }\n\n  /**\n   * Get the \"best\" link for a specific locale (with fallback).\n   * \n   * @param {string} locale \n   * @param {?string} fallbackLocale \n   * @returns {Link|null} The link with the given locale or null if not found.\n   * @see {@link getBest}\n   */\n  getLocaleLink(locale, fallbackLocale = null) {\n    let links = this.getStacLinksWithRel('alternate')\n      .filter(link => hasText(link.hreflang));\n    \n    let available;\n    if (Array.isArray(this.languages)) {\n      available = this.languages.map(l => l.code);\n    }\n    else {\n      available = links.map(link => link.hreflang);\n    }\n    \n    let best = getBest(available, locale, fallbackLocale);\n    return links.find(link => link.hreflang === best) || null;\n  }\n\n  /**\n   * Get the icons from the links in a STAC entity.\n   * \n   * @param {boolean} allowUndefined \n   * @returns {Array.<Link>}\n   */\n  getIcons(allowUndefined = true) {\n    return this.getLinksWithRels(['icon'])\n      .filter(img => img.canBrowserDisplayImage(allowUndefined));\n  }\n\n  /**\n   * Get the thumbnails from the assets and links in a STAC entity.\n   * \n   * @param {boolean} browserOnly - Return only images that can be shown in a browser natively (PNG/JPG/GIF/WEBP + HTTP/S).\n   * @param {string|null} prefer - If not `null` (default), prefers a role over the other. Either `thumbnail` or `overview`.\n   * @returns {Array.<STACReference>} Asset or Link\n   */\n  getThumbnails(browserOnly = true, prefer = null) {\n    let thumbnails = this.getAssets().filter(asset => asset.isPreview());\n    // Get from links only if no assets are available as they should usually be the same as in assets\n    if (thumbnails.length === 0) {\n      thumbnails = this.getLinks().filter(link => link.isPreview());\n    }\n    // Some old catalogs use just a asset key\n    if (thumbnails.length === 0) {\n      const thumbnail = this.getAsset(\"thumbnail\");\n      if (thumbnail) {\n        thumbnails.push(thumbnail);\n      }\n    }\n    if (browserOnly) {\n      // Remove all images that can't be displayed in a browser\n      thumbnails = thumbnails.filter(img => img.canBrowserDisplayImage());\n    }\n    if (prefer && thumbnails.length > 1) {\n      // Prefer one role over the other.\n      // The two step approach with two filters ensures the same sort bevahiour across all browsers:\n      // see https://github.com/radiantearth/stac-browser/issues/370\n      let filter = img => (Array.isArray(img.roles) && img.roles.includes(prefer)) || (img.getKey() === prefer);\n      thumbnails = thumbnails\n        .filter(filter)\n        .concat(thumbnails.filter(img => !filter(img)));\n    }\n    return thumbnails;\n  }\n\n  /**\n   * Determines the default GeoTiff asset for visualization.\n   * \n   * @param {boolean} httpOnly Return only GeoTiffs that can be accessed via HTTP(S)\n   * @param {boolean} cogOnly Return only COGs\n   * @returns {Asset} Default GeoTiff asset\n   * @see {rankGeoTIFFs}\n   */\n  getDefaultGeoTIFF(httpOnly = true, cogOnly = false) {\n    let scores = this.rankGeoTIFFs(httpOnly, cogOnly);\n    return scores[0]?.asset;\n  }\n\n  /**\n   * Object with an asset and the corresponding score.\n   * \n   * @typedef {Object} AssetScore\n   * @property {Asset} asset\n   * @property {number} score\n   */\n\n  /**\n   * A function that can influence the score.\n   * \n   * Returns a relative addition to the score.\n   * Negative values subtract from the score.\n   * \n   * @callback STAC~rankGeoTIFFs\n   * @param {Asset} asset The asset to calculate the score for.\n   */\n\n  /**\n   * Ranks the GeoTiff assets for visualization purposes.\n   * \n   * The score factors can be found below:\n   * - Roles/Keys (by default) - if multiple roles apply only the highest score is added:\n   *   - overview => +3\n   *   - thumbnail => +2\n   *   - visual => +2\n   *   - data => +1\n   *   - none of the above => no change\n   * - Other factors:\n   *   - media type is COG: +2 (if cogOnly = false)\n   *   - has RGB bands: +1\n   *   - additionalCriteria: +/- a custom value\n   * \n   * @param {boolean} httpOnly Return only GeoTiffs that can be accessed via HTTP(S)\n   * @param {boolean} cogOnly Return only COGs\n   * @param {Object.<string, number>} roleScores Roles (and keys) considered for the scoring. They key is the role name, the value is the score. Higher is better. Defaults to the roles and scores detailed above. An empty object disables role-based scoring.\n   * @param {STAC~rankGeoTIFFs} additionalCriteria A function to customize the score by adding/subtracting.\n   * @returns {Array.<AssetScore>} GeoTiff assets sorted by score in descending order.\n   */\n  rankGeoTIFFs(httpOnly = true, cogOnly = false, roleScores = null, additionalCriteria = null) {\n    if (!isObject(roleScores)) {\n      roleScores = {\n        data: 1, \n        visual: 2,\n        thumbnail: 2,\n        overview: 3\n      };\n    }\n    let scores = [];\n    let assets = this.getAssetsByTypes(geotiffMediaTypes);\n    if (httpOnly) {\n      assets = assets.filter(asset => asset.isHTTP() && (!cogOnly || asset.isCOG()));\n    }\n    let roles = Object.entries(roleScores);\n    for(let asset of assets) {\n      let score = 0;\n      if (roles.length > 0) {\n        let result = roles\n          .filter(([role]) => asset.hasRole(role, true)) // Remove all roles that don't exist in the asset\n          .map(([,value]) => value); // Map to the scores\n        if (result.length > 0) {\n          score += Math.max(...result); // Add the highest of the scores\n        }\n      }\n      if (!cogOnly && asset.isCOG()) {\n        score += 2;\n      }\n      if (asset.findVisualBands()) {\n        score += 1;\n      }\n      if (typeof additionalCriteria === 'function') {\n        score += additionalCriteria(asset);\n      }\n\n      scores.push({asset, score});\n    }\n    scores.sort((a,b) => b.score - a.score);\n    return scores;\n  }\n\n  /**\n   * The single-band assets for RGB composites.\n   * \n  * @typedef {Object} VisualAssets\n  * @property {Band} red The red band with its index\n  * @property {Band} green The green band with its index\n  * @property {Band} blue The blue band with its index\n  */\n\n  /**\n   * Find the single-band assets for RGB.\n   * \n   * @returns {VisualAssets|null} Object with the RGB bands or null\n   */\n  findVisualAssets() {\n    let rgb = {\n      red: null,\n      green: null,\n      blue: null\n    };\n    let names = Object.keys(rgb);\n    let assets = this.getAssets();\n    for(let asset of assets) {\n      let result = asset.findBand(names, 'eo:common_name');\n      if (result) {\n        rgb[result[\"eo:common_name\"]] = asset;\n      }\n    }\n    let complete = Object.values(rgb).every(o => o !== null);\n    return complete ? rgb : null;\n  }\n\n  /**\n   * \n   * @todo\n   * @param {string} key\n   * @returns {Asset|null}\n   */\n  getAsset(key) {\n    if (!isObject(this.assets)) {\n      return null;\n    }\n    return this.assets[key] || null;\n  }\n\n  /**\n   * \n   * @todo\n   * @returns {Array.<Asset>}\n   */\n  getAssets() {\n    if (!isObject(this.assets)) {\n      return [];\n    }\n    return Object.values(this.assets);\n  }\n\n  /**\n   * Returns all assets that contain at least one of the given roles.\n   * \n   * @param {string|Array.<string>} roles One or more roles.\n   * @param {boolean} includeKey Also returns `true` if the asset key equals to one of the given roles.\n   * @returns {Array.<Asset>} The assets with the given roles.\n   */\n  getAssetsWithRoles(roles, includeKey = false) {\n    return this.getAssets().filter(asset => asset.hasRole(roles, includeKey));\n  }\n\n  /**\n   * \n   * @todo\n   * @param {string} role \n   * @param {boolean} includeKey \n   * @returns {Asset|null}\n   */\n  getAssetWithRole(role, includeKey = false) {\n    let assets = this.getAssetsWithRoles([role], includeKey);\n    return assets[0] || null;\n  }\n\n  /**\n   * \n   * @todo\n   * @param {Array.<string>} types \n   * @returns {Array.<Asset>}\n   */\n  getAssetsByTypes(types) {\n    return this.getAssets().filter(asset => isMediaType(asset.type, types));\n  }\n\n  /**\n   * \n   * @todo\n   * @param {*} other \n   * @returns {boolean}\n   */\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof STAC)) {\n      return false;\n    }\n    if (this.getObjectType() !== other.getObjectType()) {\n      return false;\n    }\n    if (this.id && this.id === other.id) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Checks whether a specific extension is implemented.\n   * \n   * The pattern can contain `*` as a wildcard, e.g. for version numbers.\n   * \n   * @param {string} pattern The extension URI to check for.\n   * @returns {boolean} `true` if the extension is implemented, `false` otherwise.\n   */\n  supportsExtension(pattern) {\n    if (!Array.isArray(this.stac_extensions)) {\n      return false;\n    }\n    let regexp = new RegExp('^' + pattern.replaceAll('*', '[^/]+') + '$');\n    return this.stac_extensions.some(uri => regexp.test(uri));\n  }\n\n}\n\nexport default STAC;\n","import STAC from './stac.js';\n\n/**\n * Class for common parts of Catalogs and Collections.\n * \n * Don't instantiate this class!\n * \n * @interface\n * @param {Object} data The STAC Catalog or Collection object\n * @param {string|null} absoluteUrl Absolute URL of the STAC Catalog or Collection\n * @param {Object.<string, function>} keyMap Keys and functions that convert the values to stac-js objects.\n * @param {Array.<string>} privateKeys Keys that are private members of the stac-js objects (for cloning and export).\n */\nclass CatalogLike extends STAC {\n\n  constructor(data, absoluteUrl = null, keyMap = {}, privateKeys = []) {\n    super(data, absoluteUrl, keyMap, privateKeys);\n  }\n\n  /**\n   * Returns the type of the STAC object, here: 'Catalog' or 'Collection'.\n   * \n   * @returns {string}\n   */\n  getObjectType() {\n    return this.type;\n  }\n\n  /**\n   * Returns the search link, if present.\n   * \n   * If a specific method is provied, can exclude other methods from being returned.\n   * \n   * @returns {Link|null} The search link\n   */\n  getSearchLink(method = null) {\n    let links = this.getStacLinksWithRel('search');\n    if (!method) {\n      return links.find(link => link.method === method || (!method && !link.method)) || null;\n    }\n    else {\n      return links[0] || null;\n    }\n  }\n\n  /**\n   * Returns the link for API collections, if present.\n   * \n   * @returns {Link|null} The API collections link\n   */\n  getApiCollectionsLink() {\n    return this.getStacLinkWithRel('data');\n  }\n\n  /**\n   * Returns the link for API items, if present.\n   * \n   * @returns {Link|null} The API items link\n   */\n  getApiItemsLink() {\n    return this.getStacLinkWithRel('items');\n  }\n\n  /**\n   * Returns all child links.\n   * \n   * @returns {Array.<Link>} The child links\n   */\n  getChildLinks() {\n    return this.getStacLinksWithRel('child');\n  }\n\n  /**\n   * Returns all item links.\n   * \n   * @returns {Array.<Link>} The child links\n   */\n  getItemLinks() {\n    return this.getStacLinksWithRel('item');\n  }\n\n}\n\nexport default CatalogLike;\n","import CatalogLike from './cataloglike.js';\n\n/**\n * A STAC Catalog.\n * \n * You can access all properties of the given STAC Catalog object directly, e.g. `catalog.title`.\n * \n * @class\n * @property {string} stac_version\n * @property {?Array.<string>} stac_extensions\n * @property {string} type\n * @property {string} id\n * @property {?string} title\n * @property {string} description\n * @property {Array.<Link>} links\n * \n * @param {Object} data The STAC Catalog object\n * @param {string|null} absoluteUrl Absolute URL of the STAC Catalog\n */\nclass Catalog extends CatalogLike {\n\n  constructor(data, absoluteUrl = null) {\n    super(data, absoluteUrl);\n  }\n\n}\n\nexport default Catalog;\n","import { hasText } from \"./utils.js\";\n\n/**\n * Parses a UTC-based ISO8601 date and time string to a Date object.\n * \n * Does not support timezones as all STAC datetime must be given in UTC.\n * \n * @returns {Date|null}\n */\nexport function isoToDate(str) {\n  if (hasText(str) && str.length >= 10) {\n    try {\n      let strParts = str.match(/^(-?\\d{1,})-(\\d\\d)-(\\d\\d)[T ](\\d\\d):(\\d\\d):(\\d\\d)(?:\\.(\\d*))?(?:Z|[+-]00:00)?$/i);\n      let dt = strParts.slice(1).map(n => parseInt(n, 10));\n      return new Date(Date.UTC(dt[0], dt[1] - 1, dt[2], dt[3], dt[4], dt[5], dt[6] || 0));\n    } catch {\n      return null;\n    }\n  }\n  return null;\n}\n\n/**\n * Computes the center datetime between two datetimes.\n * \n * @param {Date} start start datetime\n * @param {Date} end end datetime\n * @returns {Date} center datetime\n */\nexport function centerDateTime(start, end) {\n  return new Date(start.valueOf() + ((end - start) / 2));\n}\n\n/**\n * Computes a single interval from multiple temporal intervals.\n * \n * @param {Array.<Array.<Date>>} list A list of temporal intervals\n * @returns {Array.<Date>|null} The merged temporal interval\n */\nexport function unionDateTime(list) {\n  if (!Array.isArray(list) || list.length === 0) {\n    return null;\n  }\n\n  let min;\n  let max;\n  const assign = (base, value, fn) => {\n    if (typeof base === 'undefined') {\n      return value;\n    }\n    else if (base === null || value === null) {\n      return null;\n    }\n    else {\n      return fn(base, value);\n    }\n  };\n  list.forEach(([start, end]) => {\n    min = assign(min, start, Math.min);\n    max = assign(max, end, Math.max);\n  });\n  return [\n    min === null ? null : new Date(min),\n    max === null ? null : new Date(max)\n  ];\n}\n","import Asset from './asset.js';\nimport Band from './band.js';\nimport CatalogLike from './cataloglike.js';\nimport { isoToDate } from './datetime.js';\nimport { ensureBoundingBox, toGeoJSON } from './geo.js';\nimport { hasText, isObject } from './utils.js';\n\n/**\n * Extents\n * \n * @typedef {Object} Extent\n * @property {SpatialExtent} spatial Spatial extents\n * @property {TemporalExtent} temporal Temporal extents\n */\n/**\n * Spatial Extents\n * \n * @typedef {Object} SpatialExtent\n * @property {Array.<Array<number>>} bbox Bounding boxes\n */\n/**\n * Temporal Extents\n * \n * @typedef {Object} TemporalExtent\n * @property {Array.<Array<string|null>>} interval Intervals\n */\n\n/**\n * A STAC Collection.\n * \n * You can access all properties of the given STAC Collection object directly, e.g. `collection.title`.\n * \n * @class\n * @property {string} stac_version\n * @property {?Array.<string>} stac_extensions\n * @property {string} type\n * @property {string} id\n * @property {?string} title\n * @property {string} description\n * @property {?Array.<string>} keywords\n * @property {string} license\n * @property {Array.<Provider>} providers\n * @property {Extent} extent\n * @property {Object.<string, Array|Object>} summaries\n * @property {Array.<Link>} links\n * @property {Object.<string, Asset>} assets\n * \n * @param {Object} data The STAC Collection object\n * @param {string|null} absoluteUrl Absolute URL of the STAC Collection\n */\nclass Collection extends CatalogLike {\n\n  constructor(data, absoluteUrl = null) {\n    const keyMap = {\n      assets: Asset.fromAssets,\n      item_assets: Asset.fromAssets\n    };\n    super(data, absoluteUrl, keyMap);\n  }\n\n  /**\n   * Returns a GeoJSON Feature for this STAC Collection.\n   * \n   * The Feature contains a Polygon or MultiPolygon based on the given number of valid bounding boxes.\n   * \n   * @returns {Object|null} GeoJSON object or `null`\n   */\n  toGeoJSON() {\n    let geojson = toGeoJSON(this.getBoundingBoxes());\n    if (geojson) {\n      geojson.id = this.id;\n    }\n    return geojson;\n  }\n\n  /**\n   * Returns a single union 2D bounding box for the whole collection.\n   * \n   * @returns {BoundingBox|null}\n   */\n  getBoundingBox() {\n    let bboxes = this.getRawBoundingBoxes();\n    if (bboxes.length > 0) {\n      return ensureBoundingBox(bboxes[0]);\n    }\n    return null;\n  }\n\n  /**\n   * Returns the individual 2D bounding boxes for the collection,\n   * without the union bounding box if multiple bounding boxes are given.\n   * \n   * @returns {Array.<BoundingBox>}\n   */\n  getBoundingBoxes() {\n    let raw = this.getRawBoundingBoxes();\n    if (raw.length === 1) {\n      return [ensureBoundingBox(raw[0])];\n    }\n    else if (raw.length > 1) {\n      return raw.slice(1).map(ensureBoundingBox);\n    }\n    return null;\n  }\n\n  /**\n   * Returns all bounding boxes from the collection, including the union bounding box.\n   * \n   * @returns {Array.<BoundingBox>}\n   */\n  getRawBoundingBoxes() {\n    let extents = this.extent?.spatial?.bbox;\n    if (Array.isArray(extents) && extents.length > 0) {\n      return extents;\n    }\n    return [];\n  }\n\n  /**\n   * Returns a single temporal extent for the STAC Collection.\n   * \n   * @returns {Array.<Date|null>|null}\n   */\n  getTemporalExtent() {\n    return this.getTemporalExtents()[0] || null;\n  }\n\n  /**\n   * Returns the temporal extent(s) for the STAC Collection.\n   * \n   * @returns {Array.<Array.<Date|null>>}\n   */\n  getTemporalExtents() {\n    let extents = this.extent?.temporal?.interval;\n    if (Array.isArray(extents) && extents.length > 0) {\n      return extents\n        .filter(extent => Array.isArray(extent) && (hasText(extent[0]) || hasText(extent[1])))\n        .map(interval => interval.map(datetime => isoToDate(datetime)));\n    }\n    return [];\n  }\n\n  /**\n   * Returns metadata from the Collection summaries for the given field name.\n   * \n   * @param {string} field Field name\n   * @returns {Array.<*>|Object|undefined} The value of the field\n   */\n  getSummary(field) {\n    if (isObject(this.summaries)) {\n      return this.summaries[field];\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns the bands.\n   * \n   * @returns {Array.<Band>}\n   */\n  getBands() {\n    let bands = this.getMetadata('bands');\n    if (!Array.isArray(bands)) {\n      bands = this.getSummary('bands');\n    }\n    if (!Array.isArray(bands)) {\n      return [];\n    }\n    return Band.fromBands(bands, this);\n  }\n  \n}\n\nexport default Collection;\n","import Collection from './collection.js';\nimport { unionDateTime } from './datetime.js';\nimport { unionBoundingBox } from './geo.js';\nimport APICollection from './apicollection.js';\n\n/**\n * Represents an Collections containing Collections.\n * \n * @class\n * @property {Array.<Collection>} collections\n * @property {Array.<Link>} links\n * \n * @param {Object} data The STAC API Collections object\n * @param {string|null} absoluteUrl Absolute URL of the STAC Item Collection\n */\nclass CollectionCollection extends APICollection {\n\n  constructor(data, absoluteUrl = null) {\n    const keyMap = {\n      collections: collections => collections.map(\n        collection => collection instanceof Collection ? collection : new Collection(collection)\n      )\n    };\n    super(data, absoluteUrl, keyMap);\n  }\n\n  /**\n   * Returns the type of the STAC object, here: 'CollectionCollection'.\n   * \n   * @returns {string}\n   */\n  getObjectType() {\n    return \"CollectionCollection\";\n  }\n\n  /**\n   * Returns all collections.\n   * \n   * @returns {Array.<Collection>} All STAC Collections\n   */\n  getAll() {\n    return this.collections;\n  }\n\n  /**\n   * Check whether this given object is a STAC Collection of Collections (i.e. API Collections).\n   * \n   * @returns {boolean} `true` if the object is a STAC CollectionCollection, `false` otherwise.\n   */\n  isCollectionCollection() {\n    return true;\n  }\n\n  /**\n   * Returns a GeoJSON Feature Collection for this STAC object.\n   * \n   * @returns {Object|null} GeoJSON object or `null`\n   */\n  toGeoJSON() {\n    let features = this.collections\n      .map(collection => collection.toGeoJSON())\n      .filter(geojson => geojson !== null);\n    return {\n      type: \"FeatureCollection\",\n      features\n    };\n  }\n\n  /**\n   * Returns a single 2D bounding box for all the STAC collections.\n   * \n   * @returns {BoundingBox|null}\n   */\n  getBoundingBox() {\n    return unionBoundingBox(this.getBoundingBoxes());\n  }\n\n  /**\n   * Returns a list of 2D bounding boxes for all the STAC collections.\n   * \n   * @returns {Array.<BoundingBox>}\n   */\n  getBoundingBoxes() {\n    return this.collections.map(collection => collection.getBoundingBox());\n  }\n\n  /**\n   * Returns a single temporal extent for the all the STAC collections.\n   * \n   * @returns {Array.<Date|null>|null}\n   */\n  getTemporalExtent() {\n    return unionDateTime(this.getTemporalExtents());\n  }\n\n  /**\n   * Returns the temporal extent(s) for the all the STAC collections.\n   * \n   * @returns {Array.<Array.<Date|null>>}\n   */\n  getTemporalExtents() {\n    return this.collections.map(collection => collection.getTemporalExtent());\n  }\n\n}\n\nexport default CollectionCollection;\n","import Asset from './asset.js';\nimport { centerDateTime, isoToDate } from './datetime.js';\nimport { ensureBoundingBox } from './geo.js';\nimport { hasText } from './utils.js';\nimport STAC from './stac.js';\nimport Band from './band.js';\n\n/**\n * Metadata for an item, the item properties.\n * \n * @typedef {Object} ItemProperties\n * @property {string} datetime Date and Time\n */\n\n/**\n * A STAC Item.\n * \n * You can access all properties of the given STAC Item object directly, e.g. `item.id` or `item.properties.datetime`.\n * \n * @class\n * @property {string} stac_version\n * @property {?Array.<string>} stac_extensions\n * @property {string} type\n * @property {string} id\n * @property {Object|null} geometry\n * @property {?Array.<number>} bbox\n * @property {ItemProperties} properties\n * @property {Array.<Link>} links\n * @property {Object.<string, Asset>} assets\n * @property {?string} collection\n * \n * @param {Object} data The STAC Item object\n * @param {string|null} absoluteUrl Absolute URL of the STAC Item\n */\nclass Item extends STAC {\n  \n  constructor(data, absoluteUrl = null) {\n    super(data, absoluteUrl, { assets: Asset.fromAssets });\n  }\n\n  /**\n   * Returns the type of the STAC object, here: 'Item'.\n   * \n   * @returns {string}\n   */\n  getObjectType() {\n    return \"Item\";\n  }\n\n  /**\n   * Returns a GeoJSON Feature for this STAC object.\n   * \n   * @returns {Object|null} GeoJSON object or `null`\n   */\n  toGeoJSON() {\n    return this.toJSON();\n  }\n\n  /**\n   * Returns a single 2D bounding box for the item.\n   * \n   * @returns {BoundingBox|null}\n   */\n  getBoundingBox() {\n    return ensureBoundingBox(this.bbox);\n  }\n\n  /**\n   * Returns 2D bounding boxes for the item.\n   * \n   * @returns {Array.<BoundingBox>}\n   */\n  getBoundingBoxes() {\n    const bbox = this.getBoundingBox();\n    return bbox ? [bbox] : [];\n  }\n\n  /**\n   * Returns a datetime for the STAC Item.\n   * \n   * If no datetime but start or end datetime are specified, computes a datetime from them.\n   * \n   * @returns {Date|null}\n   */\n  getDateTime() {\n    let dt = isoToDate(this.properties.datetime);\n    if (!dt) {\n      let start = isoToDate(this.properties.start_datetime);\n      let end = isoToDate(this.properties.end_datetime);\n      if (start && end) {\n        return centerDateTime(start, end);\n      }\n      else {\n        return start || end;\n      }\n    }\n    return dt;\n  }\n\n  /**\n   * Returns a single temporal extent for the STAC Item.\n   * \n   * @returns {Array.<Date|null>|null}\n   */\n  getTemporalExtent() {\n    return this.getTemporalExtents()[0] || null;\n  }\n\n  /**\n   * Returns the temporal extent(s) for the STAC Item.\n   * \n   * @returns {Array.<Array.<Date|null>>}\n   */\n  getTemporalExtents() {\n    let dates = [];\n    if (hasText(this.properties.start_datetime) || hasText(this.properties.end_datetime)) {\n      dates = [[this.properties.start_datetime || null, this.properties.end_datetime || null]];\n    }\n    else if (hasText(this.properties.datetime)) {\n      dates = [[this.properties.datetime, this.properties.datetime]];\n    }\n    return dates.map(interval => interval.map(datetime => isoToDate(datetime)));\n  }\n\n  /**\n   * Returns metadata from the Item properties for the given field name.\n   * \n   * @param {string} field Field name\n   * @returns {*} The value of the field\n   */\n  getMetadata(field) {\n    return this.properties[field];\n  }\n\n  /**\n   * Returns the bands.\n   * \n   * @todo Merge bands from assets\n   * @returns {Array.<Band>}\n   */\n  getBands() {\n    const bands = this.getMetadata('bands');\n    if (Array.isArray(bands)) {\n      return Band.fromBands(bands, this);\n    }\n    else {\n      return [];\n    }\n  }\n\n  /**\n   * Returns the collection link, if present.\n   * \n   * @returns {Link|null} The collection link\n   */\n  getCollectionLink() {\n    return this.getStacLinkWithRel('collection');\n  }\n\n}\n\nexport default Item;\n","import { unionDateTime } from './datetime.js';\nimport { unionBoundingBox } from './geo.js';\nimport Item from './item.js';\nimport APICollection from './apicollection.js';\n\n/**\n * Represents an ItemCollection containing Items.\n * \n * @class\n * @property {string} type\n * @property {Array.<Item>} features\n * @property {Array.<Link>} links\n * \n * @param {Object} data The STAC Item Collection object\n * @param {string|null} absoluteUrl Absolute URL of the STAC Item Collection\n */\nclass ItemCollection extends APICollection {\n\n  constructor(data, absoluteUrl = null) {\n    const keyMap = {\n      features: features => features.map(\n        feature => feature instanceof Item ? feature : new Item(feature)\n      )\n    };\n    super(data, absoluteUrl, keyMap);\n  }\n\n  /**\n   * Returns the type of the STAC object, here: 'ItemCollection'.\n   * \n   * @returns {string}\n   */\n  getObjectType() {\n    return \"ItemCollection\";\n  }\n\n  /**\n   * Returns all items.\n   * \n   * @returns {Array.<Item>} All STAC Items\n   */\n  getAll() {\n    return this.features;\n  }\n\n  /**\n   * Returns a GeoJSON FeatureCollection for this STAC object.\n   * \n   * @returns {Object|null} GeoJSON object or `null`\n   */\n  toGeoJSON() {\n    return this.toJSON();\n  }\n\n  /**\n   * Returns a single 2D bounding box for all the STAC items.\n   * \n   * @returns {BoundingBox|null}\n   */\n  getBoundingBox() {\n    return unionBoundingBox(this.getBoundingBoxes());\n  }\n\n  /**\n   * Returns a list of 2D bounding boxes for all the STAC items.\n   * \n   * @returns {Array.<BoundingBox>}\n   */\n  getBoundingBoxes() {\n    return this.features.map(item => item.getBoundingBox());\n  }\n\n  /**\n   * Returns a single temporal extent for all the STAC items.\n   * \n   * @returns {Array.<Date|null>|null}\n   */\n  getTemporalExtent() {\n    return unionDateTime(this.getTemporalExtents());\n  }\n\n  /**\n   * Returns the temporal extent(s) for all the STAC items.\n   * \n   * @returns {Array.<Array.<Date|null>>}\n   */\n  getTemporalExtents() {\n    return this.features.map(item => item.getTemporalExtent());\n  }\n\n}\n\nexport default ItemCollection;\n","import Migrate from '@radiantearth/stac-migrate';\nimport APICollection from './apicollection.js';\nimport Asset from './asset.js';\nimport Catalog from './catalog.js';\nimport CatalogLike from './cataloglike.js';\nimport Collection from './collection.js';\nimport CollectionCollection from './collectioncollection.js';\nimport Item from './item.js';\nimport ItemCollection from './itemcollection.js';\nimport Link from './link.js';\nimport STACHypermedia from './hypermedia.js';\nimport STACObject from './object.js';\nimport STACReference from './reference.js';\nimport STAC from './stac.js';\n\n/**\n * Creates the corresponding object for a object that conforms to the STAC specification.\n * \n * This creates either a Catalog, a Collection or an Item instance.\n * By default it migrates the data to the latest STAC version, but doesn't update the version number.\n * \n * @param {Object} data The STAC object\n * @param {boolean} migrate `true` to migrate to the latest version, `false` otherwise\n * @param {boolean} updateVersionNumber `true` to update the version number (to the latest version), `false` otherwise. Only applies if `migrate` is set to `true`.\n * @returns {Catalog|Collection|CollectionCollection|Item|ItemCollection} The created object instance.\n */\nexport default function create(data, migrate = true, updateVersionNumber = false) {\n  if (migrate) {\n    data = Migrate.stac(data, updateVersionNumber);\n  }\n  if (data.type === 'Feature') {\n    return new Item(data);\n  }\n  else if (data.type === 'FeatureCollection') {\n    return new ItemCollection(data);\n  }\n  else if (data.type === 'Collection'|| (!data.type && typeof data.extent !== 'undefined' && typeof data.license !== 'undefined')) {\n    return new Collection(data);\n  }\n  else if (!data.type && Array.isArray(data.collections)) {\n    return new CollectionCollection(data);\n  }\n  else {\n    return new Catalog(data);\n  }\n}\n\nexport {\n  APICollection,\n  Asset,\n  Catalog,\n  CatalogLike,\n  Collection,\n  CollectionCollection,\n  Item,\n  ItemCollection,\n  Link,\n  STAC,\n  STACHypermedia,\n  STACObject,\n  STACReference\n};\n"],"names":["hasText","string","ensureNumber","num","min","max","delta","min2","max2","isObject","obj","getMinForDataType","str","getMaxForDataType","getMinMaxValues","object","stats","isComplete","statistics","histogram","classification","cls","values","map","data_type","getNoDataValues","nodata","common","file","value","toObject","bbox","hasZ","west","east","south","north","bboxToCoords","centerOfBoundingBox","ensureBoundingBox","point","isAntimeridianBoundingBox","x","toGeoJSON","bboxes","c","coordinates","list","geometry","allow3D","base","height","n","unionBoundingBox","extrema","key","fn","STACObject","data","keyMap","privateKeys","stringify","field","v","v2","browserProtocols","toAbsolute","href","baseUrl","normalizeUri","noParams","uri","URI","baseUri","baseUriPath","geojsonMediaType","stacMediaTypes","browserImageTypes","cogMediaTypes","geotiffMediaTypes","isMediaType","type","allowedTypes","allowUndefined","isStacMediaType","STACReference","context","protocol","extension","types","Link","links","link","STACHypermedia","absoluteUrl","self","url","rel","rels","APICollection","Band","index","bands","newBands","b","newBand","NO_INHERITANCE","Asset","rgb","band","o","property","roles","role","includeKey","assets","newAssets","a","newAsset","parse","locale","stringLocale","keywordPos","keyword","localeWithoutKeyword","parts","language","retVar","variant","country","script","prepareSupported","supported","lgs","supportedLocale","lg","getBest","defaultLocale","getAnyCountry","countries","main","firstCountry","STAC","fallbackLocale","available","l","best","img","browserOnly","prefer","thumbnails","asset","thumbnail","filter","httpOnly","cogOnly","roleScores","additionalCriteria","scores","score","result","names","other","pattern","regexp","CatalogLike","method","Catalog","isoToDate","dt","centerDateTime","start","end","unionDateTime","assign","Collection","geojson","raw","extents","extent","interval","datetime","CollectionCollection","collections","collection","Item","dates","ItemCollection","features","feature","item","create","migrate","updateVersionNumber","Migrate"],"mappings":"mJAMO,SAASA,EAAQC,EAAQ,CAC9B,OAAQ,OAAOA,GAAW,UAAYA,EAAO,OAAS,CACxD,CAWO,SAASC,EAAaC,EAAKC,EAAKC,EAAKC,EAAQ,KAAY,CAC9D,GAAI,OAAOH,GAAQ,SACjB,OAAO,KAET,MAAMI,EAAOH,EAAME,EACbE,EAAOH,EAAMC,EACnB,OAAIH,EAAMI,GAAQJ,EAAMK,EACf,KAGF,KAAK,IAAI,KAAK,IAAIL,EAAKC,CAAG,EAAGC,CAAG,CACzC,CAWO,SAASI,EAASC,EAAK,CAC5B,OAAQ,OAAOA,GAAQ,UAAYA,IAAQ,OAAOA,CAAG,GAAK,CAAC,MAAM,QAAQA,CAAG,CAC9E,CAkCO,SAASC,EAAkBC,EAAK,CACrC,OAAOA,EAAG,CACR,IAAK,OACH,MAAO,KACT,IAAK,QACH,MAAO,OACT,IAAK,QACH,MAAO,WACb,CACE,OAAIA,EAAI,WAAW,GAAG,EACb,EAEF,IACT,CAYO,SAASC,EAAkBD,EAAK,CACrC,OAAOA,EAAG,CACR,IAAK,OACH,MAAO,KACT,IAAK,QACH,MAAO,KACT,IAAK,QACH,MAAO,OACT,IAAK,SACH,MAAO,OACT,IAAK,QACH,MAAO,YACT,IAAK,SACH,MAAO,WACb,CACE,OAAO,IACT,CAWO,SAASE,EAAgBC,EAAQ,CAQtC,MAAMC,EAAQ,CACZ,QAAS,KACT,QAAS,IACb,EAGQC,EAAaP,GAAOA,EAAI,UAAY,MAAQA,EAAI,UAAY,KAG5DQ,EAAaH,EAAO,YAAY,YAAY,EAClD,GAAIN,EAASS,CAAU,IACjB,OAAOA,EAAW,SAAY,WAChCF,EAAM,QAAUE,EAAW,SAEzB,OAAOA,EAAW,SAAY,WAChCF,EAAM,QAAUE,EAAW,SAEzBD,EAAWD,CAAK,GAClB,OAAOA,EAIX,MAAMG,EAAYJ,EAAO,YAAY,kBAAkB,EACvD,GAAIN,EAASU,CAAS,IAChB,OAAOA,EAAU,KAAQ,WAC3BH,EAAM,QAAUG,EAAU,KAExB,OAAOA,EAAU,KAAQ,WAC3BH,EAAM,QAAUG,EAAU,KAExBF,EAAWD,CAAK,GAClB,OAAOA,EAIX,MAAMI,EAAiBL,EAAO,YAAY,wBAAwB,EAClE,GAAI,MAAM,QAAQK,CAAc,IAC9BA,EAAe,OAAO,CAACV,EAAKW,KAC1BX,EAAI,QAAU,KAAK,IAAIA,EAAI,QAASW,EAAI,KAAK,EAC7CX,EAAI,QAAU,KAAK,IAAIA,EAAI,QAASW,EAAI,KAAK,EACtCX,GACNM,CAAK,EACJC,EAAWD,CAAK,GAClB,OAAOA,EAIX,MAAMM,EAASP,EAAO,YAAY,aAAa,EAC/C,GAAI,MAAM,QAAQO,CAAM,IACtBA,EAAO,OAAO,CAACZ,EAAKa,KAClBb,EAAI,QAAU,KAAK,IAAIA,EAAI,QAAS,GAAGa,EAAI,MAAM,EACjDb,EAAI,QAAU,KAAK,IAAIA,EAAI,QAAS,GAAGa,EAAI,MAAM,EAC1Cb,GACNM,CAAK,EACJC,EAAWD,CAAK,GAClB,OAAOA,EAIX,MAAMQ,EAAYT,EAAO,YAAY,WAAW,EAChD,OAAIS,IACFR,EAAM,QAAUL,EAAkBa,CAAS,EAC3CR,EAAM,QAAUH,EAAkBW,CAAS,GAGtCR,CACT,CAUO,SAASS,EAAgBV,EAAQ,CAEtC,IAAIW,EAAS,CAAA,EACb,MAAMC,EAASZ,EAAO,YAAY,QAAQ,EAC1C,GAAI,OAAOY,EAAW,IACpBD,EAAO,KAAKC,CAAM,MAEf,CACH,MAAMC,EAAOb,EAAO,YAAY,aAAa,EAC7C,GAAI,OAAOa,EAAS,IAClBF,EAASE,MAEN,CACH,MAAMR,EAAiBL,EAAO,YAAY,wBAAwB,EAC9D,MAAM,QAAQK,CAAc,IAC9BM,EAASN,EACN,OAAOC,GAAO,EAAQA,EAAI,MAAO,EACjC,IAAIA,GAAOA,EAAI,KAAK,EAE3B,CACF,CAEA,OAAOK,EAAO,IAAIG,GACZA,IAAU,MACL,IAEAA,IAAU,OACV,IAEAA,IAAU,OACV,KAGAA,CAEV,CACH,CCvPA,SAASC,EAASC,EAAM,CACtB,IAAIC,EAAOD,EAAK,QAAU,EACtBE,EAAOF,EAAK,CAAC,EACbG,EAAOH,EAAKC,EAAO,EAAI,CAAC,EACxBG,EAAQJ,EAAK,CAAC,EACdK,EAAQL,EAAKC,EAAO,EAAI,CAAC,EACzBtB,EAAM,CAAE,KAAAuB,EAAM,KAAAC,EAAM,MAAAC,EAAO,MAAAC,CAAK,EACpC,OAAIJ,IACFtB,EAAI,KAAOqB,EAAK,CAAC,EACjBrB,EAAI,OAASqB,EAAK,CAAC,GAEdrB,CACT,CAEA,SAAS2B,EAAaN,EAAM,CAC1B,GAAI,CAAE,KAAAE,EAAM,KAAAC,EAAM,MAAAC,EAAO,MAAAC,CAAK,EAAKN,EAASC,CAAI,EAChD,MAAO,CACL,CACE,CAACE,EAAMG,CAAK,EACZ,CAACH,EAAME,CAAK,EACZ,CAACD,EAAMC,CAAK,EACZ,CAACD,EAAME,CAAK,EACZ,CAACH,EAAMG,CAAK,CAClB,CACA,CACA,CAQO,SAASE,EAAoBP,EAAM,CAExC,GADAA,EAAOQ,EAAkBR,EAAM,EAAI,EAC/B,CAACA,EACH,OAAO,KAET,IAAIrB,EAAMoB,EAASC,CAAI,EACnBS,EAAQ,CAAA,EAEZ,GAAIC,EAA0BV,CAAI,EAAG,CACnC,IAAIW,GAAKhC,EAAI,KAAO,IAAMA,EAAI,MAAQ,EAClCgC,EAAI,MACNA,GAAK,KAEPF,EAAM,KAAKE,CAAC,CACd,MAEEF,EAAM,MAAM9B,EAAI,KAAOA,EAAI,MAAQ,CAAC,EAEtC,OAAA8B,EAAM,MAAM9B,EAAI,MAAQA,EAAI,OAAS,CAAC,EAClC,OAAOA,EAAI,KAAS,KACtB8B,EAAM,MAAM9B,EAAI,KAAOA,EAAI,QAAU,CAAC,EAEjC8B,CACT,CAkDO,SAASG,EAAUC,EAAQ,CAYhC,GAXIA,EAAO,MAAMC,GAAK,OAAOA,GAAM,QAAQ,IAEzCD,EAAS,CAACA,CAAM,GAGlBA,EAASA,EACN,IAAIb,GAAQQ,EAAkBR,CAAI,CAAC,EAEnC,OAAOA,GAAQA,IAAS,IAAI,EAG3B,CAAC,MAAM,QAAQa,CAAM,GAAKA,EAAO,SAAW,EAC9C,OAAO,KAGT,IAAIE,EAAcF,EAAO,OAAO,CAACG,EAAMhB,IAAS,CAG9C,GAAIU,EAA0BV,CAAI,EAAG,CACnC,GAAI,CAAE,KAAAE,EAAM,KAAAC,EAAM,MAAAC,EAAO,MAAAC,CAAK,EAAKN,EAASC,CAAI,EAChDgB,EAAK,KAAKV,EAAa,CAAC,KAAMF,EAAOD,EAAME,CAAK,CAAC,CAAC,EAClDW,EAAK,KAAKV,EAAa,CAACJ,EAAME,EAAO,IAAKC,CAAK,CAAC,CAAC,CACnD,MAEEW,EAAK,KAAKV,EAAaN,CAAI,CAAC,EAE9B,OAAOgB,CACT,EAAG,CAAA,CAAE,EAEDC,EAAW,KAaf,GAZIF,EAAY,SAAW,EACzBE,EAAW,CACT,KAAM,UACN,YAAaF,EAAY,CAAC,CAChC,EAEWA,EAAY,OAAS,IAC5BE,EAAW,CACT,KAAM,eACN,YAAAF,CACN,GAEME,EACF,MAAO,CACL,KAAM,UACN,SAAAA,EACA,WAAY,CAAA,CAClB,CAEA,CAaO,SAAST,EAAkBR,EAAMkB,EAAU,GAAO,CACvD,GAAI,CAAC,MAAM,QAAQlB,CAAI,GAAK,CAAC,CAAC,EAAE,CAAC,EAAE,SAASA,EAAK,MAAM,EACrD,OAAO,KAGT,GAAI,CAAE,KAAAE,EAAM,KAAAC,EAAM,MAAAC,EAAO,MAAAC,EAAO,KAAAc,EAAM,OAAAC,CAAM,EAAKrB,EAASC,CAAI,EAa9D,OAVAE,EAAO/B,EAAa+B,EAAM,KAAM,GAAG,EACnCE,EAAQjC,EAAaiC,EAAO,IAAK,EAAE,EACnCD,EAAOhC,EAAagC,EAAM,KAAM,GAAG,EACnCE,EAAQlC,EAAakC,EAAO,IAAK,EAAE,EAC/Ba,GAAWlB,EAAK,SAAW,EAC7BA,EAAO,CAACE,EAAME,EAAOe,EAAMhB,EAAME,EAAOe,CAAM,EAG9CpB,EAAO,CAACE,EAAME,EAAOD,EAAME,CAAK,EAE9BL,EAAK,KAAKqB,GAAKA,IAAM,IAAI,EACpB,KAEFrB,CACT,CAQO,SAASU,EAA0BV,EAAM,CAE9C,GADAA,EAAOQ,EAAkBR,CAAI,EACzB,CAACA,EACH,MAAO,GAGT,GAAI,CAAE,KAAAE,EAAM,KAAAC,GAASJ,EAASC,CAAI,EAClC,OAAOE,EAAOC,CAChB,CAWO,SAASmB,EAAiBT,EAAQ,CACvC,GAAI,CAAC,MAAM,QAAQA,CAAM,GAAKA,EAAO,SAAW,EAC9C,OAAO,KAGT,MAAMU,EAAU,CACd,KAAM,KACN,MAAO,KACP,KAAM,KACN,MAAO,IACX,EACQlD,EAAM,CAAC,OAAQ,OAAO,EAC5B,QAAQ2B,KAAQa,EAAQ,CAEtB,GADAb,EAAOQ,EAAkBR,CAAI,EACzB,CAACA,EACH,SAEF,MAAMrB,EAAMoB,EAASC,CAAI,EACzB,UAAUwB,KAAO7C,EACf,GAAI4C,EAAQC,CAAG,IAAM,KACnBD,EAAQC,CAAG,EAAI7C,EAAI6C,CAAG,MAEnB,CACH,MAAMC,EAAKpD,EAAI,SAASmD,CAAG,EAAI,KAAK,IAAM,KAAK,IAC/CD,EAAQC,CAAG,EAAIC,EAAGF,EAAQC,CAAG,EAAG7C,EAAI6C,CAAG,CAAC,CAC1C,CAEJ,CAEA,IAAIxB,EAAO,CAACuB,EAAQ,KAAMA,EAAQ,MAAOA,EAAQ,KAAMA,EAAQ,KAAK,EACpE,OAAOf,EAAkBR,CAAI,CAC/B,CC9OA,MAAM0B,CAAW,CAEf,YAAYC,EAAMC,EAAS,CAAA,EAAIC,EAAc,CAAA,EAAI,CAC/C,GAAI,CAACnD,EAASiD,CAAI,EAChB,MAAM,IAAI,MAAM,6BAA6B,EAG/C,GAAIA,aAAgBD,EAAY,CAC9B,QAAQF,KAAOK,EACb,KAAKL,CAAG,EAAIG,EAAKH,CAAG,EAEtBG,EAAOA,EAAK,OAAM,CACpB,CAGA,KAAK,QAAUC,EAEf,KAAK,aAAe,CAAC,UAAW,cAAc,EAAE,OAAOC,CAAW,EAGlE,QAASL,KAAOG,EACV,OAAO,KAAKH,CAAG,EAAM,MACnBA,KAAOI,EACT,KAAKJ,CAAG,EAAII,EAAOJ,CAAG,EAAEG,EAAKH,CAAG,EAAG,IAAI,EAGvC,KAAKA,CAAG,EAAIG,EAAKH,CAAG,EAI5B,CAOA,QAAS,CACP,OAAO,KAAK,OAAS,SACvB,CAOA,WAAY,CACV,OAAO,KAAK,OAAS,SACvB,CAOA,eAAgB,CACd,OAAO,KAAK,aAAe,KAAK,aAAY,CAC9C,CAOA,cAAe,CACb,OAAO,KAAK,OAAS,YACvB,CAOA,kBAAmB,CACjB,OAAO,KAAK,OAAS,mBACvB,CAOA,wBAAyB,CACvB,MAAO,EACT,CAOA,SAAU,CACR,MAAO,EACT,CAOA,QAAS,CACP,MAAO,EACT,CAOA,QAAS,CACP,MAAO,EACT,CAiBA,eAAgB,CAEhB,CAQA,eAAeM,EAAY,GAAM,CAC/B,OAAO,IACT,CAQA,YAAYC,EAAO,CACjB,OAAO,KAAKA,CAAK,CACnB,CAOA,WAAY,CACV,OAAO,IACT,CAOA,gBAAiB,CACf,OAAO,IACT,CAOA,WAAY,CACV,OAAOxB,EAAoB,KAAK,gBAAgB,CAClD,CAOA,kBAAmB,CACjB,MAAO,CAAA,CACT,CAOA,QAAS,CACP,IAAI5B,EAAM,CAAA,EACV,cAAO,KAAK,IAAI,EAAE,QAAQ6C,GAAO,CAC/B,GAAI,OAAO,KAAKA,CAAG,GAAM,YAAc,KAAK,aAAa,SAASA,CAAG,EACnE,OAEF,IAAIQ,EAAI,KAAKR,CAAG,EAChB,GAAIA,KAAO,KAAK,QAAS,CACvB,IAAIS,EAAK,MAAM,QAAQD,CAAC,EAAI,CAAA,EAAK,CAAA,EACjC,QAAQR,KAAOQ,EACT,OAAOA,EAAER,CAAG,EAAE,QAAW,WAC3BS,EAAGT,CAAG,EAAIQ,EAAER,CAAG,EAAE,OAAM,EAGvBS,EAAGT,CAAG,EAAIQ,EAAER,CAAG,EAGnBQ,EAAIC,CACN,CACAtD,EAAI6C,CAAG,EAAIQ,CACb,CAAC,EACMrD,CACT,CAEF,CC/NO,MAAMuD,EAAmB,CAC9B,OACA,OACF,EAUO,SAASC,EAAWC,EAAMC,EAASP,EAAY,GAAM,CAC1D,OAAOQ,EAAaF,EAAMC,EAAS,GAAOP,CAAS,CACrD,CAWO,SAASQ,EAAaF,EAAMC,EAAU,KAAME,EAAW,GAAOT,EAAY,GAAM,CAErF,IAAIU,EAAMC,EAAIL,CAAI,EAClB,GAAIC,GAAWG,EAAI,GAAG,UAAU,EAAG,CAEjC,IAAIE,EAAUD,EAAIJ,CAAO,EACrBM,EAAcD,EAAQ,KAAI,EAC1B,CAACC,EAAY,SAAS,GAAG,GAAK,CAACA,EAAY,SAAS,OAAO,GAC7DD,EAAQ,KAAKC,EAAc,GAAG,EAEhCH,EAAMA,EAAI,WAAWE,CAAO,CAC9B,CAGA,OAAAF,EAAI,UAAS,EACTD,IACFC,EAAI,MAAM,EAAE,EACZA,EAAI,SAAS,EAAE,GAEVV,EAAYU,EAAI,SAAQ,EAAKA,CACtC,CChDO,MAAMI,EAAmB,uBAOnBC,EAAiB,CAC5B,mBACAD,EACA,WACF,EAOaE,EAAoB,CAC/B,YACA,aACA,aACA,YACA,YACF,EAOaC,EAAgB,CAC3B,2DACA,8CACF,EAOaC,EAAoB,CAC/B,sBACA,kCACA,wBACF,EAAE,OAAOD,CAAa,EAiBf,SAASE,EAAYC,EAAMC,EAAcC,EAAiB,GAAO,CAItE,OAHK,MAAM,QAAQD,CAAY,IAC7BA,EAAe,CAACA,CAAY,GAE1BC,GAAkB,OAAOF,EAAS,IAC7B,GAEA,OAAOA,GAAS,SAChB,IAGPC,EAAeA,EAAa,IAAID,GAAQA,EAAK,YAAW,CAAE,EACnDC,EAAa,SAASD,EAAK,YAAW,CAAE,EAEnD,CASO,SAASG,EAAgBH,EAAME,EAAiB,GAAO,CAC5D,OAAOH,EAAYC,EAAML,EAAgBO,CAAc,CACzD,CCvEA,MAAME,UAAsB5B,CAAW,CAErC,YAAYC,EAAM4B,EAAU,KAAM3B,EAAS,CAAA,EAAIC,EAAc,GAAI,CAC/D,MAAMF,EAAMC,EAAQ,CAAC,UAAU,EAAE,OAAOC,CAAW,CAAC,EAC/C,KAAK,WACR,KAAK,SAAW0B,EAEpB,CAQA,eAAezB,EAAY,GAAM,CAC/B,OAAI,KAAK,SACAK,EAAW,KAAK,KAAM,KAAK,SAAS,eAAc,EAAIL,CAAS,EAE/D,KAAK,KAAK,SAAS,KAAK,EACxBA,EAAY,KAAK,KAAOW,EAAI,KAAK,IAAI,EAEvC,IACT,CAOA,YAAa,CACX,OAAO,KAAK,QACd,CAUA,uBAAuBW,EAAiB,GAAO,CAC7C,GAAI,OAAO,KAAK,MAAS,SACvB,MAAO,GAEJ,GAAI,CAACA,GAAkB,OAAO,KAAK,KAAS,IAC/C,MAAO,GAET,IAAIZ,EAAM,KAAK,eAAe,EAAK,EAC9BA,IACHA,EAAMC,EAAI,KAAK,IAAI,GAErB,MAAMe,EAAWhB,EAAI,SAAQ,EAAG,YAAW,EACrCiB,EAAYjB,EAAI,OAAM,EAAG,YAAW,EAC1C,OAAIvE,EAAQuF,CAAQ,GAAK,CAACtB,EAAiB,SAASsB,CAAQ,EACnD,GAEAvF,EAAQ,KAAK,IAAI,GAAK6E,EAAkB,SAAS,KAAK,KAAK,YAAW,CAAE,EACxE,GAEA,UAAO,KAAK,KAAS,KAAe7E,EAAQwF,CAAS,IAAMA,IAAc,OAASX,EAAkB,SAAS,SAAWW,CAAS,GAM5I,CAQA,OAAOC,EAAO,CACZ,OAAOzF,EAAQ,KAAK,IAAI,GAAKgF,EAAY,KAAK,KAAMS,CAAK,CAC3D,CAOA,WAAY,CACV,OAAO,KAAK,OAAOV,CAAiB,CACtC,CAOA,OAAQ,CACN,OAAO,KAAK,OAAOD,CAAa,CAClC,CASA,QAAS,CACP,IAAIP,EAAM,KAAK,eAAe,EAAK,EACnC,GAAI,CAACA,EACH,OAAO,KAET,MAAMgB,EAAWhB,EAAI,SAAQ,EAAG,YAAW,EAC3C,OAAOvE,EAAQuF,CAAQ,GAAKtB,EAAiB,SAASsB,CAAQ,CAChE,CAOA,WAAY,CACV,MAAO,EACT,CAEF,CC1HA,MAAMG,UAAaL,CAAc,CAE/B,YAAY3B,EAAM4B,EAAU,KAAM,CAChC,MAAM5B,EAAM4B,CAAO,CACrB,CAOA,QAAS,CACP,MAAO,EACT,CAOA,eAAgB,CACd,MAAO,MACT,CAOA,WAAY,CACV,OAAO,KAAK,MAAQ,SACtB,CAUA,OAAO,UAAUK,EAAOL,EAAU,KAAM,CACtC,OAAI,MAAM,QAAQK,CAAK,EAGhBA,EAAM,IAAIC,GAAQnF,EAASmF,CAAI,EAAI,IAAIF,EAAKE,EAAMN,CAAO,EAAIM,CAAI,EAF/D,CAAA,CAGX,CAEF,CCjDA,MAAMC,UAAuBpC,CAAW,CAEtC,YAAYC,EAAMoC,EAAc,KAAMnC,EAAS,CAAA,EAAIC,EAAc,GAAI,CAQnE,GAPA,MACEF,EACA,OAAO,OAAO,CAAE,MAAOgC,EAAK,SAAS,EAAI/B,CAAM,EAC/C,CAAC,MAAM,EAAE,OAAOC,CAAW,CACjC,EAGQ,CAAC,KAAK,OACR,KAAK,KAAOkC,EACR,CAAC,KAAK,MAAM,CACd,IAAIC,EAAO,KAAK,YAAW,EACvBA,IACF,KAAK,KAAOA,EAAK,KAErB,CAEJ,CAQA,eAAelC,EAAY,GAAM,CAC/B,OAAOA,EAAY,KAAK,KAAOW,EAAI,KAAK,IAAI,CAC9C,CAOA,eAAewB,EAAK,CAClB,KAAK,KAAOA,CACd,CASA,oBAAoBC,EAAKd,EAAiB,GAAM,CAC9C,OAAO,KAAK,iBAAiB,CAACc,CAAG,CAAC,EAC/B,OAAOL,GAAQR,EAAgBQ,EAAK,KAAMT,CAAc,CAAC,CAC9D,CASA,mBAAmBc,EAAKd,EAAiB,GAAM,CAC7C,MAAMQ,EAAQ,KAAK,oBAAoBM,EAAKd,CAAc,EAC1D,OAAIQ,EAAM,OAAS,EACVA,EAAM,CAAC,EAGP,IAEX,CAOA,UAAW,CACT,OAAO,MAAM,QAAQ,KAAK,KAAK,EAAI,KAAK,MAAM,OAAOC,GAAQnF,EAASmF,CAAI,GAAK5F,EAAQ4F,EAAK,IAAI,CAAC,EAAI,CAAA,CACvG,CAQA,eAAeK,EAAK,CAClB,OAAO,KAAK,SAAQ,EAAG,KAAKL,GAAQA,EAAK,MAAQK,CAAG,GAAK,IAC3D,CAQA,iBAAiBC,EAAM,CACrB,OAAO,KAAK,SAAQ,EAAG,OAAON,GAAQM,EAAK,SAASN,EAAK,GAAG,CAAC,CAC/D,CAQA,sBAAsBM,EAAM,CAC1B,OAAO,KAAK,SAAQ,EAAG,OAAON,GAAQ,CAACM,EAAK,SAASN,EAAK,GAAG,CAAC,CAChE,CAOA,aAAc,CACZ,OAAO,KAAK,mBAAmB,MAAM,CACvC,CAOA,aAAc,CACZ,OAAO,KAAK,mBAAmB,MAAM,CACvC,CAOA,eAAgB,CACd,OAAO,KAAK,mBAAmB,QAAQ,CACzC,CAEF,CC5IA,MAAMO,UAAsBN,CAAe,CAEzC,YAAYnC,EAAMoC,EAAc,KAAMnC,EAAS,CAAA,EAAIC,EAAc,GAAI,CACnE,MAAMF,EAAMoC,EAAanC,EAAQC,CAAW,CAC9C,CAOA,QAAS,CACP,MAAO,CAAA,CACT,CAEF,CCfA,MAAMwC,UAAa3C,CAAW,CAE5B,YAAYC,EAAM2C,EAAQ,KAAMf,EAAU,KAAM,CAC9C,MAAM5B,EAAM,CAAA,EAAI,CAAC,SAAU,UAAU,CAAC,EAClC,OAAO,KAAK,QAAW,WACzB,KAAK,OAAS,OAAO2C,GAAU,SAAW,SAASA,EAAO,EAAE,EAAIA,GAE7D,KAAK,WACR,KAAK,SAAWf,EAEpB,CAOA,YAAa,CACX,OAAO,KAAK,QACd,CAOA,eAAgB,CACd,MAAO,MACT,CAOA,QAAS,CACP,MAAO,EACT,CAOA,UAAW,CACT,OAAO,KAAK,MACd,CAWA,YAAYxB,EAAO,CACjB,GAAI,OAAO,KAAKA,CAAK,EAAM,IACzB,OAAO,KAAKA,CAAK,EAEnB,GAAI,KAAK,SACP,OAAO,KAAK,SAAS,YAAYA,CAAK,CAG1C,CASA,iBAAkB,CAChB,OAAOhD,EAAgB,IAAI,CAC7B,CASA,iBAAkB,CAChB,OAAOW,EAAgB,IAAI,CAC7B,CASA,OAAO,UAAU6E,EAAOhB,EAAU,KAAM,CACtC,IAAIiB,EAAW,CAAA,EACf,GAAG,MAAM,QAAQD,CAAK,EACpB,QAAQ,KAAKA,EAAO,CAClB,MAAME,EAAIF,EAAM,CAAC,EACXG,EAAUD,aAAaJ,EAAOI,EAAI,IAAIJ,EAAKI,EAAG,EAAGlB,CAAO,EAC9DiB,EAAS,KAAKE,CAAO,CACvB,CAEF,OAAOF,CACT,CAEF,CCvHA,MAAMG,EAAiB,CACrB,UACA,UACA,YACA,UACA,cACA,OACF,EAkBA,MAAMC,UAActB,CAAc,CAEhC,YAAY3B,EAAMH,EAAM,KAAM+B,EAAU,KAAM,CAC5C,MAAM3B,EAAS,CACb,MAAOyC,EAAK,UACZ,UAAWO,EAAM,UACvB,EACI,MAAMjD,EAAM4B,EAAS3B,EAAQ,CAAC,MAAM,CAAC,EAChC,KAAK,OACR,KAAK,KAAOJ,EAEhB,CAOA,eAAgB,CACd,MAAO,OACT,CAOA,SAAU,CACR,MAAO,EACT,CAQA,eAAeM,EAAY,GAAM,CAC/B,OAAI,KAAK,eACA,KAEF,MAAM,eAAeA,CAAS,CACvC,CAOA,QAAS,CACP,OAAO,KAAK,IACd,CAWA,YAAYC,EAAO,CACjB,GAAI,OAAO,KAAKA,CAAK,EAAM,IACzB,OAAO,KAAKA,CAAK,EAGnB,GAAI,KAAK,oBAAoB6C,EAC3B,OAAO,KAAK,SAAS,YAAY7C,CAAK,EAGxC,GAAI,KAAK,UAAY,CAAC4C,EAAe,SAAS5C,CAAK,EACjD,OAAO,KAAK,SAAS,YAAYA,CAAK,CAG1C,CAOA,UAAW,CACT,OAAO,KAAK,OAAS,CAAA,CACvB,CAgBA,iBAAkB,CAChB,MAAM8C,EAAM,CACV,IAAK,KACL,MAAO,KACP,KAAM,IACZ,EACUN,EAAQ,KAAK,SAAQ,EAC3B,UAAU/C,KAAO+C,EAAO,CACtB,MAAMD,EAAQ,SAAS9C,EAAK,EAAE,EACxBsD,EAAOP,EAAMD,CAAK,EACpB5F,EAASoG,CAAI,GAAK7G,EAAQ6G,EAAK,gBAAgB,CAAC,GAAKA,EAAK,gBAAgB,IAAKD,IACjFA,EAAIC,EAAK,gBAAgB,CAAC,EAAIA,EAElC,CAEA,OADiB,OAAO,OAAOD,CAAG,EAAE,MAAME,GAAKA,IAAM,IAAI,EACvCF,EAAM,IAC1B,CAYA,SAAS/E,EAAOkF,EAAW,OAAQ,CAC5B,MAAM,QAAQlF,CAAK,IACtBA,EAAQ,CAACA,CAAK,GAEhB,MAAMyE,EAAQ,KAAK,SAAQ,EACrBD,EAAQC,EAAM,UAAUO,GAAQpG,EAASoG,CAAI,GAAKhF,EAAM,SAASgF,EAAKE,CAAQ,CAAC,CAAC,EACtF,OAAIV,GAAS,EACJC,EAAMD,CAAK,EAEb,IACT,CAWA,QAAQQ,EAAM,CACZ,OAAIpG,EAASoG,CAAI,GAAKA,IAAS,KACtBA,EAEK,KAAK,SAAQ,EACdA,CAAI,GAAK,IACxB,CASA,iBAAkB,CAChB,OAAO/F,EAAgB,IAAI,CAC7B,CASA,iBAAkB,CAChB,OAAOW,EAAgB,IAAI,CAC7B,CAOA,cAAe,CACb,MAAO,CAACzB,EAAQ,KAAK,IAAI,CAC3B,CASA,QAAS,CACP,OAAI,KAAK,eACA,KAEF,MAAM,OAAM,CACrB,CAUA,WAAY,CACV,MAAMgH,EAAQ,CAAC,YAAa,UAAU,EACtC,OAAIA,EAAM,SAAS,KAAK,OAAM,CAAE,EACvB,GAEF,MAAM,QAAQ,KAAK,KAAK,GAAK,KAAK,MAAM,KAAKC,GAAQD,EAAM,SAASC,CAAI,CAAC,CAClF,CASA,QAAQD,EAAOE,EAAa,GAAO,CAIjC,OAHK,MAAM,QAAQF,CAAK,IACtBA,EAAQ,CAACA,CAAK,GAEZE,GAAcF,EAAM,SAAS,KAAK,OAAM,CAAE,EACrC,GAEF,MAAM,QAAQ,KAAK,KAAK,GAAM,EAAQ,KAAK,MAAM,KAAKC,GAAQD,EAAM,SAASC,CAAI,CAAC,CAC3F,CASA,OAAO,WAAWE,EAAQ7B,EAAU,KAAM,CACxC,IAAI8B,EAAY,CAAA,EAChB,GAAG3G,EAAS0G,CAAM,EAChB,QAAQ,KAAKA,EAAQ,CACnB,MAAME,EAAIF,EAAO,CAAC,EACZG,EAAWD,aAAaV,EAAQU,EAAI,IAAIV,EAAMU,EAAG,EAAG/B,CAAO,EACjE8B,EAAU,CAAC,EAAIE,CACjB,CAEF,OAAOF,CACT,CAEF,CCvRe,SAASG,EAAMC,EAAQ,CACpC,GAAI,CAACA,EACH,OAIF,MAAMC,EAAe,OAAOD,CAAM,EAC5BE,EAAaD,EAAa,QAAQ,GAAG,EAErCE,EAAUD,IAAe,GAC3BD,EAAa,OAAOC,EAAa,CAAC,EAClC,OAEEE,EAAuBF,IAAe,GACxCD,EAAa,OAAO,EAAGC,CAAU,EACjCD,EAGEI,EAAQ,OAAOD,CAAoB,EACtC,QAAQ,KAAM,GAAG,EACjB,MAAM,GAAG,EAEZ,GAAI,CAACC,EAAM,QAAUA,EAAM,OAAS,EAClC,OAGF,MAAMC,EAAWD,EAAM,QACvB,GAAI,CAACC,EACH,OAGF,MAAMC,EAAS,CACb,QAAAJ,EACA,SAAUG,EAAS,YAAW,CAClC,EAEE,GAAI,CAACD,EAAM,OACT,OAAOE,EAGT,GAAIF,EAAM,SAAW,EAAG,CACtB,MAAMG,EAAUH,EAAM,MAClBG,IACFD,EAAO,QAAUC,EAAQ,cAE7B,CAEA,IAAIC,EAAUJ,EAAM,MAWpB,GAVII,EAAQ,OAAS,IACnBF,EAAO,QAAUE,EAEjBA,EAAUJ,EAAM,OAGdI,IACFF,EAAO,QAAUE,EAAQ,eAGvB,CAACJ,EAAM,OACT,OAAOE,EAGT,MAAMG,EAASL,EAAM,MACrB,OAAI,OAAOK,GAAW,UAAYA,EAAO,QAAU,IACjDH,EAAO,OAASG,EAAO,CAAC,EAAE,cAAgBA,EAAO,UAAU,CAAC,EAAE,YAAW,GAGpEH,CACT,CA0CO,SAASI,GAAiBC,EAAW,CAC1C,MAAMC,EAAM,CAAA,EAEZ,OAAAD,EAAU,QAAQE,GAAmB,CACnC,KAAM,CAAE,SAAAR,EAAU,QAAAG,CAAO,EAAKV,EAAMe,CAAe,EACnD,GAAI,CAACR,EACH,MAAM,IAAI,MAAM,UAAUQ,CAAe,kBAAkB,EAGxDD,EAAIP,CAAQ,IACfO,EAAIP,CAAQ,EAAI,CACd,UAAW,CAAA,EACX,aAAc,OACd,KAAM,MACd,GAGI,MAAMS,EAAKF,EAAIP,CAAQ,EACnBG,GACFM,EAAG,UAAUN,CAAO,EAAIK,EAEnBC,EAAG,eACNA,EAAG,aAAeD,IAGpBC,EAAG,KAAOD,CAEd,CAAC,EAEMD,CACT,CAEO,SAASG,EAAQJ,EAAWZ,EAAQiB,EAAeC,EAAe,CACvE,MAAML,EAAM,MAAM,QAAQD,CAAS,EAAID,GAAiBC,CAAS,EAAIA,EAGrE,GAAI,CAACZ,GAAUiB,EACb,OAAOD,EAAQJ,EAAWK,EAAe,MAAwB,EAGnE,GAAI,CAACjB,EACH,OAGF,KAAM,CAAE,SAAAM,EAAU,QAAAG,CAAO,EAAKV,EAAMC,CAAM,EAC1C,GAAI,CAACM,EACH,OAAOW,EAIT,GAAI,CAACJ,EAAIP,CAAQ,EACf,OAAIN,IAAWiB,EACb,OAGKD,EAAQJ,EAAWK,EAAe,IAAmB,EAG9D,KAAM,CAAE,UAAAE,EAAW,KAAAC,EAAOH,EAAe,aAAAI,GAAiBR,EAAIP,CAAQ,EACtE,MAAI,CAACa,GAAa,CAACV,EAKVW,EAOFD,EAAUV,CAAO,EAAIU,EAAUV,CAAO,EAAIW,CACnD,CC1KA,MAAME,UAAajD,CAAe,CAEhC,YAAYnC,EAAMoC,EAAc,KAAMnC,EAAS,CAAA,EAAIC,EAAc,GAAI,CACnE,MAAMF,EAAMoC,EAAanC,EAAQC,CAAW,CAC9C,CAOA,mBAAoB,CAClB,OAAO,IACT,CAOA,oBAAqB,CACnB,MAAO,CAAA,CACT,CAUA,cAAc4D,EAAQuB,EAAiB,KAAM,CAC3C,IAAIpD,EAAQ,KAAK,oBAAoB,WAAW,EAC7C,OAAOC,GAAQ5F,EAAQ4F,EAAK,QAAQ,CAAC,EAEpCoD,EACA,MAAM,QAAQ,KAAK,SAAS,EAC9BA,EAAY,KAAK,UAAU,IAAIC,GAAKA,EAAE,IAAI,EAG1CD,EAAYrD,EAAM,IAAIC,GAAQA,EAAK,QAAQ,EAG7C,IAAIsD,EAAOV,EAAQQ,EAAWxB,EAAQuB,CAAc,EACpD,OAAOpD,EAAM,KAAKC,GAAQA,EAAK,WAAasD,CAAI,GAAK,IACvD,CAQA,SAAS/D,EAAiB,GAAM,CAC9B,OAAO,KAAK,iBAAiB,CAAC,MAAM,CAAC,EAClC,OAAOgE,GAAOA,EAAI,uBAAuBhE,CAAc,CAAC,CAC7D,CASA,cAAciE,EAAc,GAAMC,EAAS,KAAM,CAC/C,IAAIC,EAAa,KAAK,UAAS,EAAG,OAAOC,GAASA,EAAM,WAAW,EAMnE,GAJID,EAAW,SAAW,IACxBA,EAAa,KAAK,SAAQ,EAAG,OAAO1D,GAAQA,EAAK,WAAW,GAG1D0D,EAAW,SAAW,EAAG,CAC3B,MAAME,EAAY,KAAK,SAAS,WAAW,EACvCA,GACFF,EAAW,KAAKE,CAAS,CAE7B,CAKA,GAJIJ,IAEFE,EAAaA,EAAW,OAAOH,GAAOA,EAAI,uBAAsB,CAAE,GAEhEE,GAAUC,EAAW,OAAS,EAAG,CAInC,IAAIG,EAASN,GAAQ,MAAM,QAAQA,EAAI,KAAK,GAAKA,EAAI,MAAM,SAASE,CAAM,GAAOF,EAAI,OAAM,IAAOE,EAClGC,EAAaA,EACV,OAAOG,CAAM,EACb,OAAOH,EAAW,OAAOH,GAAO,CAACM,EAAON,CAAG,CAAC,CAAC,CAClD,CACA,OAAOG,CACT,CAUA,kBAAkBI,EAAW,GAAMC,EAAU,GAAO,CAElD,OADa,KAAK,aAAaD,EAAUC,CAAO,EAClC,CAAC,GAAG,KACpB,CAyCA,aAAaD,EAAW,GAAMC,EAAU,GAAOC,EAAa,KAAMC,EAAqB,KAAM,CACtFpJ,EAASmJ,CAAU,IACtBA,EAAa,CACX,KAAM,EACN,OAAQ,EACR,UAAW,EACX,SAAU,CAClB,GAEI,IAAIE,EAAS,CAAA,EACT3C,EAAS,KAAK,iBAAiBpC,CAAiB,EAChD2E,IACFvC,EAASA,EAAO,OAAOoC,GAASA,EAAM,OAAM,IAAO,CAACI,GAAWJ,EAAM,MAAK,EAAG,GAE/E,IAAIvC,EAAQ,OAAO,QAAQ4C,CAAU,EACrC,QAAQL,KAASpC,EAAQ,CACvB,IAAI4C,EAAQ,EACZ,GAAI/C,EAAM,OAAS,EAAG,CACpB,IAAIgD,EAAShD,EACV,OAAO,CAAC,CAACC,CAAI,IAAMsC,EAAM,QAAQtC,EAAM,EAAI,CAAC,EAC5C,IAAI,CAAC,CAAA,CAAEpF,CAAK,IAAMA,CAAK,EACtBmI,EAAO,OAAS,IAClBD,GAAS,KAAK,IAAI,GAAGC,CAAM,EAE/B,CACI,CAACL,GAAWJ,EAAM,UACpBQ,GAAS,GAEPR,EAAM,oBACRQ,GAAS,GAEP,OAAOF,GAAuB,aAChCE,GAASF,EAAmBN,CAAK,GAGnCO,EAAO,KAAK,CAAC,MAAAP,EAAO,MAAAQ,CAAK,CAAC,CAC5B,CACA,OAAAD,EAAO,KAAK,CAACzC,EAAEb,IAAMA,EAAE,MAAQa,EAAE,KAAK,EAC/ByC,CACT,CAgBA,kBAAmB,CACjB,IAAIlD,EAAM,CACR,IAAK,KACL,MAAO,KACP,KAAM,IACZ,EACQqD,EAAQ,OAAO,KAAKrD,CAAG,EACvBO,EAAS,KAAK,UAAS,EAC3B,QAAQoC,KAASpC,EAAQ,CACvB,IAAI6C,EAAST,EAAM,SAASU,EAAO,gBAAgB,EAC/CD,IACFpD,EAAIoD,EAAO,gBAAgB,CAAC,EAAIT,EAEpC,CAEA,OADe,OAAO,OAAO3C,CAAG,EAAE,MAAME,GAAKA,IAAM,IAAI,EACrCF,EAAM,IAC1B,CAQA,SAASrD,EAAK,CACZ,OAAK9C,EAAS,KAAK,MAAM,GAGlB,KAAK,OAAO8C,CAAG,GAAK,IAC7B,CAOA,WAAY,CACV,OAAK9C,EAAS,KAAK,MAAM,EAGlB,OAAO,OAAO,KAAK,MAAM,EAFvB,CAAA,CAGX,CASA,mBAAmBuG,EAAOE,EAAa,GAAO,CAC5C,OAAO,KAAK,UAAS,EAAG,OAAOqC,GAASA,EAAM,QAAQvC,EAAOE,CAAU,CAAC,CAC1E,CASA,iBAAiBD,EAAMC,EAAa,GAAO,CAEzC,OADa,KAAK,mBAAmB,CAACD,CAAI,EAAGC,CAAU,EACzC,CAAC,GAAK,IACtB,CAQA,iBAAiBzB,EAAO,CACtB,OAAO,KAAK,UAAS,EAAG,OAAO8D,GAASvE,EAAYuE,EAAM,KAAM9D,CAAK,CAAC,CACxE,CAQA,OAAOyE,EAAO,CACZ,OAAI,OAASA,EACJ,GAEL,EAAEA,aAAiBpB,IAGnB,KAAK,cAAa,IAAOoB,EAAM,cAAa,EACvC,GAEL,QAAK,IAAM,KAAK,KAAOA,EAAM,GAInC,CAUA,kBAAkBC,EAAS,CACzB,GAAI,CAAC,MAAM,QAAQ,KAAK,eAAe,EACrC,MAAO,GAET,IAAIC,EAAS,IAAI,OAAO,IAAMD,EAAQ,WAAW,IAAK,OAAO,EAAI,GAAG,EACpE,OAAO,KAAK,gBAAgB,KAAK5F,GAAO6F,EAAO,KAAK7F,CAAG,CAAC,CAC1D,CAEF,CC/TA,MAAM8F,UAAoBvB,CAAK,CAE7B,YAAYpF,EAAMoC,EAAc,KAAMnC,EAAS,CAAA,EAAIC,EAAc,GAAI,CACnE,MAAMF,EAAMoC,EAAanC,EAAQC,CAAW,CAC9C,CAOA,eAAgB,CACd,OAAO,KAAK,IACd,CASA,cAAc0G,EAAS,KAAM,CAC3B,IAAI3E,EAAQ,KAAK,oBAAoB,QAAQ,EAC7C,OAAK2E,EAII3E,EAAM,CAAC,GAAK,KAHZA,EAAM,KAAKC,GAAQA,EAAK,SAAW0E,GAAW,CAACA,GAAU,CAAC1E,EAAK,MAAO,GAAK,IAKtF,CAOA,uBAAwB,CACtB,OAAO,KAAK,mBAAmB,MAAM,CACvC,CAOA,iBAAkB,CAChB,OAAO,KAAK,mBAAmB,OAAO,CACxC,CAOA,eAAgB,CACd,OAAO,KAAK,oBAAoB,OAAO,CACzC,CAOA,cAAe,CACb,OAAO,KAAK,oBAAoB,MAAM,CACxC,CAEF,CC9DA,MAAM2E,WAAgBF,CAAY,CAEhC,YAAY3G,EAAMoC,EAAc,KAAM,CACpC,MAAMpC,EAAMoC,CAAW,CACzB,CAEF,CChBO,SAAS0E,EAAU5J,EAAK,CAC7B,GAAIZ,EAAQY,CAAG,GAAKA,EAAI,QAAU,GAChC,GAAI,CAEF,IAAI6J,EADW7J,EAAI,MAAM,iFAAiF,EACxF,MAAM,CAAC,EAAE,IAAI,GAAK,SAAS,EAAG,EAAE,CAAC,EACnD,OAAO,IAAI,KAAK,KAAK,IAAI6J,EAAG,CAAC,EAAGA,EAAG,CAAC,EAAI,EAAGA,EAAG,CAAC,EAAGA,EAAG,CAAC,EAAGA,EAAG,CAAC,EAAGA,EAAG,CAAC,EAAGA,EAAG,CAAC,GAAK,CAAC,CAAC,CACpF,MAAQ,CACN,OAAO,IACT,CAEF,OAAO,IACT,CASO,SAASC,GAAeC,EAAOC,EAAK,CACzC,OAAO,IAAI,KAAKD,EAAM,QAAO,GAAOC,EAAMD,GAAS,CAAE,CACvD,CAQO,SAASE,EAAc9H,EAAM,CAClC,GAAI,CAAC,MAAM,QAAQA,CAAI,GAAKA,EAAK,SAAW,EAC1C,OAAO,KAGT,IAAI3C,EACAC,EACJ,MAAMyK,EAAS,CAAC5H,EAAMrB,EAAO2B,IACvB,OAAON,EAAS,IACXrB,EAEAqB,IAAS,MAAQrB,IAAU,KAC3B,KAGA2B,EAAGN,EAAMrB,CAAK,EAGzB,OAAAkB,EAAK,QAAQ,CAAC,CAAC4H,EAAOC,CAAG,IAAM,CAC7BxK,EAAM0K,EAAO1K,EAAKuK,EAAO,KAAK,GAAG,EACjCtK,EAAMyK,EAAOzK,EAAKuK,EAAK,KAAK,GAAG,CACjC,CAAC,EACM,CACLxK,IAAQ,KAAO,KAAO,IAAI,KAAKA,CAAG,EAClCC,IAAQ,KAAO,KAAO,IAAI,KAAKA,CAAG,CACtC,CACA,CCfA,MAAM0K,UAAmBV,CAAY,CAEnC,YAAY3G,EAAMoC,EAAc,KAAM,CACpC,MAAMnC,EAAS,CACb,OAAQgD,EAAM,WACd,YAAaA,EAAM,UACzB,EACI,MAAMjD,EAAMoC,EAAanC,CAAM,CACjC,CASA,WAAY,CACV,IAAIqH,EAAUrI,EAAU,KAAK,iBAAgB,CAAE,EAC/C,OAAIqI,IACFA,EAAQ,GAAK,KAAK,IAEbA,CACT,CAOA,gBAAiB,CACf,IAAIpI,EAAS,KAAK,oBAAmB,EACrC,OAAIA,EAAO,OAAS,EACXL,EAAkBK,EAAO,CAAC,CAAC,EAE7B,IACT,CAQA,kBAAmB,CACjB,IAAIqI,EAAM,KAAK,oBAAmB,EAClC,OAAIA,EAAI,SAAW,EACV,CAAC1I,EAAkB0I,EAAI,CAAC,CAAC,CAAC,EAE1BA,EAAI,OAAS,EACbA,EAAI,MAAM,CAAC,EAAE,IAAI1I,CAAiB,EAEpC,IACT,CAOA,qBAAsB,CACpB,IAAI2I,EAAU,KAAK,QAAQ,SAAS,KACpC,OAAI,MAAM,QAAQA,CAAO,GAAKA,EAAQ,OAAS,EACtCA,EAEF,CAAA,CACT,CAOA,mBAAoB,CAClB,OAAO,KAAK,qBAAqB,CAAC,GAAK,IACzC,CAOA,oBAAqB,CACnB,IAAIA,EAAU,KAAK,QAAQ,UAAU,SACrC,OAAI,MAAM,QAAQA,CAAO,GAAKA,EAAQ,OAAS,EACtCA,EACJ,OAAOC,GAAU,MAAM,QAAQA,CAAM,IAAMnL,EAAQmL,EAAO,CAAC,CAAC,GAAKnL,EAAQmL,EAAO,CAAC,CAAC,EAAE,EACpF,IAAIC,GAAYA,EAAS,IAAIC,GAAYb,EAAUa,CAAQ,CAAC,CAAC,EAE3D,CAAA,CACT,CAQA,WAAWvH,EAAO,CAChB,GAAIrD,EAAS,KAAK,SAAS,EACzB,OAAO,KAAK,UAAUqD,CAAK,CAG/B,CAOA,UAAW,CACT,IAAIwC,EAAQ,KAAK,YAAY,OAAO,EAIpC,OAHK,MAAM,QAAQA,CAAK,IACtBA,EAAQ,KAAK,WAAW,OAAO,GAE5B,MAAM,QAAQA,CAAK,EAGjBF,EAAK,UAAUE,EAAO,IAAI,EAFxB,CAAA,CAGX,CAEF,CC5JA,MAAMgF,WAA6BnF,CAAc,CAE/C,YAAYzC,EAAMoC,EAAc,KAAM,CACpC,MAAMnC,EAAS,CACb,YAAa4H,GAAeA,EAAY,IACtCC,GAAcA,aAAsBT,EAAaS,EAAa,IAAIT,EAAWS,CAAU,CAC/F,CACA,EACI,MAAM9H,EAAMoC,EAAanC,CAAM,CACjC,CAOA,eAAgB,CACd,MAAO,sBACT,CAOA,QAAS,CACP,OAAO,KAAK,WACd,CAOA,wBAAyB,CACvB,MAAO,EACT,CAOA,WAAY,CAIV,MAAO,CACL,KAAM,oBACN,SALa,KAAK,YACjB,IAAI6H,GAAcA,EAAW,UAAS,CAAE,EACxC,OAAOR,GAAWA,IAAY,IAAI,CAIzC,CACE,CAOA,gBAAiB,CACf,OAAO3H,EAAiB,KAAK,kBAAkB,CACjD,CAOA,kBAAmB,CACjB,OAAO,KAAK,YAAY,IAAImI,GAAcA,EAAW,gBAAgB,CACvE,CAOA,mBAAoB,CAClB,OAAOX,EAAc,KAAK,oBAAoB,CAChD,CAOA,oBAAqB,CACnB,OAAO,KAAK,YAAY,IAAIW,GAAcA,EAAW,mBAAmB,CAC1E,CAEF,CCtEA,MAAMC,UAAa3C,CAAK,CAEtB,YAAYpF,EAAMoC,EAAc,KAAM,CACpC,MAAMpC,EAAMoC,EAAa,CAAE,OAAQa,EAAM,WAAY,CACvD,CAOA,eAAgB,CACd,MAAO,MACT,CAOA,WAAY,CACV,OAAO,KAAK,OAAM,CACpB,CAOA,gBAAiB,CACf,OAAOpE,EAAkB,KAAK,IAAI,CACpC,CAOA,kBAAmB,CACjB,MAAMR,EAAO,KAAK,eAAc,EAChC,OAAOA,EAAO,CAACA,CAAI,EAAI,CAAA,CACzB,CASA,aAAc,CACZ,IAAI0I,EAAKD,EAAU,KAAK,WAAW,QAAQ,EAC3C,GAAI,CAACC,EAAI,CACP,IAAIE,EAAQH,EAAU,KAAK,WAAW,cAAc,EAChDI,EAAMJ,EAAU,KAAK,WAAW,YAAY,EAChD,OAAIG,GAASC,EACJF,GAAeC,EAAOC,CAAG,EAGzBD,GAASC,CAEpB,CACA,OAAOH,CACT,CAOA,mBAAoB,CAClB,OAAO,KAAK,qBAAqB,CAAC,GAAK,IACzC,CAOA,oBAAqB,CACnB,IAAIiB,EAAQ,CAAA,EACZ,OAAI1L,EAAQ,KAAK,WAAW,cAAc,GAAKA,EAAQ,KAAK,WAAW,YAAY,EACjF0L,EAAQ,CAAC,CAAC,KAAK,WAAW,gBAAkB,KAAM,KAAK,WAAW,cAAgB,IAAI,CAAC,EAEhF1L,EAAQ,KAAK,WAAW,QAAQ,IACvC0L,EAAQ,CAAC,CAAC,KAAK,WAAW,SAAU,KAAK,WAAW,QAAQ,CAAC,GAExDA,EAAM,IAAIN,GAAYA,EAAS,IAAIC,GAAYb,EAAUa,CAAQ,CAAC,CAAC,CAC5E,CAQA,YAAYvH,EAAO,CACjB,OAAO,KAAK,WAAWA,CAAK,CAC9B,CAQA,UAAW,CACT,MAAMwC,EAAQ,KAAK,YAAY,OAAO,EACtC,OAAI,MAAM,QAAQA,CAAK,EACdF,EAAK,UAAUE,EAAO,IAAI,EAG1B,CAAA,CAEX,CAOA,mBAAoB,CAClB,OAAO,KAAK,mBAAmB,YAAY,CAC7C,CAEF,CC/IA,MAAMqF,WAAuBxF,CAAc,CAEzC,YAAYzC,EAAMoC,EAAc,KAAM,CACpC,MAAMnC,EAAS,CACb,SAAUiI,GAAYA,EAAS,IAC7BC,GAAWA,aAAmBJ,EAAOI,EAAU,IAAIJ,EAAKI,CAAO,CACvE,CACA,EACI,MAAMnI,EAAMoC,EAAanC,CAAM,CACjC,CAOA,eAAgB,CACd,MAAO,gBACT,CAOA,QAAS,CACP,OAAO,KAAK,QACd,CAOA,WAAY,CACV,OAAO,KAAK,OAAM,CACpB,CAOA,gBAAiB,CACf,OAAON,EAAiB,KAAK,kBAAkB,CACjD,CAOA,kBAAmB,CACjB,OAAO,KAAK,SAAS,IAAIyI,GAAQA,EAAK,gBAAgB,CACxD,CAOA,mBAAoB,CAClB,OAAOjB,EAAc,KAAK,oBAAoB,CAChD,CAOA,oBAAqB,CACnB,OAAO,KAAK,SAAS,IAAIiB,GAAQA,EAAK,mBAAmB,CAC3D,CAEF,CChEe,SAASC,GAAOrI,EAAMsI,EAAU,GAAMC,EAAsB,GAAO,CAIhF,OAHID,IACFtI,EAAOwI,EAAQ,KAAKxI,EAAMuI,CAAmB,GAE3CvI,EAAK,OAAS,UACT,IAAI+H,EAAK/H,CAAI,EAEbA,EAAK,OAAS,oBACd,IAAIiI,GAAejI,CAAI,EAEvBA,EAAK,OAAS,cAAgB,CAACA,EAAK,MAAQ,OAAOA,EAAK,OAAW,KAAe,OAAOA,EAAK,QAAY,IAC1G,IAAIqH,EAAWrH,CAAI,EAEnB,CAACA,EAAK,MAAQ,MAAM,QAAQA,EAAK,WAAW,EAC5C,IAAI4H,GAAqB5H,CAAI,EAG7B,IAAI6G,GAAQ7G,CAAI,CAE3B","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]}