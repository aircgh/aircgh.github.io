{"version":3,"mappings":"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","names":["SelectEventType","SelectEvent","Event","type","selected","deselected","mapBrowserEvent","originalFeatureStyles","Select","Interaction","options","singleClick","never","shiftKeyOnly","TRUE","getDefaultStyleFunction","Collection","layerFilter","layers","layer","feature","getUid","hitTolerance","map","CollectionEventType","evt","VectorLayer","key","interactions","i","interaction","Feature","features","clear","add","remove","toggle","set","foundAtCursor","modifiedFeature","styles","createEditingStyle","extend","u8","u16","i32","fleb","fdeb","clim","freb","eb","start","b","r","j","_a","fl","revfl","_b","fd","rev","x","hMap","cd","mb","s","l","le","co","rvb","sv","r_1","v","m","flt","fdt","flrm","fdrm","max","a","bits","d","p","o","bits16","shft","slc","e","ec","err","ind","msg","nt","inflt","dat","st","buf","dict","sl","dl","noBuf","resize","noSt","cbuf","bl","nbuf","final","pos","bt","lm","dm","lbt","dbt","tbts","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","c","n","lt","dt","t","lms","dms","lpos","sym","dsym","end","shift","dend","et","gzs","flg","zs","gzl","zls","inflateSync","data","opts","gunzipSync","unzlibSync","decompressSync","td","tds","B","h","W","E","y","w","z","f","u","N","k","q","G","ie","J","D","F","O","_","Y","Q","A","C","T","g","X","Z","U","I","K","R","M","P","H","__defProp","__getOwnPropSymbols","__hasOwnProp","__propIsEnum","__defNormalProp","obj","value","__spreadValues","prop","__name","target","__async","__this","__arguments","generator","resolve","reject","fulfilled","step","rejected","_PMTilesRasterSource","DataTileSource","src","img","PMTiles","projection","createXYZ","extentFromProjection","response","image","PMTilesRasterSource","_PMTilesVectorSource","VectorTileSource","MVT","tile","url","vtile","re","result","extent","resolution","tile_result","format","TileState","PMTilesVectorSource","hasText","string","ensureNumber","num","min","delta","min2","max2","isObject","getMinForDataType","str","getMaxForDataType","getMinMaxValues","object","stats","isComplete","statistics","histogram","classification","cls","values","data_type","getNoDataValues","nodata","common","file","toObject","bbox","hasZ","west","east","south","north","bboxToCoords","centerOfBoundingBox","ensureBoundingBox","point","isAntimeridianBoundingBox","fixGeoJsonGoordinates","coords","lon","lat","fixGeoJson","geojson","geometry","toGeoJSON","bboxes","coordinates","list","allow3D","base","height","unionBoundingBox","extrema","fn","STACObject","keyMap","privateKeys","stringify","field","v2","browserProtocols","toAbsolute","href","baseUrl","normalizeUri","noParams","uri","URI","baseUri","baseUriPath","geojsonMediaType","stacMediaTypes","browserImageTypes","cogMediaTypes","geotiffMediaTypes","isMediaType","allowedTypes","allowUndefined","isStacMediaType","STACReference","context","protocol","extension","types","Link","links","link","STACHypermedia","absoluteUrl","self","rel","rels","APICollection","Band","index","bands","newBands","newBand","NO_INHERITANCE","Asset","rgb","band","property","roles","role","includeKey","assets","newAssets","newAsset","parse","locale","stringLocale","keywordPos","keyword","localeWithoutKeyword","parts","language","retVar","variant","country","script","prepareSupported","supported","lgs","supportedLocale","lg","getBest","defaultLocale","getAnyCountry","countries","main","firstCountry","STAC","fallbackLocale","available","best","browserOnly","prefer","thumbnails","asset","thumbnail","filter","httpOnly","cogOnly","roleScores","additionalCriteria","scores","score","names","other","pattern","regexp","CatalogLike","method","Catalog","isoToDate","centerDateTime","unionDateTime","assign","raw","extents","interval","datetime","CollectionCollection","collections","collection","Item","dates","ItemCollection","item","create","migrate","updateVersionNumber","Migrate","ErrorEvent","BaseEvent","error","EventType","LABEL_EXTENSION","transparentFill","Fill","getStyle","strokeColor","strokeWidth","fillColor","circleRadius","fill","stroke","Stroke","Style","Circle","defaultBoundsStyle","defaultCollectionStyle","getStacObjectsForEvent","event","exclude","selectedFeatures","objects","stac","getGeoTiffSourceInfoFromAsset","selectedBands","sourceInfo","source","minimum","maximum","bandNoData","visualBands","loadProjection","code","fromProjectionCode","fromEPSGCode","__vitePreload","getProjection","reference","defaultProjection","isProj4Registered","getBoundsStyle","originalStyle","layerGroup","style","getSpecificWebMapUrl","isScalar","isMask","readRGB","preference","interpretation","interpretations","geotiffGlobals.photometricInterpretations","STATISTICS_MAXIMUM","STATISTICS_MINIMUM","defaultTileSize","workerPool","getWorkerPool","Pool","getBoundingBox","getOrigin","getResolutions","referenceImage","getProjectionFromKeys","geoKeys","geoKey","unitKey","loadMissingProjection","getCachedProjection","units","unitsFromCode","Projection","getImagesForTIFF","tiff","count","requests","getImagesForSource","request","tiffFromBlob","tiffFromUrls","tiffFromUrl","assertEqual","expected","got","tolerance","message","rejector","length","array","GeoTIFFSource","DataTile","numSources","sources","logError","firstSource","modelTransformation","matrix","multiplyTransform","origin","commonRenderTileSizes","commonSourceTileSizes","resolutions","samplesPerPixel","nodataValues","metadata","minZoom","sourceCount","sourceIndex","images","masks","imageCount","sourceExtent","sourceOrigin","sourceTileSizes","renderTileSizes","sourceResolutions","imageIndex","nodataValue","wantedSamples","level","imageResolutions","sourceTileSize","aspectRatio","getIntersection","resolutionFactor","scaledSourceResolutions","ii","sourceImagery","outer","bandCount","tileGrid","TileGrid","zoom","viewExtent","makeInverse","createMatrix","transformFn","createTransformFromCoordinateTransform","input","applyMatrix","applyTransform","toUserCoordinate","getCenter","toUserExtent","pool","pixelBounds","samples","bandNumber","fillValue","sampleIndex","readOptions","maskIndex","mask","sourceSamples","normalize","addAlpha","pixelCount","dataLength","dataIndex","pixelIndex","transparent","gain","bias","sourceValue","clamp","bandIndex","nodataIsNaN","SourceType","name","STACLayer","LayerGroup","superOptions","responseType","isEmpty","children","updateBoundsStyle","errorHandler","promises","defaultOptions","subgroup","transformExtent","ImageLayer","StaticImage","updateOptions","headers","pmtiles.PMTiles","pmtiles.TileType","TileJSON","params","wmsOptions","WMS","wmtsCapabilities","wmtsOptions","optionsFromCapabilities","uriTemplate","vars","schema","WMTS","XYZ","VectorTileLayer","WebGLTileLayer","TileLayer","GeoTIFF","status","zIndex","visible","GeoJSON","VectorSource","labelAsset","sourceLinks","items","emit","oldLayers","ref","geotiff","boundsLayer","mapLinks","match","candidate","prioA","prioB","updateLayers","childs","child","view","state","attribution","encoding","urlObj","WMTSCapabilities","selectStyle","mapId","_sfc_main","defineAsyncComponent","LayerControl","TextControl","MapMixin","mapGetters","empty","selection","StacLayer","writer","container","MapUtils","_hoisted_1","_hoisted_4","_hoisted_5","_openBlock","_createElementBlock","_createElementVNode","$data","_createVNode","_component_LayerControl","_ctx","_createBlock","_component_TextControl","_hoisted_3","$props","_component_b_popover","$options","_component_Items","_component_Catalogs","_component_Features","_component_b_button"],"ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29],"sources":["../../node_modules/ol/interaction/Select.js","../../node_modules/fflate/esm/browser.js","../../node_modules/pmtiles/dist/esm/index.js","../../node_modules/ol-pmtiles/dist/esm/index.js","../../node_modules/ol-stac/node_modules/stac-js/src/utils.js","../../node_modules/ol-stac/node_modules/stac-js/src/geo.js","../../node_modules/ol-stac/node_modules/stac-js/src/object.js","../../node_modules/ol-stac/node_modules/stac-js/src/http.js","../../node_modules/ol-stac/node_modules/stac-js/src/mediatypes.js","../../node_modules/ol-stac/node_modules/stac-js/src/reference.js","../../node_modules/ol-stac/node_modules/stac-js/src/link.js","../../node_modules/ol-stac/node_modules/stac-js/src/hypermedia.js","../../node_modules/ol-stac/node_modules/stac-js/src/apicollection.js","../../node_modules/ol-stac/node_modules/stac-js/src/band.js","../../node_modules/ol-stac/node_modules/stac-js/src/asset.js","../../node_modules/ol-stac/node_modules/stac-js/src/locales.js","../../node_modules/ol-stac/node_modules/stac-js/src/stac.js","../../node_modules/ol-stac/node_modules/stac-js/src/cataloglike.js","../../node_modules/ol-stac/node_modules/stac-js/src/catalog.js","../../node_modules/ol-stac/node_modules/stac-js/src/datetime.js","../../node_modules/ol-stac/node_modules/stac-js/src/collection.js","../../node_modules/ol-stac/node_modules/stac-js/src/collectioncollection.js","../../node_modules/ol-stac/node_modules/stac-js/src/item.js","../../node_modules/ol-stac/node_modules/stac-js/src/itemcollection.js","../../node_modules/ol-stac/node_modules/stac-js/src/index.js","../../node_modules/ol-stac/events/ErrorEvent.js","../../node_modules/ol-stac/util.js","../../node_modules/ol-stac/source/GeoTIFF.js","../../node_modules/ol-stac/source/type.js","../../node_modules/ol-stac/layer/STAC.js","../../src/components/MapView.vue"],"sourcesContent":["/**\n * @module ol/interaction/Select\n */\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Feature from '../Feature.js';\nimport {extend} from '../array.js';\nimport Event from '../events/Event.js';\nimport {never, shiftKeyOnly, singleClick} from '../events/condition.js';\nimport {TRUE} from '../functions.js';\nimport VectorLayer from '../layer/Vector.js';\nimport {clear} from '../obj.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {getUid} from '../util.js';\nimport Interaction from './Interaction.js';\n\n/**\n * @enum {string}\n */\nconst SelectEventType = {\n  /**\n   * Triggered when feature(s) has been (de)selected.\n   * @event SelectEvent#select\n   * @api\n   */\n  SELECT: 'select',\n};\n\n/**\n * A function that takes a {@link module:ol/Feature~Feature} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @typedef {function(import(\"../Feature.js\").default, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [addCondition] A function\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is the event\n * for the selected features as a whole. By default, this is\n * {@link module:ol/events/condition.singleClick}. Clicking on a feature selects that\n * feature and removes any that were in the selection. Clicking outside any\n * feature removes all from the selection.\n * See `toggle`, `add`, `remove` options for adding/removing extra features to/\n * from the selection.\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers]\n * A list of layers from which features should be selected. Alternatively, a\n * filter function can be provided. The function will be called for each layer\n * in the map and should return `true` for layers that you want to be\n * selectable. If the option is absent, all visible layers will be considered\n * selectable.\n * @property {import(\"../style/Style.js\").StyleLike|null} [style]\n * Style for the selected features. By default the default edit style is used\n * (see {@link module:ol/style/Style~Style}). Set to `null` if this interaction should not apply\n * any style changes for selected features.\n * If set to a falsey value, the selected feature's style will not change.\n * @property {import(\"../events/condition.js\").Condition} [removeCondition] A function\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [toggleCondition] A function\n * that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is in addition\n * to the `condition` event. By default,\n * {@link module:ol/events/condition.shiftKeyOnly}, i.e. pressing `shift` as\n * well as the `condition` event, adds that feature to the current selection if\n * it is not currently selected, and removes it if it is. See `add` and `remove`\n * if you want to use different events instead of a toggle.\n * @property {boolean} [multi=false] A boolean that determines if the default\n * behaviour should select only single features or all (overlapping) features at\n * the clicked map position. The default of `false` means single select.\n * @property {Collection<Feature>} [features]\n * Collection where the interaction will place selected features. Optional. If\n * not set the interaction will create a collection. In any case the collection\n * used by the interaction is returned by\n * {@link module:ol/interaction/Select~Select#getFeatures}.\n * @property {FilterFunction} [filter] A function\n * that takes a {@link module:ol/Feature~Feature} and a\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside\n * the radius around the given position will be checked for features.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of\n * this type.\n */\nexport class SelectEvent extends Event {\n  /**\n   * @param {SelectEventType} type The event type.\n   * @param {Array<import(\"../Feature.js\").default>} selected Selected features.\n   * @param {Array<import(\"../Feature.js\").default>} deselected Deselected features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Associated\n   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   */\n  constructor(type, selected, deselected, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * Selected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.selected = selected;\n\n    /**\n     * Deselected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.deselected = deselected;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/**\n * Original feature styles to reset to when features are no longer selected.\n * @type {Object<number, import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction>}\n */\nconst originalFeatureStyles = {};\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'select', SelectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'select', Return>} SelectOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for selecting vector features. By default, selected features are\n * styled differently, so this interaction can be used for visual highlighting,\n * as well as selecting features for other actions, such as modification or\n * output. There are three ways of controlling which features are selected:\n * using the browser event as defined by the `condition` and optionally the\n * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a\n * further feature filter using the `filter` option.\n *\n * @fires SelectEvent\n * @api\n */\nclass Select extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {SelectOnSignature<void>}\n     */\n    this.un;\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     */\n    this.boundAddFeature_ = this.addFeature_.bind(this);\n\n    /**\n     * @private\n     */\n    this.boundRemoveFeature_ = this.removeFeature_.bind(this);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : singleClick;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.addCondition_ = options.addCondition ? options.addCondition : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.removeCondition_ = options.removeCondition\n      ? options.removeCondition\n      : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.toggleCondition_ = options.toggleCondition\n      ? options.toggleCondition\n      : shiftKeyOnly;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multi_ = options.multi ? options.multi : false;\n\n    /**\n     * @private\n     * @type {FilterFunction}\n     */\n    this.filter_ = options.filter ? options.filter : TRUE;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n\n    /**\n     * @private\n     * @type {import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction|null}\n     */\n    this.style_ =\n      options.style !== undefined ? options.style : getDefaultStyleFunction();\n\n    /**\n     * @private\n     * @type {Collection<Feature>}\n     */\n    this.features_ = options.features || new Collection();\n\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\n    let layerFilter;\n    if (options.layers) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        const layers = options.layers;\n        layerFilter = function (layer) {\n          return layers.includes(layer);\n        };\n      }\n    } else {\n      layerFilter = TRUE;\n    }\n\n    /**\n     * @private\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\n     */\n    this.layerFilter_ = layerFilter;\n\n    /**\n     * An association between selected feature (key)\n     * and layer (value)\n     * @private\n     * @type {Object<string, import(\"../layer/Layer.js\").default>}\n     */\n    this.featureLayerAssociation_ = {};\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"../layer/Layer.js\").default} layer Layer.\n   * @private\n   */\n  addFeatureLayerAssociation_(feature, layer) {\n    this.featureLayerAssociation_[getUid(feature)] = layer;\n  }\n\n  /**\n   * Get the selected features.\n   * @return {Collection<Feature>} Features collection.\n   * @api\n   */\n  getFeatures() {\n    return this.features_;\n  }\n\n  /**\n   * Returns the Hit-detection tolerance.\n   * @return {number} Hit tolerance in pixels.\n   * @api\n   */\n  getHitTolerance() {\n    return this.hitTolerance_;\n  }\n\n  /**\n   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of\n   * a selected feature.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @return {import('../layer/Vector.js').default} Layer.\n   * @api\n   */\n  getLayer(feature) {\n    return /** @type {import('../layer/Vector.js').default} */ (\n      this.featureLayerAssociation_[getUid(feature)]\n    );\n  }\n\n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n  setHitTolerance(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  }\n\n  /**\n   * Remove the interaction from its current map, if any,  and attach it to a new\n   * map, if any. Pass `null` to just remove the interaction from the current map.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   * @override\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    if (currentMap && this.style_) {\n      this.features_.forEach(this.restorePreviousStyle_.bind(this));\n    }\n    super.setMap(map);\n    if (map) {\n      this.features_.addEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_,\n      );\n      this.features_.addEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_,\n      );\n\n      if (this.style_) {\n        this.features_.forEach(this.applySelectedStyle_.bind(this));\n      }\n    } else {\n      this.features_.removeEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_,\n      );\n      this.features_.removeEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_,\n      );\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  addFeature_(evt) {\n    const feature = evt.element;\n    if (this.style_) {\n      this.applySelectedStyle_(feature);\n    }\n    if (!this.getLayer(feature)) {\n      const layer = this.findLayerOfFeature_(feature);\n      if (layer) {\n        this.addFeatureLayerAssociation_(feature, layer);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  removeFeature_(evt) {\n    if (this.style_) {\n      this.restorePreviousStyle_(evt.element);\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature of which to get the layer\n   * @return {VectorLayer} layer, if one was found.\n   * @private\n   */\n  findLayerOfFeature_(feature) {\n    const layer = /** @type {VectorLayer} */ (\n      this.getMap()\n        .getAllLayers()\n        .find(function (layer) {\n          if (\n            layer instanceof VectorLayer &&\n            layer.getSource() &&\n            layer.getSource().hasFeature(feature)\n          ) {\n            return layer;\n          }\n        })\n    );\n    return layer;\n  }\n\n  /**\n   * @return {import(\"../style/Style.js\").StyleLike|null} Select style.\n   */\n  getStyle() {\n    return this.style_;\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  applySelectedStyle_(feature) {\n    const key = getUid(feature);\n    if (!(key in originalFeatureStyles)) {\n      originalFeatureStyles[key] = feature.getStyle();\n    }\n    feature.setStyle(this.style_);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  restorePreviousStyle_(feature) {\n    const interactions = this.getMap().getInteractions().getArray();\n    for (let i = interactions.length - 1; i >= 0; --i) {\n      const interaction = interactions[i];\n      if (\n        interaction !== this &&\n        interaction instanceof Select &&\n        interaction.getStyle() &&\n        interaction.getFeatures().getArray().lastIndexOf(feature) !== -1\n      ) {\n        feature.setStyle(interaction.getStyle());\n        return;\n      }\n    }\n\n    const key = getUid(feature);\n    feature.setStyle(originalFeatureStyles[key]);\n    delete originalFeatureStyles[key];\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  removeFeatureLayerAssociation_(feature) {\n    delete this.featureLayerAssociation_[getUid(feature)];\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").FeatureLike} feature The feature to select\n   * @param {import(\"../layer/Layer.js\").default} layer Optional layer containing this feature\n   * @param {Array<Feature>} [selected] optional array to which selected features will be added\n   * @return {Feature|undefined} The feature, if it got selected.\n   * @private\n   */\n  selectFeatureInternal_(feature, layer, selected) {\n    if (!(feature instanceof Feature)) {\n      return;\n    }\n    if (!this.filter_(feature, layer)) {\n      return;\n    }\n    const features = this.getFeatures();\n    if (!features.getArray().includes(feature)) {\n      this.addFeatureLayerAssociation_(feature, layer);\n      features.push(feature);\n      selected?.push(feature);\n    }\n    return feature;\n  }\n\n  /**\n   * Try to select a feature as if it was clicked and `addCondition` evaluated to True.\n   * Unlike modifying `select.getFeatures()` directly, this respects the `filter` and `layers` options (except `multi`, which is ignored).\n   * The {@link module:ol/interaction/Select~SelectEvent} fired by this won't have a mapBrowserEvent property\n   * @param {Feature} feature The feature to select\n   * @return {boolean} True if the feature was selected\n   */\n  selectFeature(feature) {\n    const layer = this.findLayerOfFeature_(feature);\n    if (!this.layerFilter_(layer)) {\n      return false;\n    }\n    const selected = this.selectFeatureInternal_(feature, layer);\n    if (selected) {\n      this.dispatchEvent(\n        new SelectEvent(SelectEventType.SELECT, [selected], [], undefined),\n      );\n    }\n    return !!selected;\n  }\n\n  /**\n   * Deselects a feature if it was previously selected. Also removes layer association.\n   * @param {import(\"../Feature.js\").FeatureLike} feature The feature to deselect\n   * @param {Array<Feature>} [deselected] optional array to which deselected features will be added\n   * @return {Feature|undefined} The feature, if it was previously selected.\n   * @private\n   */\n  removeFeatureInternal_(feature, deselected) {\n    const features = this.getFeatures();\n    if (\n      !(feature instanceof Feature) ||\n      !features.getArray().includes(feature)\n    ) {\n      return;\n    }\n    features.remove(feature);\n    this.removeFeatureLayerAssociation_(feature);\n    deselected?.push(feature);\n    return feature;\n  }\n\n  /**\n   * Try to deselect a feature as if it was clicked.\n   * Compared to `select.getFeatures().remove(feature)` this causes a SelectEvent.\n   * The {@link module:ol/interaction/Select~SelectEvent} fired by this won't have a mapBrowserEvent property\n   * @param {Feature} feature The feature to deselect\n   * @return {boolean} True if the feature was deselected\n   */\n  deselectFeature(feature) {\n    const deselected = this.removeFeatureInternal_(feature);\n    if (deselected) {\n      this.dispatchEvent(\n        new SelectEvent(SelectEventType.SELECT, [], [deselected], undefined),\n      );\n    }\n    return !!deselected;\n  }\n\n  /**\n   * Try to toggle a feature as if it was clicked and `toggleCondition` was True.\n   * Unlike modifying `select.getFeatures()` directly, this respects the `filter` and `layers` options (except `multi`, which is ignored).\n   * The {@link module:ol/interaction/Select~SelectEvent} fired by this won't have a mapBrowserEvent property\n   * @param {Feature} feature The feature to deselect\n   */\n  toggleFeature(feature) {\n    if (!this.deselectFeature(feature)) {\n      this.selectFeature(feature);\n    }\n  }\n  /**\n   * Deselect all features as if a user deselected them.\n   * Compared to `select.getFeatures().clear()` this causes a SelectEvent.\n   * The {@link module:ol/interaction/Select~SelectEvent} fired by this won't have a mapBrowserEvent property\n   */\n  clearSelection() {\n    clear(this.featureLayerAssociation_);\n    const features = this.getFeatures();\n    const deselected = features.getArray().slice(); // shallow copy\n    features.clear();\n    if (deselected.length !== 0) {\n      this.dispatchEvent(\n        new SelectEvent(SelectEventType.SELECT, [], deselected, undefined),\n      );\n    }\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the\n   * selected state of features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @override\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    const add = this.addCondition_(mapBrowserEvent);\n    const remove = this.removeCondition_(mapBrowserEvent);\n    const toggle = this.toggleCondition_(mapBrowserEvent);\n    const set = !add && !remove && !toggle;\n    const map = mapBrowserEvent.map;\n    const features = this.getFeatures();\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const deselected = [];\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const selected = [];\n\n    // TODO: technically the way i've restructured this logic means that\n    //       instead of first emptying the features list of all extra features and then adding the selected ones back,\n    //       the selected features get added and then the old ones get removed.\n    //       a grow then shrink, instead of a shrink then grow. I can't imagine anyone relying on this, but alas, its worth a mention.\n    if (set) {\n      // Replace the currently selected feature(s) with the feature(s) at the\n      // pixel, or clear the selected feature(s) if there is no feature at\n      // the pixel.\n      let foundAtCursor = false;\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        (feature, layer) => {\n          foundAtCursor = true;\n          if (!this.selectFeatureInternal_(feature, layer, selected)) {\n            return; // keep going, this one wasn't selected\n          }\n          return !this.multi_; // stop if not multi\n        },\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        },\n      );\n\n      for (let i = features.getLength() - 1; i >= 0; --i) {\n        const feature = features.item(i);\n        if (\n          // remove all but selected, if there were any selected\n          (selected.length > 0 && !selected.includes(feature)) ||\n          // remove all, if click outside of layer\n          !foundAtCursor\n        ) {\n          this.removeFeatureInternal_(feature, deselected);\n        }\n      }\n    } else {\n      // Modify the currently selected feature(s).\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        (feature, layer) => {\n          let modifiedFeature;\n          if (remove || toggle) {\n            modifiedFeature = this.removeFeatureInternal_(feature, deselected);\n          }\n          if ((add || toggle) && !modifiedFeature) {\n            modifiedFeature = this.selectFeatureInternal_(\n              feature,\n              layer,\n              selected,\n            );\n          }\n          if (!modifiedFeature) {\n            return; // keep going, this one wasn't removed/selected\n          }\n          return !this.multi_; // stop if not multi\n        },\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        },\n      );\n    }\n    if (selected.length > 0 || deselected.length > 0) {\n      this.dispatchEvent(\n        new SelectEvent(\n          SelectEventType.SELECT,\n          selected,\n          deselected,\n          mapBrowserEvent,\n        ),\n      );\n    }\n    return true;\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  extend(styles['Polygon'], styles['LineString']);\n  extend(styles['GeometryCollection'], styles['LineString']);\n\n  return function (feature) {\n    if (!feature.getGeometry()) {\n      return null;\n    }\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\nexport default Select;\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new i32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return { b: b, r: r };\n};\nvar _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8)) >> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 1; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    return new u8(v.subarray(s, e));\n};\n/**\n * Codes for errors generated within this library\n */\nexport var FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, st, buf, dict) {\n    // source length       dict length\n    var sl = dat.length, dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l)\n        return buf || new u8(0);\n    var noBuf = !buf;\n    // have to estimate size\n    var resize = noBuf || st.i != 2;\n    // no state\n    var noSt = st.i;\n    // Assumes roughly 33% compression ratio average\n    if (noBuf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (resize)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17\n        if (resize)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (resize)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                if (bt < dt) {\n                    var shift = dl - dt, dend = Math.min(dt, end);\n                    if (shift + bt < 0)\n                        err(3);\n                    for (; bt < dend; ++bt)\n                        buf[bt] = dict[shift + bt];\n                }\n                for (; bt < end; ++bt)\n                    buf[bt] = buf[bt - dt];\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    // don't reallocate for streams or user buffers\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n    d[o + 2] |= v >> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return { t: et, l: 0 };\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return { t: v, l: 1 };\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return { t: new u8(tr), l: mbt };\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return { c: cl.subarray(0, cli), n: s };\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;\n    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;\n    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;\n    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        ++lcfreq[lclt[i] & 31];\n    for (var i = 0; i < lcdt.length; ++i)\n        ++lcfreq[lcdt[i] & 31];\n    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];\n    if (bs >= 0 && flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >> 5) & 127), p += clct[i] >> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        var sym = syms[i];\n        if (sym > 255) {\n            var len = (sym >> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (sym >> 23) & 31), p += fleb[len];\n            var dst = sym & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (sym >> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[sym]), p += ll[sym];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, st) {\n    var s = st.z || dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var lst = st.l;\n    var pos = (st.r || 0) & 7;\n    if (lvl) {\n        if (pos)\n            w[0] = st.r >> 3;\n        var opt = deo[lvl - 1];\n        var n = opt >> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new i32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos\n        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;\n        for (; i + 2 < s; ++i) {\n            // hash value\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = i - dif + j & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one int32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        for (i = Math.max(i, wi); i < s; ++i) {\n            syms[li++] = dat[i];\n            ++lf[dat[i]];\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        if (!lst) {\n            st.r = (pos & 7) | w[(pos / 8) | 0] << 3;\n            // shft(pos) now 1 less if pos & 7 != 0\n            pos -= 7;\n            st.h = head, st.p = prev, st.i = i, st.w = wi;\n        }\n    }\n    else {\n        for (var i = st.w || 0; i < s + lst; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[(pos / 8) | 0] = lst;\n                e = s;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n        st.i = s;\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Adler32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | (b >> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    if (!st) {\n        st = { l: 1 };\n        if (opt.dictionary) {\n            var dict = opt.dictionary.subarray(-32768);\n            var newDat = new u8(dict.length + dat.length);\n            newDat.set(dict);\n            newDat.set(dat, dict.length);\n            dat = newDat;\n            st.w = dict.length;\n        }\n    }\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? (st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20) : (12 + opt.mem), pre, post, st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return fnStr;\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            fnStr = wcln(fns[i], fnStr, td_1);\n        ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };\n    }\n    var td = mrg({}, ch[id].e);\n    return wk(ch[id].c + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt]; };\nvar bDflt = function () { return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zls]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get opts\nvar gopt = function (o) { return o && {\n    out: o.size && new u8(o.size),\n    dictionary: o.dictionary\n}; };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) {\n        if (ev.data.length) {\n            strm.push(ev.data[0], ev.data[1]);\n            postMessage([ev.data[0].length]);\n        }\n        else\n            strm.flush();\n    };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id, flush, ext) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else if (!Array.isArray(dat))\n            ext(dat);\n        else if (dat.length == 1) {\n            strm.queuedSize -= dat[0];\n            if (strm.ondrain)\n                strm.ondrain(dat[0]);\n        }\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.queuedSize = 0;\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        strm.queuedSize += d.length;\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n    if (flush) {\n        strm.flush = function () { w.postMessage([]); };\n    }\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + (o.filename ? o.filename.length + 1 : 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (o.dictionary && 32);\n    c[1] |= 31 - ((c[0] << 8) | c[1]) % 31;\n    if (o.dictionary) {\n        var h = adler();\n        h.p(o.dictionary);\n        wbytes(c, 2, h.d());\n    }\n};\n// zlib start\nvar zls = function (d, dict) {\n    if ((d[0] & 15) != 8 || (d[0] >> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if ((d[1] >> 5 & 1) == +!dict)\n        err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');\n    return (d[1] >> 3 & 4) + 2;\n};\nfunction StrmOpt(opts, cb) {\n    if (typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n        this.s = { l: 0, i: 32768, w: 32768, z: 32768 };\n        // Buffer length must always be 0 mod 32768 for index calculations to be correct when modifying head and prev\n        // 98304 = 32768 (lookback) + 65536 (common chunk size)\n        this.b = new u8(98304);\n        if (this.o.dictionary) {\n            var dict = this.o.dictionary.subarray(-32768);\n            this.b.set(dict, 32768 - dict.length);\n            this.s.i = 32768 - dict.length;\n        }\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, this.s), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        var endLen = chunk.length + this.s.z;\n        if (endLen > this.b.length) {\n            if (endLen > 2 * this.b.length - 32768) {\n                var newBuf = new u8(endLen & -32768);\n                newBuf.set(this.b.subarray(0, this.s.z));\n                this.b = newBuf;\n            }\n            var split = this.b.length - this.s.z;\n            this.b.set(chunk.subarray(0, split), this.s.z);\n            this.s.z = this.b.length;\n            this.p(this.b, false);\n            this.b.set(this.b.subarray(-32768));\n            this.b.set(chunk.subarray(split), 32768);\n            this.s.z = chunk.length - split + 32768;\n            this.s.i = 32766, this.s.w = 32768;\n        }\n        else {\n            this.b.set(chunk, this.s.z);\n            this.s.z += chunk.length;\n        }\n        this.s.l = final & 1;\n        if (this.s.z > this.s.w + 8191 || final) {\n            this.p(this.b, final || false);\n            this.s.w = this.s.i, this.s.i -= 2;\n        }\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * deflated output for small inputs.\n     */\n    Deflate.prototype.flush = function () {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        this.p(this.b, false);\n        this.s.w = this.s.i, this.s.i -= 2;\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6, 1);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    function Inflate(opts, cb) {\n        // no StrmOpt here to avoid adding to workerizer\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n        this.s = { i: 0, b: dict ? dict.length : 0 };\n        this.o = new u8(32768);\n        this.p = new u8(0);\n        if (dict)\n            this.o.set(dict);\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        if (!this.p.length)\n            this.p = c;\n        else if (c.length) {\n            var n = new u8(this.p.length + c.length);\n            n.set(this.p), n.set(c, this.p.length), this.p = n;\n        }\n    };\n    Inflate.prototype.c = function (final) {\n        this.s.i = +(this.d = final || false);\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.s, this.o);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    function AsyncInflate(opts, cb) {\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Inflate(ev.data);\n            onmessage = astrm(strm);\n        }, 7, 0);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gopt(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, opts) {\n    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        this.l += chunk.length;\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * GZIPped output for small inputs.\n     */\n    Gzip.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8, 1);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming single or multi-member GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    function Gunzip(opts, cb) {\n        this.v = 1;\n        this.r = 0;\n        Inflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        this.r += chunk.length;\n        if (this.v) {\n            var p = this.p.subarray(this.v - 1);\n            var s = p.length > 3 ? gzs(p) : 4;\n            if (s > p.length) {\n                if (!final)\n                    return;\n            }\n            else if (this.v > 1 && this.onmember) {\n                this.onmember(this.r - p.length);\n            }\n            this.p = p.subarray(s), this.v = 0;\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n        // process concatenated GZIP\n        if (this.s.f && !this.s.l && !final) {\n            this.v = shft(this.s.p) + 9;\n            this.s = { i: 0 };\n            this.o = new u8(0);\n            this.push(new u8(0), final);\n        }\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming single or multi-member GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    function AsyncGunzip(opts, cb) {\n        var _this = this;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gunzip(ev.data);\n            strm.onmember = function (offset) { return postMessage(offset); };\n            onmessage = astrm(strm);\n        }, 9, 0, function (offset) { return _this.onmember && _this.onmember(offset); });\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0], ev.data[1])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, opts) {\n    var st = gzs(data);\n    if (st + 8 > data.length)\n        err(6, 'invalid gzip data');\n    return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * zlibbed output for small inputs.\n     */\n    Zlib.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10, 1);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    function Unzlib(opts, cb) {\n        Inflate.call(this, opts, cb);\n        this.v = opts && opts.dictionary ? 2 : 1;\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 6 && !final)\n                return;\n            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    function AsyncUnzlib(opts, cb) {\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Unzlib(ev.data);\n            onmessage = astrm(strm);\n        }, 11, 0);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gopt(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, opts) {\n    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    function Decompress(opts, cb) {\n        this.o = StrmOpt.call(this, opts, cb) || {};\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n    }\n    // init substream\n    // overriden by AsyncDecompress\n    Decompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (dat, final) {\n            _this.ondata(dat, final);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(this.o)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(this.o)\n                        : new this.Z(this.o);\n                this.i();\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    function AsyncDecompress(opts, cb) {\n        Decompress.call(this, opts, cb);\n        this.queuedSize = 0;\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n    }\n    AsyncDecompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        };\n        this.s.ondrain = function (size) {\n            _this.queuedSize -= size;\n            if (_this.ondrain)\n                _this.ondrain(size);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        this.queuedSize += chunk.length;\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, opts) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, opts)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, opts)\n            : unzlibSync(data, opts);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return { s: r, r: slc(d, i - 1) };\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (final) {\n            if (r.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = r;\n        this.ondata(s, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td) {\n        return td.decode(dat);\n    }\n    else {\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (r.length)\n            err(8);\n        return s;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this.ondata(err, dat, final);\n                    _this.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this.d & 1))\n                        return;\n                    _this.u.splice(-1, 1);\n                    _this.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this = this;\n        this.i = new Inflate(function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this.k[0] == chks_3 && _this.c)\n                                        _this.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nexport function unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    // Synchronously decompress under 512KB, or barely-compressed data\n                    if (su < 524288 || sc > 0.8 * su) {\n                        try {\n                            cbl(null, inflateSync(infl, { out: new u8(su) }));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nexport function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n","var j=Object.defineProperty;var B=Math.pow;var l=(o,t)=>j(o,\"name\",{value:t,configurable:!0});var m=(o,t,e)=>new Promise((r,n)=>{var s=c=>{try{a(e.next(c))}catch(u){n(u)}},i=c=>{try{a(e.throw(c))}catch(u){n(u)}},a=c=>c.done?r(c.value):Promise.resolve(c.value).then(s,i);a((e=e.apply(o,t)).next())});import{decompressSync as F}from\"fflate\";var re=l((o,t)=>{let e=!1,r=\"\",n=L.GridLayer.extend({createTile:l((s,i)=>{let a=document.createElement(\"img\"),c=new AbortController,u=c.signal;return a.cancel=()=>{c.abort()},e||(o.getHeader().then(d=>{d.tileType===1?console.error(\"Error: archive contains MVT vector tiles, but leafletRasterLayer is for displaying raster tiles. See https://github.com/protomaps/PMTiles/tree/main/js for details.\"):d.tileType===2?r=\"image/png\":d.tileType===3?r=\"image/jpeg\":d.tileType===4?r=\"image/webp\":d.tileType===5&&(r=\"image/avif\")}),e=!0),o.getZxy(s.z,s.x,s.y,u).then(d=>{if(d){let h=new Blob([d.data],{type:r}),p=window.URL.createObjectURL(h);a.src=p}else a.style.display=\"none\";a.cancel=void 0,i(void 0,a)}).catch(d=>{if(d.name!==\"AbortError\")throw d}),a},\"createTile\"),_removeTile:l(function(s){let i=this._tiles[s];i&&(i.el.cancel&&i.el.cancel(),i.el.width=0,i.el.height=0,i.el.deleted=!0,L.DomUtil.remove(i.el),delete this._tiles[s],this.fire(\"tileunload\",{tile:i.el,coords:this._keyToTileCoords(s)}))},\"_removeTile\")});return new n(t)},\"leafletRasterLayer\"),W=l(o=>(t,e)=>{if(e instanceof AbortController)return o(t,e);let r=new AbortController;return o(t,r).then(n=>e(void 0,n.data,n.cacheControl||\"\",n.expires||\"\"),n=>e(n)).catch(n=>e(n)),{cancel:l(()=>r.abort(),\"cancel\")}},\"v3compat\"),E=class E{constructor(t){this.tilev4=l((t,e)=>m(this,null,function*(){if(t.type===\"json\"){let p=t.url.substr(10),y=this.tiles.get(p);if(y||(y=new w(p),this.tiles.set(p,y)),this.metadata){let z=yield y.getTileJson(t.url);return e.signal.throwIfAborted(),{data:z}}let f=yield y.getHeader();return e.signal.throwIfAborted(),(f.minLon>=f.maxLon||f.minLat>=f.maxLat)&&console.error(`Bounds of PMTiles archive ${f.minLon},${f.minLat},${f.maxLon},${f.maxLat} are not valid.`),{data:{tiles:[`${t.url}/{z}/{x}/{y}`],minzoom:f.minZoom,maxzoom:f.maxZoom,bounds:[f.minLon,f.minLat,f.maxLon,f.maxLat]}}}let r=new RegExp(/pmtiles:\\/\\/(.+)\\/(\\d+)\\/(\\d+)\\/(\\d+)/),n=t.url.match(r);if(!n)throw new Error(\"Invalid PMTiles protocol URL\");let s=n[1],i=this.tiles.get(s);i||(i=new w(s),this.tiles.set(s,i));let a=n[2],c=n[3],u=n[4],d=yield i.getHeader(),h=yield i==null?void 0:i.getZxy(+a,+c,+u,e.signal);if(e.signal.throwIfAborted(),h)return{data:new Uint8Array(h.data),cacheControl:h.cacheControl,expires:h.expires};if(d.tileType===1){if(this.errorOnMissingTile)throw new Error(\"Tile not found.\");return{data:new Uint8Array}}return{data:null}}),\"tilev4\");this.tile=W(this.tilev4);this.tiles=new Map,this.metadata=(t==null?void 0:t.metadata)||!1,this.errorOnMissingTile=(t==null?void 0:t.errorOnMissingTile)||!1}add(t){this.tiles.set(t.source.getKey(),t)}get(t){return this.tiles.get(t)}};l(E,\"Protocol\");var S=E;function b(o,t){return(t>>>0)*4294967296+(o>>>0)}l(b,\"toNum\");function N(o,t){let e=t.buf,r=e[t.pos++],n=(r&112)>>4;if(r<128||(r=e[t.pos++],n|=(r&127)<<3,r<128)||(r=e[t.pos++],n|=(r&127)<<10,r<128)||(r=e[t.pos++],n|=(r&127)<<17,r<128)||(r=e[t.pos++],n|=(r&127)<<24,r<128)||(r=e[t.pos++],n|=(r&1)<<31,r<128))return b(o,n);throw new Error(\"Expected varint not more than 10 bytes\")}l(N,\"readVarintRemainder\");function x(o){let t=o.buf,e=t[o.pos++],r=e&127;return e<128||(e=t[o.pos++],r|=(e&127)<<7,e<128)||(e=t[o.pos++],r|=(e&127)<<14,e<128)||(e=t[o.pos++],r|=(e&127)<<21,e<128)?r:(e=t[o.pos],r|=(e&15)<<28,N(r,o))}l(x,\"readVarint\");function k(o,t,e,r,n){return n===0?r!==0?[o-1-e,o-1-t]:[e,t]:[t,e]}l(k,\"rotate\");function q(o,t,e){if(o>26)throw new Error(\"Tile zoom level exceeds max safe number limit (26)\");if(t>=1<<o||e>=1<<o)throw new Error(\"tile x/y outside zoom level bounds\");let r=((1<<o)*(1<<o)-1)/3,n=o-1,[s,i]=[t,e];for(let a=1<<n;a>0;a>>=1){let c=s&a,u=i&a;r+=(3*c^u)*(1<<n),[s,i]=k(a,s,i,c,u),n--}return r}l(q,\"zxyToTileId\");function G(o){let t=3*o+1;return t<4294967296?31-Math.clz32(t):63-Math.clz32(t/4294967296)}l(G,\"tileIdToZ\");function ie(o){let t=G(o)>>1;if(t>26)throw new Error(\"Tile zoom level exceeds max safe number limit (26)\");let e=((1<<t)*(1<<t)-1)/3,r=o-e,n=0,s=0,i=1<<t;for(let a=1;a<i;a<<=1){let c=a&r/2,u=a&(r^c);[n,s]=k(a,n,s,c,u),r=r/2,n+=c,s+=u}return[t,n,s]}l(ie,\"tileIdToZxy\");var J=(s=>(s[s.Unknown=0]=\"Unknown\",s[s.None=1]=\"None\",s[s.Gzip=2]=\"Gzip\",s[s.Brotli=3]=\"Brotli\",s[s.Zstd=4]=\"Zstd\",s))(J||{});function D(o,t){return m(this,null,function*(){if(t===1||t===0)return o;if(t===2){if(typeof globalThis.DecompressionStream==\"undefined\")return F(new Uint8Array(o));let e=new Response(o).body;if(!e)throw new Error(\"Failed to read response stream\");let r=e.pipeThrough(new globalThis.DecompressionStream(\"gzip\"));return new Response(r).arrayBuffer()}throw new Error(\"Compression method not supported\")})}l(D,\"defaultDecompress\");var O=(a=>(a[a.Unknown=0]=\"Unknown\",a[a.Mvt=1]=\"Mvt\",a[a.Png=2]=\"Png\",a[a.Jpeg=3]=\"Jpeg\",a[a.Webp=4]=\"Webp\",a[a.Avif=5]=\"Avif\",a[a.Mlt=6]=\"Mlt\",a))(O||{});function _(o){return o===1?\".mvt\":o===2?\".png\":o===3?\".jpg\":o===4?\".webp\":o===5?\".avif\":o===6?\".mlt\":\"\"}l(_,\"tileTypeExt\");var Y=127;function Q(o,t){let e=0,r=o.length-1;for(;e<=r;){let n=r+e>>1,s=t-o[n].tileId;if(s>0)e=n+1;else if(s<0)r=n-1;else return o[n]}return r>=0&&(o[r].runLength===0||t-o[r].tileId<o[r].runLength)?o[r]:null}l(Q,\"findTile\");var A=class A{constructor(t){this.file=t}getKey(){return this.file.name}getBytes(t,e){return m(this,null,function*(){return{data:yield this.file.slice(t,t+e).arrayBuffer()}})}};l(A,\"FileSource\");var V=A,C=class C{constructor(t,e=new Headers){var i,a;this.url=t,this.customHeaders=e,this.mustReload=!1;let r=\"\";\"navigator\"in globalThis&&(r=(a=(i=globalThis.navigator)==null?void 0:i.userAgent)!=null?a:\"\");let n=r.indexOf(\"Windows\")>-1,s=/Chrome|Chromium|Edg|OPR|Brave/.test(r);this.chromeWindowsNoCache=!1,n&&s&&(this.chromeWindowsNoCache=!0)}getKey(){return this.url}setHeaders(t){this.customHeaders=t}getBytes(t,e,r,n){return m(this,null,function*(){let s,i;r?i=r:(s=new AbortController,i=s.signal);let a=new Headers(this.customHeaders);a.set(\"range\",`bytes=${t}-${t+e-1}`);let c;this.mustReload?c=\"reload\":this.chromeWindowsNoCache&&(c=\"no-store\");let u=yield fetch(this.url,{signal:i,cache:c,headers:a});if(t===0&&u.status===416){let y=u.headers.get(\"Content-Range\");if(!y||!y.startsWith(\"bytes */\"))throw new Error(\"Missing content-length on 416 response\");let f=+y.substr(8);u=yield fetch(this.url,{signal:i,cache:\"reload\",headers:{range:`bytes=0-${f-1}`}})}let d=u.headers.get(\"Etag\");if(d!=null&&d.startsWith(\"W/\")&&(d=null),u.status===416||n&&d&&d!==n)throw this.mustReload=!0,new v(`Server returned non-matching ETag ${n} after one retry. Check browser extensions and servers for issues that may affect correct ETag headers.`);if(u.status>=300)throw new Error(`Bad response code: ${u.status}`);let h=u.headers.get(\"Content-Length\");if(u.status===200&&(!h||+h>e))throw s&&s.abort(),new Error(\"Server returned no content-length header or content-length exceeding request. Check that your storage backend supports HTTP Byte Serving.\");return{data:yield u.arrayBuffer(),etag:d||void 0,cacheControl:u.headers.get(\"Cache-Control\")||void 0,expires:u.headers.get(\"Expires\")||void 0}})}};l(C,\"FetchSource\");var T=C;function g(o,t){let e=o.getUint32(t+4,!0),r=o.getUint32(t+0,!0);return e*B(2,32)+r}l(g,\"getUint64\");function X(o,t){let e=new DataView(o),r=e.getUint8(7);if(r>3)throw new Error(`Archive is spec version ${r} but this library supports up to spec version 3`);return{specVersion:r,rootDirectoryOffset:g(e,8),rootDirectoryLength:g(e,16),jsonMetadataOffset:g(e,24),jsonMetadataLength:g(e,32),leafDirectoryOffset:g(e,40),leafDirectoryLength:g(e,48),tileDataOffset:g(e,56),tileDataLength:g(e,64),numAddressedTiles:g(e,72),numTileEntries:g(e,80),numTileContents:g(e,88),clustered:e.getUint8(96)===1,internalCompression:e.getUint8(97),tileCompression:e.getUint8(98),tileType:e.getUint8(99),minZoom:e.getUint8(100),maxZoom:e.getUint8(101),minLon:e.getInt32(102,!0)/1e7,minLat:e.getInt32(106,!0)/1e7,maxLon:e.getInt32(110,!0)/1e7,maxLat:e.getInt32(114,!0)/1e7,centerZoom:e.getUint8(118),centerLon:e.getInt32(119,!0)/1e7,centerLat:e.getInt32(123,!0)/1e7,etag:t}}l(X,\"bytesToHeader\");function Z(o){let t={buf:new Uint8Array(o),pos:0},e=x(t),r=[],n=0;for(let s=0;s<e;s++){let i=x(t);r.push({tileId:n+i,offset:0,length:0,runLength:1}),n+=i}for(let s=0;s<e;s++)r[s].runLength=x(t);for(let s=0;s<e;s++)r[s].length=x(t);for(let s=0;s<e;s++){let i=x(t);i===0&&s>0?r[s].offset=r[s-1].offset+r[s-1].length:r[s].offset=i-1}return r}l(Z,\"deserializeIndex\");var U=class U extends Error{};l(U,\"EtagMismatch\");var v=U;function I(o,t){return m(this,null,function*(){let e=yield o.getBytes(0,16384);if(new DataView(e.data).getUint16(0,!0)!==19792)throw new Error(\"Wrong magic number for PMTiles archive\");let n=e.data.slice(0,Y),s=X(n,e.etag),i=e.data.slice(s.rootDirectoryOffset,s.rootDirectoryOffset+s.rootDirectoryLength),a=`${o.getKey()}|${s.etag||\"\"}|${s.rootDirectoryOffset}|${s.rootDirectoryLength}`,c=Z(yield t(i,s.internalCompression));return[s,[a,c.length,c]]})}l(I,\"getHeaderAndRoot\");function K(o,t,e,r,n){return m(this,null,function*(){let s=yield o.getBytes(e,r,void 0,n.etag),i=yield t(s.data,n.internalCompression),a=Z(i);if(a.length===0)throw new Error(\"Empty directory is invalid\");return a})}l(K,\"getDirectory\");var R=class R{constructor(t=100,e=!0,r=D){this.cache=new Map,this.maxCacheEntries=t,this.counter=1,this.decompress=r}getHeader(t){return m(this,null,function*(){let e=t.getKey(),r=this.cache.get(e);if(r)return r.lastUsed=this.counter++,r.data;let n=yield I(t,this.decompress);return n[1]&&this.cache.set(n[1][0],{lastUsed:this.counter++,data:n[1][2]}),this.cache.set(e,{lastUsed:this.counter++,data:n[0]}),this.prune(),n[0]})}getDirectory(t,e,r,n){return m(this,null,function*(){let s=`${t.getKey()}|${n.etag||\"\"}|${e}|${r}`,i=this.cache.get(s);if(i)return i.lastUsed=this.counter++,i.data;let a=yield K(t,this.decompress,e,r,n);return this.cache.set(s,{lastUsed:this.counter++,data:a}),this.prune(),a})}prune(){if(this.cache.size>this.maxCacheEntries){let t=1/0,e;this.cache.forEach((r,n)=>{r.lastUsed<t&&(t=r.lastUsed,e=n)}),e&&this.cache.delete(e)}}invalidate(t){return m(this,null,function*(){this.cache.delete(t.getKey())})}};l(R,\"ResolvedValueCache\");var $=R,M=class M{constructor(t=100,e=!0,r=D){this.cache=new Map,this.invalidations=new Map,this.maxCacheEntries=t,this.counter=1,this.decompress=r}getHeader(t){return m(this,null,function*(){let e=t.getKey(),r=this.cache.get(e);if(r)return r.lastUsed=this.counter++,yield r.data;let n=new Promise((s,i)=>{I(t,this.decompress).then(a=>{a[1]&&this.cache.set(a[1][0],{lastUsed:this.counter++,data:Promise.resolve(a[1][2])}),s(a[0]),this.prune()}).catch(a=>{i(a)})});return this.cache.set(e,{lastUsed:this.counter++,data:n}),n})}getDirectory(t,e,r,n){return m(this,null,function*(){let s=`${t.getKey()}|${n.etag||\"\"}|${e}|${r}`,i=this.cache.get(s);if(i)return i.lastUsed=this.counter++,yield i.data;let a=new Promise((c,u)=>{K(t,this.decompress,e,r,n).then(d=>{c(d),this.prune()}).catch(d=>{u(d)})});return this.cache.set(s,{lastUsed:this.counter++,data:a}),a})}prune(){if(this.cache.size>=this.maxCacheEntries){let t=1/0,e;this.cache.forEach((r,n)=>{r.lastUsed<t&&(t=r.lastUsed,e=n)}),e&&this.cache.delete(e)}}invalidate(t){return m(this,null,function*(){let e=t.getKey();if(this.invalidations.get(e))return yield this.invalidations.get(e);this.cache.delete(t.getKey());let r=new Promise((n,s)=>{this.getHeader(t).then(i=>{n(),this.invalidations.delete(e)}).catch(i=>{s(i)})});this.invalidations.set(e,r)})}};l(M,\"SharedPromiseCache\");var P=M,H=class H{constructor(t,e,r){typeof t==\"string\"?this.source=new T(t):this.source=t,r?this.decompress=r:this.decompress=D,e?this.cache=e:this.cache=new P}getHeader(){return m(this,null,function*(){return yield this.cache.getHeader(this.source)})}getZxyAttempt(t,e,r,n){return m(this,null,function*(){let s=q(t,e,r),i=yield this.cache.getHeader(this.source);if(t<i.minZoom||t>i.maxZoom)return;let a=i.rootDirectoryOffset,c=i.rootDirectoryLength;for(let u=0;u<=3;u++){let d=yield this.cache.getDirectory(this.source,a,c,i),h=Q(d,s);if(h){if(h.runLength>0){let p=yield this.source.getBytes(i.tileDataOffset+h.offset,h.length,n,i.etag);return{data:yield this.decompress(p.data,i.tileCompression),cacheControl:p.cacheControl,expires:p.expires}}a=i.leafDirectoryOffset+h.offset,c=h.length}else return}throw new Error(\"Maximum directory depth exceeded\")})}getZxy(t,e,r,n){return m(this,null,function*(){try{return yield this.getZxyAttempt(t,e,r,n)}catch(s){if(s instanceof v)return this.cache.invalidate(this.source),yield this.getZxyAttempt(t,e,r,n);throw s}})}getMetadataAttempt(){return m(this,null,function*(){let t=yield this.cache.getHeader(this.source),e=yield this.source.getBytes(t.jsonMetadataOffset,t.jsonMetadataLength,void 0,t.etag),r=yield this.decompress(e.data,t.internalCompression),n=new TextDecoder(\"utf-8\");return JSON.parse(n.decode(r))})}getMetadata(){return m(this,null,function*(){try{return yield this.getMetadataAttempt()}catch(t){if(t instanceof v)return this.cache.invalidate(this.source),yield this.getMetadataAttempt();throw t}})}getTileJson(t){return m(this,null,function*(){let e=yield this.getHeader(),r=yield this.getMetadata(),n=_(e.tileType);return{tilejson:\"3.0.0\",scheme:\"xyz\",tiles:[`${t}/{z}/{x}/{y}${n}`],vector_layers:r.vector_layers,attribution:r.attribution,description:r.description,name:r.name,version:r.version,bounds:[e.minLon,e.minLat,e.maxLon,e.maxLat],center:[e.centerLon,e.centerLat,e.centerZoom],minzoom:e.minZoom,maxzoom:e.maxZoom}})}};l(H,\"PMTiles\");var w=H;export{J as Compression,v as EtagMismatch,T as FetchSource,V as FileSource,w as PMTiles,S as Protocol,$ as ResolvedValueCache,P as SharedPromiseCache,O as TileType,X as bytesToHeader,Q as findTile,g as getUint64,re as leafletRasterLayer,x as readVarint,ie as tileIdToZxy,_ as tileTypeExt,q as zxyToTileId};\n//# sourceMappingURL=index.js.map","var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/index.ts\nimport {\n  default as DataTileSource\n} from \"ol/source/DataTile.js\";\nimport TileState from \"ol/TileState.js\";\nimport { MVT } from \"ol/format.js\";\nimport {\n  default as VectorTileSource\n} from \"ol/source/VectorTile.js\";\nimport { createXYZ, extentFromProjection } from \"ol/tilegrid.js\";\nimport { PMTiles } from \"pmtiles\";\nvar _PMTilesRasterSource = class _PMTilesRasterSource extends DataTileSource {\n  constructor(options) {\n    super(__spreadValues(__spreadValues({}, options), {\n      state: \"loading\"\n    }));\n    this.loadImage = /* @__PURE__ */ __name((src) => {\n      return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.addEventListener(\"load\", () => resolve(img));\n        img.addEventListener(\"error\", () => reject(new Error(\"load failed\")));\n        img.src = src;\n      });\n    }, \"loadImage\");\n    const p = new PMTiles(options.url);\n    p.getHeader().then((h) => {\n      const projection = options.projection === void 0 ? \"EPSG:3857\" : options.projection;\n      this.tileGrid = options.tileGrid || createXYZ({\n        extent: extentFromProjection(projection),\n        maxResolution: options.maxResolution,\n        minZoom: h.minZoom,\n        maxZoom: h.maxZoom,\n        tileSize: options.tileSize\n      });\n      this.setLoader((z, x, y) => __async(this, null, function* () {\n        const response = yield p.getZxy(z, x, y);\n        if (!response) {\n          return new Uint8Array();\n        }\n        const src = URL.createObjectURL(new Blob([response.data]));\n        const image = yield this.loadImage(src);\n        URL.revokeObjectURL(src);\n        return image;\n      }));\n      this.setState(\"ready\");\n    });\n  }\n};\n__name(_PMTilesRasterSource, \"PMTilesRasterSource\");\nvar PMTilesRasterSource = _PMTilesRasterSource;\nvar _PMTilesVectorSource = class _PMTilesVectorSource extends VectorTileSource {\n  constructor(options) {\n    super(__spreadValues(__spreadValues({}, options), {\n      state: \"loading\",\n      url: \"pmtiles://{z}/{x}/{y}\",\n      format: options.format || new MVT()\n    }));\n    this.tileLoadFunction = /* @__PURE__ */ __name((tile, url) => {\n      const vtile = tile;\n      const re = new RegExp(/pmtiles:\\/\\/(\\d+)\\/(\\d+)\\/(\\d+)/);\n      const result = url.match(re);\n      if (!(result && result.length >= 4)) {\n        throw Error(\"Could not parse tile URL\");\n      }\n      const z = +result[1];\n      const x = +result[2];\n      const y = +result[3];\n      vtile.setLoader(\n        (extent, resolution, projection) => {\n          this.pmtiles_.getZxy(z, x, y).then((tile_result) => {\n            if (tile_result) {\n              const format = vtile.getFormat();\n              vtile.setFeatures(\n                format.readFeatures(tile_result.data, {\n                  extent,\n                  featureProjection: projection\n                })\n              );\n              vtile.setState(TileState.LOADED);\n            } else {\n              vtile.setFeatures([]);\n              vtile.setState(TileState.EMPTY);\n            }\n          }).catch((err) => {\n            vtile.setFeatures([]);\n            vtile.setState(TileState.ERROR);\n          });\n        }\n      );\n    }, \"tileLoadFunction\");\n    this.pmtiles_ = new PMTiles(options.url);\n    this.pmtiles_.getHeader().then((h) => {\n      const projection = options.projection || \"EPSG:3857\";\n      const extent = options.extent || extentFromProjection(projection);\n      this.tileGrid = options.tileGrid || createXYZ({\n        extent,\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom !== void 0 ? options.maxZoom : h.maxZoom,\n        minZoom: h.minZoom,\n        tileSize: options.tileSize || 512\n      });\n      this.setTileLoadFunction(this.tileLoadFunction);\n      this.setState(\"ready\");\n    });\n  }\n};\n__name(_PMTilesVectorSource, \"PMTilesVectorSource\");\nvar PMTilesVectorSource = _PMTilesVectorSource;\nexport {\n  PMTilesRasterSource,\n  PMTilesVectorSource\n};\n//# sourceMappingURL=index.js.map","/**\n * Checks whether a variable is a string and contains at least one character.\n * \n * @param {*} string - A variable to check.\n * @returns {boolean} - `true` is the given variable is a string with length > 0, `false` otherwise.\n */\nexport function hasText(string) {\n  return (typeof string === 'string' && string.length > 0);\n}\n\n/**\n * Ensures a number is between a minimum and maximum value, but with a delta.\n * \n * @param {number} num The number to check.\n * @param {number} min The minimum value.\n * @param {number} max The maximum value.\n * @param {number} delta The delta that the number is allowed to be larger or smaller.\n * @returns {number|null}\n */\nexport function ensureNumber(num, min, max, delta = 0.00000001) {\n  if (typeof num !== 'number') {\n    return null;\n  }\n  const min2 = min - delta;\n  const max2 = max + delta;\n  if (num < min2 || num > max2) {\n    return null;\n  }\n\n  return Math.min(Math.max(num, min), max);\n}\n\n/**\n * Checks whether a variable is a real object or not.\n * \n * This is a more strict version of `typeof x === 'object'` as this example would also succeed for arrays and `null`.\n * This function only returns `true` for real objects and not for arrays, `null` or any other data types.\n * \n * @param {*} obj - A variable to check.\n * @returns {boolean} - `true` is the given variable is an object, `false` otherwise.\n */\nexport function isObject(obj) {\n  return (typeof obj === 'object' && obj === Object(obj) && !Array.isArray(obj));\n}\n\n/**\n * Merges any number of arrays of objects.\n * \n * @param  {...Array.<Object>} bands \n * @returns {Array.<Object>}\n */\nexport function mergeArraysOfObjects(...bands) {\n  bands = bands.filter(arr => Array.isArray(arr));\n  if (bands.length > 1) {\n    let length = Math.max(...bands.map(arr => arr.length));\n    let merged = [];\n    for(let i = 0; i < length; i++) {\n      merged.push(Object.assign({}, ...bands.map(band => band[i])));\n    }\n    return merged;\n  }\n  else if (bands.length === 1) {\n    return bands[0];\n  }\n  return [];\n}\n\n/**\n * Get minimum values for the STAC data types.\n * \n * Currently only supports int types.\n * \n * @private\n * @todo Add float support\n * @param {string} str Data type\n * @returns {number|null} Minimum value\n */\nexport function getMinForDataType(str) {\n  switch(str) {\n    case \"int8\":\n      return -128;\n    case \"int16\":\n      return -32768;\n    case \"int32\":\n      return -2147483648;\n  }\n  if (str.startsWith(\"u\")) {\n    return 0;\n  }\n  return null;\n}\n\n/**\n * Get maximum values for the STAC data types.\n * \n * Currently only supports int types.\n * \n * @private\n * @todo Add float support\n * @param {string} str Data type\n * @returns {number|null} Maximum value\n */\nexport function getMaxForDataType(str) {\n  switch(str) {\n    case \"int8\":\n      return 127;\n    case \"uint8\":\n      return 255;\n    case \"int16\":\n      return 32767;\n    case \"uint16\":\n      return 65535;\n    case \"int32\":\n      return 2147483647;\n    case \"uint32\":\n      return 4294967295;\n  }\n  return null;\n}\n\n\n/**\n * Gets the reported minimum and maximum values for a STAC object.\n * \n * Searches through different extension fields in raster, classification, and file.\n * \n * @param {StacObject} object \n * @returns {Statistics}\n */\nexport function getMinMaxValues(object) {\n  /**\n   * Statistics\n   * \n   * @typedef {Object} Statistics\n   * @property {number|null} minimum Minimum value\n   * @property {number|null} maximum Maximum value\n   */\n  const stats = {\n    minimum: null,\n    maximum: null\n  };\n\n  // Checks whether the stats object is completely filled\n  const isComplete = obj => obj.minimum !== null && obj.maximum !== null;\n\n  // data sources: raster (statistics, histogram, data_type), classification, file (values, data_type)\n  const statistics = object.getMetadata(\"statistics\");\n  if (isObject(statistics)) {\n    if (typeof statistics.minimum === 'number') {\n      stats.minimum = statistics.minimum;\n    }\n    if (typeof statistics.maximum === 'number') {\n      stats.maximum = statistics.maximum;\n    }\n    if (isComplete(stats)) {\n      return stats;\n    }\n  }\n\n  const histogram = object.getMetadata(\"raster:histogram\");\n  if (isObject(histogram)) {\n    if (typeof histogram.min === 'number') {\n      stats.minimum = histogram.min;\n    }\n    if (typeof histogram.max === 'number') {\n      stats.maximum = histogram.max;\n    }\n    if (isComplete(stats)) {\n      return stats;\n    }\n  }\n\n  const classification = object.getMetadata(\"classification:classes\");\n  if (Array.isArray(classification)) {\n    classification.reduce((obj, cls) => {\n      obj.minimum = Math.min(obj.minimum, cls.value);\n      obj.maximum = Math.max(obj.maximum, cls.value);\n      return obj;\n    }, stats);\n    if (isComplete(stats)) {\n      return stats;\n    }\n  }\n\n  const values = object.getMetadata(\"file:values\");\n  if (Array.isArray(values)) {\n    values.reduce((obj, map) => {\n      obj.minimum = Math.min(obj.minimum, ...map.values);\n      obj.maximum = Math.max(obj.maximum, ...map.values);\n      return obj;\n    }, stats);\n    if (isComplete(stats)) {\n      return stats;\n    }\n  }\n\n  const data_type = object.getMetadata(\"data_type\");\n  if (data_type) {\n    stats.minimum = getMinForDataType(data_type);\n    stats.maximum = getMaxForDataType(data_type);\n  }\n\n  return stats;\n}\n\n/**\n * Gets the reported no-data values for a STAC Object.\n * \n * Searches through different extension fields in nodata, classification, and file.\n * \n * @param {StacObject} object \n * @returns {Array.<*>}\n */\nexport function getNoDataValues(object) {\n  // data sources: raster (nodata), classification (nodata flag), file (nodata)\n  let nodata = [];\n  const common = object.getMetadata(\"nodata\");\n  if (typeof common !== 'undefined') {\n    nodata.push(common);\n  }\n  else {\n    const file = object.getMetadata(\"file:nodata\");\n    if (typeof file !== 'undefined') {\n      nodata = file;\n    }\n    else {\n      const classification = object.getMetadata(\"classification:classes\");\n      if (Array.isArray(classification)) {\n        nodata = classification\n          .filter(cls => Boolean(cls.nodata))\n          .map(cls => cls.value);\n      }\n    }\n  }\n\n  return nodata.map(value => {\n    if (value === \"nan\") {\n      return NaN;\n    }\n    else if (value === \"+inf\") {\n      return +Infinity;\n    }\n    else if (value === \"-inf\") {\n      return -Infinity;\n    }\n    else {\n      return value;\n    }\n  });\n}\n","import { ensureNumber, isObject } from \"./utils.js\";\n\nfunction toObject(bbox) {\n  let hasZ = bbox.length >= 6;\n  let west = bbox[0];\n  let east = bbox[hasZ ? 3 : 2];\n  let south = bbox[1];\n  let north = bbox[hasZ ? 4 : 3];\n  let obj = { west, east, south, north };\n  if (hasZ) {\n    obj.base = bbox[2];\n    obj.height = bbox[5];\n  }\n  return obj;\n}\n\nfunction bboxToCoords(bbox) {\n  let { west, east, south, north } = toObject(bbox);\n  return [\n    [\n      [west, north],\n      [west, south],\n      [east, south],\n      [east, north],\n      [west, north]\n    ]\n  ];\n}\n\n/**\n * Returns the center of the STAC entity.\n * \n * @param {BoundingBox|null} bbox \n * @returns {Point|null}\n */\nexport function centerOfBoundingBox(bbox) {\n  bbox = ensureBoundingBox(bbox, true);\n  if (!bbox) {\n    return null;\n  }\n  let obj = toObject(bbox);\n  let point = [];\n  // todo: implement also for bboxes that cross the boundaries at the poles\n  if (isAntimeridianBoundingBox(bbox)) {\n    let x = (obj.west + 360 + obj.east) / 2;\n    if (x > 180) {\n      x -= 360;\n    }\n    point.push(x);\n  }\n  else {\n    point.push((obj.west + obj.east) / 2);\n  }\n  point.push((obj.south + obj.north) / 2); // y\n  if (typeof obj.base !== 'undefined') {\n    point.push((obj.base + obj.height) / 2); // z\n  }\n  return point;\n}\n\nfunction fixGeoJsonGoordinates(coords) {\n  if (Array.isArray(coords[0])) {\n    // Handle nested coordinates (e.g., MultiPolygons, LineStrings)\n    return coords.map(fixGeoJsonGoordinates);\n  }\n  // Fix individual coordinate [longitude, latitude]\n  const [lon, lat] = coords;\n  return [ensureNumber(lon, -180, 180), ensureNumber(lat, -90, 90)];\n}\n\n/**\n * Fix coordinates in a GeoJSON object to be within the CRS range.\n * \n * Function works in-place.\n * \n * @param {Object} geojson - The GeoJSON object to be checked.\n * @returns {Object} The fixed GeoJSON object.\n */\nexport function fixGeoJson(geojson) {\n  if (!isObject(geojson)) {\n    return geojson;\n  }\n  if (geojson.bbox) {\n    geojson.bbox = ensureBoundingBox(geojson.bbox);\n  }\n  if (geojson.type === \"FeatureCollection\") {\n    geojson.features.forEach((feature) => fixGeoJson(feature));\n  }\n  else if (geojson.type === \"Feature\") {\n    geojson.geometry = fixGeoJson(geojson.geometry);\n  }\n  else if (geojson.type === \"GeometryCollection\") {\n    geojson.geometries.forEach((geometry) => fixGeoJson(geometry));\n  }\n  else if (geojson.coordinates) {\n    geojson.coordinates = fixGeoJsonGoordinates(geojson.coordinates);\n  }\n  return geojson;\n}\n\n/**\n * Converts one or more bounding boxes to a GeoJSON Feature.\n * \n * The Feature contains a Polygon or MultiPolygon based on the given number of valid bounding boxes.\n * \n * @param {BoundingBox|Array.<BoundingBox>} bboxes \n * @returns {Object|null}\n */\nexport function toGeoJSON(bboxes) {\n  if (bboxes.every(c => typeof c === 'number')) {\n    // Wrap a single bounding box into an array\n    bboxes = [bboxes];\n  }\n\n  bboxes = bboxes\n    .map(bbox => ensureBoundingBox(bbox))\n    // Remove invalid bounding boxes\n    .filter(bbox => bbox !== null);\n\n  // Return if no valid bbox is given\n  if (!Array.isArray(bboxes) || bboxes.length === 0) {\n    return null;\n  }\n\n  let coordinates = bboxes.reduce((list, bbox) => {\n    // todo: implement also for bboxes that cross the boundaries at the poles\n    // see https://github.com/DanielJDufour/bbox-fns/blob/main/split.js\n    if (isAntimeridianBoundingBox(bbox)) {\n      let { west, east, south, north } = toObject(bbox);\n      list.push(bboxToCoords([-180, south, east, north]));\n      list.push(bboxToCoords([west, south, 180, north]));\n    }\n    else {\n      list.push(bboxToCoords(bbox));\n    }\n    return list;\n  }, []);\n\n  let geometry = null;\n  if (coordinates.length === 1) {\n    geometry = {\n      type: \"Polygon\",\n      coordinates: coordinates[0]\n    };\n  }\n  else if (coordinates.length > 1) {\n    geometry = {\n      type: \"MultiPolygon\",\n      coordinates\n    };\n  }\n  if (geometry) {\n    return {\n      type: \"Feature\",\n      geometry,\n      properties: {}\n    };\n  }\n}\n\n/**\n * Ensure this is a valid bounding box.\n * \n * This function will ensure that the given bounding box is valid and otherwise return `null`.\n * \n * If the bounding box is 3D, the function will return `null` unless `allow3D` is set to `true`.\n * \n * @param {BoundingBox|Array.<number>} bbox The bounding box to check.\n * @param {boolean} allow3D - Whether to allow 3D bounding boxes or not.\n * @returns {BoundingBox|null}\n */\nexport function ensureBoundingBox(bbox, allow3D = false) {\n  if (!Array.isArray(bbox) || ![4,6].includes(bbox.length)) {\n    return null;\n  }\n\n  let { west, east, south, north, base, height } = toObject(bbox);\n  // Some bounding boxes are slightly too large (due to floating point errors).\n  // So you may get 90.00000001 instead of 90. To avoid this, we allow for a small delta.\n  west = ensureNumber(west, -180, 180);\n  south = ensureNumber(south, -90, 90);\n  east = ensureNumber(east, -180, 180);\n  north = ensureNumber(north, -90, 90);\n  if (allow3D && bbox.length === 6) {\n    bbox = [west, south, base, east, north, height];\n  }\n  else {\n    bbox = [west, south, east, north];\n  }\n  if (bbox.some(n => n === null)) {\n    return null;\n  }\n  return bbox;\n}\n\n/**\n * Checks whether the given bounding box crosses the antimeridian.\n * \n * @param {BoundingBox} bbox \n * @returns {boolean}\n */\nexport function isAntimeridianBoundingBox(bbox) {\n  bbox = ensureBoundingBox(bbox);\n  if (!bbox) {\n    return false;\n  }\n  \n  let { west, east } = toObject(bbox);\n  return west > east;\n}\n\n/**\n * Compute the union of a list of bounding boxes.\n * \n * The function ignores any invalid bounding boxes or values for the third dimension.\n * \n * @param {Array.<BoundingBox|null>} bboxes \n * @returns {BoundingBox|null}\n * @see {ensureBoundingBox}\n */\nexport function unionBoundingBox(bboxes) {\n  if (!Array.isArray(bboxes) || bboxes.length === 0) {\n    return null;\n  }\n\n  const extrema = {\n    west: null,\n    south: null,\n    east: null,\n    north: null,\n  };\n  const min = ['west', 'south'];\n  for(let bbox of bboxes) {\n    bbox = ensureBoundingBox(bbox);\n    if (!bbox) {\n      continue;\n    }\n    const obj = toObject(bbox);\n    for(const key in obj) {\n      if (extrema[key] === null) {\n        extrema[key] = obj[key];\n      }\n      else {\n        const fn = min.includes(key) ? Math.min : Math.max;\n        extrema[key] = fn(extrema[key], obj[key]);\n      }\n    }\n  }\n\n  let bbox = [extrema.west, extrema.south, extrema.east, extrema.north];\n  return ensureBoundingBox(bbox);\n}\n","import { centerOfBoundingBox } from './geo.js';\nimport { isObject } from './utils.js';\n\n/**\n * Base class for STAC objects.\n * \n * Don't instantiate this class!\n * \n * @interface\n * @param {Object} data The STAC object\n * @param {Object.<string, function>} keyMap Keys and functions that convert the values to stac-js objects.\n * @param {Array.<string>} privateKeys Keys that are private members of the stac-js objects (for cloning and export).\n */\nclass STACObject {\n\n  constructor(data, keyMap = {}, privateKeys = []) {\n    if (!isObject(data)) {\n      throw new Error('Given data is not an object');\n    }\n\n    if (data instanceof STACObject) {\n      for(let key of privateKeys) {\n        this[key] = data[key];\n      }\n      data = data.toJSON();\n    }\n\n    // Map with functions that convert properties to stac-js objects\n    this._keyMap = keyMap;\n    // Array with keys that are used internally and should be cloned\n    this._privateKeys = ['_keyMap', '_privateKeys'].concat(privateKeys);\n\n    // Assign the data to the object\n    for (let key in data) {\n      if (typeof this[key] === 'undefined') {\n        if (key in keyMap) {\n          this[key] = keyMap[key](data[key], this);\n        }\n        else {\n          this[key] = data[key];\n        }\n      }\n    }\n  }\n\n  /**\n   * Check whether this given object is a STAC Item.\n   * \n   * @returns {boolean} `true` if the object is a STAC Item, `false` otherwise.\n   */\n  isItem() {\n    return this.type === 'Feature';\n  }\n\n  /**\n   * Check whether this given object is a STAC Catalog.\n   * \n   * @returns {boolean} `true` if the object is a STAC Catalog, `false` otherwise.\n   */\n  isCatalog() {\n    return this.type === 'Catalog';\n  }\n\n  /**\n   * Check whether this given object is \"catalog-like\", i.e. a Catalog or Collection.\n   * \n   * @returns {boolean} `true` if the object is a \"catalog-like\", `false` otherwise.\n   */\n  isCatalogLike() {\n    return this.isCatalog() || this.isCollection();\n  }\n\n  /**\n   * Check whether this given object is a STAC Collection.\n   * \n   * @returns {boolean} `true` if the object is a STAC Collection, `false` otherwise.\n   */\n  isCollection() {\n    return this.type === 'Collection';\n  }\n\n  /**\n   * Check whether this given object is a STAC ItemCollection.\n   * \n   * @returns {boolean} `true` if the object is a STAC ItemCollection, `false` otherwise.\n   */\n  isItemCollection() {\n    return this.type === 'FeatureCollection';\n  }\n\n  /**\n   * Check whether this given object is a STAC Collection of Collections (i.e. API Collections).\n   * \n   * @returns {boolean} `true` if the object is a STAC CollectionCollection, `false` otherwise.\n   */\n  isCollectionCollection() {\n    return false;\n  }\n\n  /**\n   * Check whether this given object is a STAC Asset.\n   * \n   * @returns {boolean} `true` if the object is a STAC Asset, `false` otherwise.\n   */\n  isAsset() {\n    return false;\n  }\n\n  /**\n   * Check whether this given object is a STAC Link.\n   * \n   * @returns {boolean} `true` if the object is a STAC Link, `false` otherwise.\n   */\n  isLink() {\n    return false;\n  }\n\n  /**\n   * Check whether this given object is a STAC Band.\n   * \n   * @returns {boolean} `true` if the object is a STAC Band, `false` otherwise.\n   */\n  isBand() {\n    return false;\n  }\n\n  /**\n   * Returns the type of the STAC object.\n   * \n   * One of:\n   * - Asset\n   * - Catalog\n   * - Collection\n   * - CollectionCollection\n   * - Item\n   * - ItemCollection\n   * - Link\n   * - Band\n   * @abstract\n   * @returns {string}\n   */\n  getObjectType() {\n    return;\n  }\n\n  /**\n   * Gets the absolute URL of the STAC entity (if provided explicitly or available from the self link).\n   * \n   * @param {boolean} stringify If `true` (default), a string is returned, otherwise a URI object.\n   * @returns {string|null} Absolute URL\n   */\n  getAbsoluteUrl(stringify = true) { // eslint-disable-line no-unused-vars\n    return null;\n  }\n\n  /**\n   * Returns the metadata for the STAC entity.\n   * \n   * @param {string} field Field name\n   * @returns {*}\n   */\n  getMetadata(field) {\n    return this[field];\n  }\n\n  /**\n   * Returns a GeoJSON Feature or FeatureCollection for this STAC object.\n   * \n   * @returns {Object|null} GeoJSON object or `null`\n   */\n  toGeoJSON() {\n    return null;\n  }\n\n  /**\n   * Returns a single bounding box for the STAC entity.\n   * \n   * @returns {BoundingBox|null}\n   */\n  getBoundingBox() {\n    return null;\n  }\n\n  /**\n   * Returns the center of the STAC entity.\n   * \n   * @returns {BoundingBox|null}\n   */\n  getCenter() {\n    return centerOfBoundingBox(this.getBoundingBox());\n  }\n\n  /**\n   * Returns a list of bounding boxes for the STAC entity.\n   * \n   * @returns {Array.<BoundingBox>}\n   */\n  getBoundingBoxes() {\n    return [];\n  }\n\n  /**\n   * Returns a plain object for JSON export.\n   * \n   * @returns {Object} Plain object\n   */\n  toJSON() {\n    let obj = {};\n    Object.keys(this).forEach(key => {\n      if (typeof this[key] === 'function' || this._privateKeys.includes(key)) {\n        return;\n      }\n      let v = this[key];\n      if (key in this._keyMap) {\n        let v2 = Array.isArray(v) ? [] : {};\n        for(let key in v) {\n          if (typeof v[key].toJSON === 'function') {\n            v2[key] = v[key].toJSON();\n          }\n          else {\n            v2[key] = v[key];\n          }\n        }\n        v = v2;\n      }\n      obj[key] = v;\n    });\n    return obj;\n  }\n  \n}\n\nexport default STACObject;\n","import URI from 'urijs';\n\n/**\n * Protocols supported by browsers (http and https).\n * \n * @type {Array.<string>}\n */\nexport const browserProtocols = [\n  'http',\n  'https'\n];\n\n/**\n * \n * @todo\n * @param {string} href \n * @param {string} baseUrl \n * @param {boolean} stringify \n * @returns {string|URI}\n */\nexport function toAbsolute(href, baseUrl, stringify = true) {\n  return normalizeUri(href, baseUrl, false, stringify);\n}\n\n/**\n * \n * @todo\n * @param {string} href \n * @param {string|null} baseUrl \n * @param {boolean} noParams \n * @param {boolean} stringify \n * @returns {string|URI}\n */\nexport function normalizeUri(href, baseUrl = null, noParams = false, stringify = true) {\n  // Parse URL and make absolute, if required\n  let uri = URI(href);\n  if (baseUrl && uri.is(\"relative\")) { // Don't convert GDAL VFS URIs: https://github.com/radiantearth/stac-browser/issues/116\n    // Avoid that baseUrls that have a . in the last parth part will be removed (e.g. https://example.com/api/v1.0 )\n    let baseUri = URI(baseUrl);\n    let baseUriPath = baseUri.path();\n    if (!baseUriPath.endsWith('/') && !baseUriPath.endsWith('.json')) {\n      baseUri.path(baseUriPath + '/');\n    }\n    uri = uri.absoluteTo(baseUri);\n  }\n  // Normalize URL and remove trailing slash from path\n  // to avoid handling the same resource twice\n  uri.normalize();\n  if (noParams) {\n    uri.query(\"\");\n    uri.fragment(\"\");\n  }\n  return stringify ? uri.toString() : uri;\n}\n","/**\n * The GeoJSON media type.\n * \n * @type {string}\n */\nexport const geojsonMediaType = 'application/geo+json';\n\n/**\n * All STAC media types (JSON + GeoJSON).\n * \n * @type {Array.<string>}\n */\nexport const stacMediaTypes = [\n  'application/json',\n  geojsonMediaType,\n  'text/json'\n];\n\n/**\n * All image media types that Web Browsers can show (GIF, JPEG, PNG, WebP).\n * \n * @type {Array.<string>}\n */\nexport const browserImageTypes = [\n  'image/gif',\n  'image/jpeg',\n  'image/apng',\n  'image/png',\n  'image/webp'\n];\n\n/**\n * All Cloud Optimized GeoTiff media types.\n * \n * @type {Array.<string>}\n */\nexport const cogMediaTypes = [\n  'image/tiff; application=geotiff; profile=cloud-optimized',\n  'image/vnd.stac.geotiff; cloud-optimized=true'\n];\n\n/**\n * All GeoTiff media types (including COG media types).\n * \n * @type {Array.<string>}\n */\nexport const geotiffMediaTypes = [\n  'application/geotiff',\n  'image/tiff; application=geotiff',\n  'image/vnd.stac.geotiff',\n].concat(cogMediaTypes);\n\n/**\n * All image media types combined (Web Browser + GeoTiff).\n * \n * @type {Array.<string>}\n */\nexport const imageMediaTypes = browserImageTypes.concat(geotiffMediaTypes);\n\n/**\n * Checks whether a given media type is in the list of media types.\n * \n * @param {string|undefined} type The potential media type.\n * @param {string|Array.<string>} allowedTypes A list of allowed media types (or a single media type as string).\n * @param {boolean} allowUndefined If set to `true`, returns `true` if `undefined` is passed as `type`.\n * @returns {boolean} `true` if the media type is allowed, `false` otherwise.\n */\nexport function isMediaType(type, allowedTypes, allowUndefined = false) {\n  if (!Array.isArray(allowedTypes)) {\n    allowedTypes = [allowedTypes];\n  }\n  if (allowUndefined && typeof type === 'undefined') {\n    return true;\n  }\n  else if (typeof type !== 'string') {\n    return false;\n  }\n  else {\n    allowedTypes = allowedTypes.map(type => type.toLowerCase());\n    return allowedTypes.includes(type.toLowerCase());\n  }\n}\n\n/**\n * Checks whether the given media type is a STAC media type (JSON or GeoJSON).\n * \n * @param {string|undefined} type The potential media type.\n * @param {boolean} allowUndefined If set to `true`, returns `true` if `undefined` is passed as `type`.\n * @returns {boolean} `true` if the media type is a STAC media type, `false` otherwise.\n */\nexport function isStacMediaType(type, allowUndefined = false) {\n  return isMediaType(type, stacMediaTypes, allowUndefined);\n}\n","import { browserProtocols, toAbsolute } from './http.js';\nimport { cogMediaTypes, geotiffMediaTypes, isMediaType } from \"./mediatypes.js\";\nimport { hasText } from './utils.js';\nimport STACObject from './object.js';\nimport { browserImageTypes } from './mediatypes.js';\nimport URI from 'urijs';\n\n/**\n * A STAC reference as base for Assets and Links.\n * \n * Don't instantiate this class!\n * \n * @interface\n * @property {string} href\n * @property {?string} type\n * \n * @param {Object} data The STAC API Collection object\n * @param {STAC|null} context The object that contains the reference\n * @param {Object.<string, function>} keyMap Keys and functions that convert the values to stac-js objects.\n * @param {Array.<string>} privateKeys Keys that are private members of the stac-js objects (for cloning and export).\n */\nclass STACReference extends STACObject {\n\n  constructor(data, context = null, keyMap = {}, privateKeys = []) {\n    super(data, keyMap, ['_context'].concat(privateKeys));\n    if (!this._context) {\n      this._context = context;\n    }\n  }\n\n  /**\n   * Gets the URL of the reference as absolute URL.\n   * \n   * @param {boolean} stringify If `true` (default), a string is returned, otherwise a URI object.\n   * @returns {URI|string|null}\n   */\n  getAbsoluteUrl(stringify = true) {\n    if (this._context) {\n      return toAbsolute(this.href, this._context.getAbsoluteUrl(), stringify);\n    }\n    else if (this.href.includes('://')) {\n      return stringify ? this.href : URI(this.href);\n    }\n    return null;\n  }\n\n  /**\n   * Returns the STAC entity that contains the reference.\n   * \n   * @returns {STAC|null}\n   */\n  getContext() {\n    return this._context;\n  }\n\n  /**\n   * Checks whether a given reference can be displayed by a browser.\n   * \n   * A browser can usually display an image if it is a specific file format (e.g. JPEG, PNG, ...) and is served over HTTP(S).\n   * \n   * @returns {boolean} `true` if a browser can display the given reference, `false` otherwise.\n   * @see {canBrowserDisplayImage}\n   */\n  canBrowserDisplayImage(allowUndefined = false) {\n    if (typeof this.href !== 'string') {\n      return false;\n    }\n    else if (!allowUndefined && typeof this.type === 'undefined') {\n      return false;\n    }\n    let uri = this.getAbsoluteUrl(false);\n    if (!uri) {\n      uri = URI(this.href);\n    }\n    const protocol = uri.protocol().toLowerCase();\n    const extension = uri.suffix().toLowerCase();\n    if (hasText(protocol) && !browserProtocols.includes(protocol)) {\n      return false;\n    }\n    else if (hasText(this.type) && browserImageTypes.includes(this.type.toLowerCase())) {\n      return true;\n    }\n    else if (typeof this.type === 'undefined' && hasText(extension) && (extension === 'jpg' || browserImageTypes.includes('image/' + extension))) {\n      return true;\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Checks whether this entity is of a specific type.\n   * \n   * @param {string|Array.<string>} types One or more media types.\n   * @returns {boolean} `true` is this entity is one of the given types, `false` otherwise.\n   */\n  isType(types) { // string or array of strings\n    return hasText(this.type) && isMediaType(this.type, types);\n  }\n\n  /**\n   * Checks whether this entity is a GeoTiff (including COGs).\n   * \n   * @returns {boolean} `true` is this entity is a GeoTiff, `false` otherwise.\n   */\n  isGeoTIFF() {\n    return this.isType(geotiffMediaTypes);\n  }\n\n  /**\n   * Checks whether this entity is a COG (excluding pure GeoTiffs).\n   * \n   * @returns {boolean} `true` is this entity is a COG, `false` otherwise.\n   */\n  isCOG() {\n    return this.isType(cogMediaTypes);\n  }\n\n  /**\n   * Checks whether the entity is accessible via HTTP or HTTPS.\n   * \n   * Returns `null` if no URI is available, otherwise a `boolean` value.\n   * \n   * @returns {boolean|null} `true` is this entity is available via HTTP or HTTPS, `false` or `null` otherwise.\n   */\n  isHTTP() {\n    let uri = this.getAbsoluteUrl(false);\n    if (!uri) {\n      return null;\n    }\n    const protocol = uri.protocol().toLowerCase();\n    return hasText(protocol) && browserProtocols.includes(protocol);\n  }\n\n  /**\n   * Returns whether the entity is a preview image.\n   * \n   * @returns {boolean} `true` if the entity is a preview, `false` otherwise.\n   */\n  isPreview() {\n    return false;\n  }\n  \n}\n\nexport default STACReference;\n","import STACReference from './reference.js';\nimport { isObject } from './utils.js';\n\n/**\n * A STAC Link object.\n * \n * You can access all properties of the given STAC Link object directly, e.g. `link.href`.\n * \n * @class\n * @property {string} href\n * @property {string} rel\n * @property {?string} type\n * @property {?string} title\n * @property {?string} method\n * @property {?Object.<string, string>} headers\n * @property {?Object} body\n * @property {?boolean} merge\n * \n * @param {Object|Link} data The STAC Link object\n * @param {STAC|null} context The object that contains the link\n */\nclass Link extends STACReference {\n\n  constructor(data, context = null) {\n    super(data, context);\n  }\n  \n  /**\n   * Check whether this given object is a STAC LInk.\n   * \n   * @returns {boolean} `true` if the object is a STAC Link, `false` otherwise.\n   */\n  isLink() {\n    return true;\n  }\n\n  /**\n   * Returns the type of the STAC object, here: 'Link'.\n   * \n   * @returns {string}\n   */\n  getObjectType() {\n    return \"Link\";\n  }\n\n  /**\n   * Returns whether the link is a preview image.\n   * \n   * @returns {boolean} `true` if the link is a preview, `false` otherwise.\n   */\n  isPreview() {\n    return this.rel === 'preview';\n  }\n\n\n  /**\n   * Converts an array of STAC Links into an array of stac-js Links.\n   * \n   * @param {Array.<Object>} links Links\n   * @param {STAC|null} context The object that contains the links\n   * @returns {Array.<Link>} Improved Links\n   */\n  static fromLinks(links, context = null) {\n    if(!Array.isArray(links)) {\n      return [];\n    }\n    return links.map(link => isObject(link) ? new Link(link, context) : link);\n  }\n\n}\n\nexport default Link;\n","import STACObject from './object.js';\nimport Link from './link.js';\nimport { isStacMediaType } from './mediatypes.js';\nimport { hasText, isObject } from './utils.js';\nimport URI from 'urijs';\n\n\n/**\n * STAC Hypermedia class for STAC objects.\n * \n * Don't instantiate this class!\n * \n * @interface\n * @property {Array.<Link>} links\n * \n * @param {Object} data The STAC object\n * @param {string|null} absoluteUrl Absolute URL of the STAC object\n * @param {Object.<string, function>} keyMap Keys and functions that convert the values to stac-js objects.\n * @param {Array.<string>} privateKeys Keys that are private members of the stac-js objects (for cloning and export).\n */\nclass STACHypermedia extends STACObject {\n\n  constructor(data, absoluteUrl = null, keyMap = {}, privateKeys = []) {\n    super(\n      data,\n      Object.assign({ links: Link.fromLinks }, keyMap),\n      ['_url'].concat(privateKeys)\n    );\n\n    // Set or detect the URL of the STAC entity\n    if (!this._url) {\n      this._url = absoluteUrl;\n      if (!this._url) {\n        let self = this.getSelfLink();\n        if (self) {\n          this._url = self.href;\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets the absolute URL of the STAC entity (if provided explicitly or available from the self link).\n   * \n   * @param {boolean} stringify If `true` (default), a string is returned, otherwise a URI object.\n   * @returns {string|null} Absolute URL\n   */\n  getAbsoluteUrl(stringify = true) {\n    return stringify ? this._url : URI(this._url);\n  }\n\n  /**\n   * Sets the absolute URL of the STAC entity.\n   * \n   * @param {string} url Absolute URL\n   */\n  setAbsoluteUrl(url) {\n    this._url = url;\n  }\n\n  /**\n   * \n   * @todo\n   * @param {string} rel \n   * @param {boolean} allowUndefined \n   * @returns {Array.<Link>}\n   */\n  getStacLinksWithRel(rel, allowUndefined = true) {\n    return this.getLinksWithRels([rel])\n      .filter(link => isStacMediaType(link.type, allowUndefined));\n  }\n\n  /**\n   * \n   * @todo\n   * @param {string} rel \n   * @param {boolean} allowUndefined \n   * @returns {Link} \n   */\n  getStacLinkWithRel(rel, allowUndefined = true) {\n    const links = this.getStacLinksWithRel(rel, allowUndefined);\n    if (links.length > 0) {\n      return links[0];\n    }\n    else {\n      return null;\n    }\n  }\n  \n  /**\n   * \n   * @todo\n   * @returns {Array.<Link>}\n   */\n  getLinks() {\n    return Array.isArray(this.links) ? this.links.filter(link => isObject(link) && hasText(link.href)) : [];\n  }\n\n  /**\n   * \n   * @todo\n   * @param {string} rel \n   * @returns {Link} \n   */\n  getLinkWithRel(rel) {\n    return this.getLinks().find(link => link.rel === rel) || null;\n  }\n\n  /**\n   * \n   * @todo\n   * @param {Array.<string>} rels \n   * @returns {Array.<Link>} \n   */\n  getLinksWithRels(rels) {\n    return this.getLinks().filter(link => rels.includes(link.rel));\n  }\n\n  /**\n   * \n   * @todo\n   * @param {Array.<string>} rels \n   * @returns {Array.<Link>} \n   */\n  getLinksWithOtherRels(rels) {\n    return this.getLinks().filter(link => !rels.includes(link.rel));\n  }\n\n  /**\n   * Returns the self link, if present.\n   * \n   * @returns {Link|null} The self link\n   */\n  getSelfLink() {\n    return this.getStacLinkWithRel('self');\n  }\n\n  /**\n   * Returns the root link, if present.\n   * \n   * @returns {Link|null} The root link\n   */\n  getRootLink() {\n    return this.getStacLinkWithRel('root');\n  }\n\n  /**\n   * Returns the parent link, if present.\n   * \n   * @returns {Link|null} The parent link\n   */\n  getParentLink() {\n    return this.getStacLinkWithRel('parent');\n  }\n  \n}\n\nexport default STACHypermedia;\n","import STACHypermedia from './hypermedia.js';\n\n/**\n * A STAC API Collection (i.e. an ItemCollection or a CollectionCollection)\n * \n * You can access all properties of the given STAC Catalog object directly, e.g. `collection.links`.\n * \n * Don't instantiate this class!\n * \n * @interface\n * @param {Object} data The STAC API Collection object\n * @param {string|null} absoluteUrl Absolute URL of the STAC Item Collection\n * @param {Object.<string, function>} keyMap Keys and functions that convert the values to stac-js objects.\n * @param {Array.<string>} privateKeys Keys that are private members of the stac-js objects (for cloning and export).\n */\nclass APICollection extends STACHypermedia {\n\n  constructor(data, absoluteUrl = null, keyMap = {}, privateKeys = []) {\n    super(data, absoluteUrl, keyMap, privateKeys);\n  }\n\n  /**\n   * Returns all STAC entities in this list.\n   * \n   * @returns {Array.<STAC>} All STAC entities\n   */\n  getAll() {\n    return [];\n  }\n\n}\n\nexport default APICollection;\n","import { getMinMaxValues, getNoDataValues } from \"./utils.js\";\nimport STACObject from './object.js';\n\n/**\n * A STAC Band.\n * \n * You can access all properties of the given STAC Band object directly, e.g., `band.name`.\n * \n * @class\n * @property {string} name\n * \n * @param {Object|Band} data The STAC Band object\n * @param {number|string} index The band index\n * @param {Collection|Item|Asset|null} context The object that contains the band\n */\nclass Band extends STACObject {\n\n  constructor(data, index = null, context = null) {\n    super(data, {}, ['_index', '_context']);\n    if (typeof this._index !== 'number') {\n      this._index = typeof index === 'string' ? parseInt(index, 10) : index;\n    }\n    if (!this._context) {\n      this._context = context;\n    }\n  }\n\n  /**\n   * Returns the STAC entity that contains the band.\n   * \n   * @returns {Collection|Item|Asset|null}\n   */\n  getContext() {\n    return this._context;\n  }\n\n  /**\n   * Returns the type of the STAC object, here: 'Band'.\n   * \n   * @returns {string}\n   */\n  getObjectType() {\n    return \"Band\";\n  }\n\n  /**\n   * Check whether this given object is a STAC Band.\n   * \n   * @returns {boolean} `true` if the object is a STAC Band, `false` otherwise.\n   */\n  isBand() {\n    return true;\n  }\n\n  /**\n   * Returns the index of the band.\n   * \n   * @returns {number|null} Index of the band\n   */\n  getIndex() {\n    return this._index;\n  }\n\n  /**\n   * Returns the metadata for the given field name.\n   * \n   * Returns the metadata from the asset, if present.\n   * Otherwise, returns the metadata from calling `getMetadata()` on the STAC entity that contains the asset.\n   * \n   * @param {string} field Field name\n   * @returns {*} The value of the field\n   */\n  getMetadata(field) {\n    if (typeof this[field] !== 'undefined') {\n      return this[field];\n    }\n    if (this._context) {\n      return this._context.getMetadata(field);\n    }\n    return undefined;\n  }\n\n  /**\n   * Gets the reported minimum and maximum values for a band.\n   * \n   * Searches through different extension fields in raster, classification, and file.\n   * \n   * @returns {Statistics}\n   */\n  getMinMaxValues() {\n    return getMinMaxValues(this);\n  }\n\n  /**\n   * Gets the reported no-data values for a band.\n   * \n   * Searches through different extension fields in raster, classification, and file.\n   * \n   * @returns {Array.<*>}\n   */\n  getNoDataValues() {\n    return getNoDataValues(this);\n  }\n\n  /**\n   * Converts an object of STAC Bands into an array of stac-js Bands.\n   * \n   * @param {Array.<Object>} bands Bands\n   * @param {Collection|Item|Asset|null} context The object that contains the bands\n   * @returns {Array.<Band>} Improved Bands\n   */\n  static fromBands(bands, context = null) {\n    let newBands = [];\n    if(Array.isArray(bands)) {\n      for(let i in bands) {\n        const b = bands[i];\n        const newBand = b instanceof Band ? b : new Band(b, i, context);\n        newBands.push(newBand);\n      }\n    }\n    return newBands;\n  }\n\n}\n\nexport default Band;\n","import { getMinMaxValues, getNoDataValues, hasText, isObject } from \"./utils.js\";\nimport STACReference from './reference.js';\nimport Band from \"./band.js\";\n\nconst NO_INHERITANCE = [\n  'created',\n  'updated',\n  'published',\n  'expires',\n  'unpublished',\n  'bands'\n];\n\n/**\n * A STAC Asset or Item Asset Definition.\n * \n * You can access all properties of the given STAC Asset object directly, e.g., `asset.href`.\n * \n * @class\n * @property {string} href\n * @property {?string} title\n * @property {?string} description\n * @property {?string} type\n * @property {?Array.<string>} roles\n * \n * @param {Object|Asset} data The STAC Asset object\n * @param {string} key The asset key\n * @param {Collection|Item|null} context The object that contains the asset\n */\nclass Asset extends STACReference {\n\n  constructor(data, key = null, context = null) {\n    const keyMap = {\n      bands: Band.fromBands,\n      alternate: Asset.fromAssets\n    };\n    super(data, context, keyMap, ['_key']);\n    if (!this._key) {\n      this._key = key;\n    }\n  }\n\n  /**\n   * Returns the type of the STAC object, here: 'Asset'.\n   * \n   * @returns {string}\n   */\n  getObjectType() {\n    return \"Asset\";\n  }\n\n  /**\n   * Check whether this given object is a STAC Asset.\n   * \n   * @returns {boolean} `true` if the object is a STAC Asset, `false` otherwise.\n   */\n  isAsset() {\n    return true;\n  }\n\n  /**\n   * Gets the URL of the asset as absolute URL.\n   * \n   * @param {boolean} stringify If `true` (default), a string is returned, otherwise a URI object.\n   * @returns {URI|string|null}\n   */\n  getAbsoluteUrl(stringify = true) {\n    if (this.isDefinition()) {\n      return null;\n    }\n    return super.getAbsoluteUrl(stringify);\n  }\n\n  /**\n   * Returns the key of the asset.\n   * \n   * @returns {string|null} Key of the asset\n   */\n  getKey() {\n    return this._key;\n  }\n\n  /**\n   * Returns the metadata for the given field name.\n   * \n   * Returns the metadata from the asset, if present.\n   * Otherwise, returns the metadata from calling `getMetadata()` on the STAC entity that contains the asset.\n   * \n   * @param {string} field Field name\n   * @returns {*} The value of the field\n   */\n  getMetadata(field) {\n    if (typeof this[field] !== 'undefined') {\n      return this[field];\n    }\n    // Check whether this is an alternate asset\n    if (this._context instanceof Asset) {\n      return this._context.getMetadata(field);\n    }\n    // This should be a Collection or Item, we can inherit most fields\n    if (this._context && !NO_INHERITANCE.includes(field)) {\n      return this._context.getMetadata(field);\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns the bands for the asset.\n   * \n   * @returns {Array.<Band>}\n   */\n  getBands() {\n    return this.bands || [];\n  }\n\n  /**\n   * The RGB bands.\n   * \n   * @typedef {Object} VisualBands\n   * @property {Band} red The red band with its index\n   * @property {Band} green The green band with its index\n   * @property {Band} blue The blue band with its index\n   */\n\n  /**\n   * Find the RGB bands.\n   * \n   * @returns {VisualBands|null} Object with the RGB bands or null\n   */\n  findVisualBands() {\n    const rgb = {\n      red: null,\n      green: null,\n      blue: null\n    };\n    const bands = this.getBands();\n    for(const key in bands) {\n      const index = parseInt(key, 10); // for loop may return strings as keys\n      const band = bands[index];\n      if (isObject(band) && hasText(band['eo:common_name']) && band['eo:common_name'] in rgb) {\n        rgb[band['eo:common_name']] = band;\n      }\n    }\n    const complete = Object.values(rgb).every(o => o !== null);\n    return complete ? rgb : null;\n  }\n\n  /**\n   * Returns the band for the given criteria.\n   * \n   * Searches the given `property` (default: `name`) for the given value(s).\n   * \n   * @param {*} value A single value to find or a list of values to find one of.\n   * @param {string} property The property in the bands to match against.\n   * @returns {Band|null}\n   * @see {getBands}\n   */\n  findBand(value, property = 'name') {\n    if (!Array.isArray(value)) {\n      value = [value];\n    }\n    const bands = this.getBands();\n    const index = bands.findIndex(band => isObject(band) && value.includes(band[property]));\n    if (index >= 0) {\n      return bands[index];\n    }\n    return null;\n  }\n\n  /**\n   * Returns the band for the given band index.\n   * \n   * Passes through the (band) objects.\n   * \n   * @param {number|Object} band\n   * @returns {Object|null}\n   * @see {getBands}\n   */\n  getBand(band) {\n    if (isObject(band) || band === null) {\n      return band;\n    }\n    const bands = this.getBands();\n    return bands[band] || null;\n  }\n\n  /**\n   * Gets the reported minimum and maximum values for an asset.\n   * \n   * Searches through different extension fields in raster, classification, and file.\n   * \n   * @returns {Statistics}\n   */\n  getMinMaxValues() {\n    return getMinMaxValues(this);\n  }\n\n  /**\n   * Gets the reported no-data values for an asset.\n   * \n   * Searches through different extension fields in nodata, classification, and file.\n   * \n   * @returns {Array.<*>}\n   */\n  getNoDataValues() {\n    return getNoDataValues(this);\n  }\n\n  /**\n   * Returns whether this asset is an Item Asset definition (i.e., doesn't have an href) or not.\n   * \n   * @returns {boolean} `true` if this asset is an Item Asset definition, `false` otherwise.\n   */\n  isDefinition() { // \n    return !hasText(this.href);\n  }\n\n  /**\n   * Checks whether the asset is accessible via HTTP or HTTPS.\n   * \n   * Returns `null` for item asset definitions, otherwise a `boolean` value.\n   * \n   * @returns {boolean|null} `true` if this asset is available via HTTP or HTTPS, `false` or `null` otherwise.\n   */\n  isHTTP() {\n    if (this.isDefinition()) {\n      return null;\n    }\n    return super.isHTTP();\n  }\n\n  /**\n   * Returns whether the asset is a preview image (thumbnail / overview).\n   * \n   * An asset is a preview if one of the roles is 'thumbnail' or 'overview'.\n   * it is also a preview if the key is 'thumbnail' or 'overview'.\n   * \n   * @returns {boolean} `true` if the asset is a preview, `false` otherwise.\n   */\n  isPreview() {\n    const roles = ['thumbnail', 'overview'];\n    if (roles.includes(this.getKey())) {\n      return true;\n    }\n    return Array.isArray(this.roles) && this.roles.some(role => roles.includes(role));\n  }\n\n  /**\n   * Checks whether this asset has a specific role assigned.\n   * \n   * @param {string|Array.<string>} roles One or more roles.\n   * @param {boolean} includeKey Also returns `true` if the asset key equals to one of the given roles.\n   * @returns {boolean} `true` if this asset is one of the given roles (or key), `false` otherwise.\n   */\n  hasRole(roles, includeKey = false) { // string or array of strings\n    if (!Array.isArray(roles)) {\n      roles = [roles];\n    }\n    if (includeKey && roles.includes(this.getKey())) {\n      return true;\n    }\n    return Array.isArray(this.roles) && (Boolean(this.roles.find(role => roles.includes(role))));\n  }\n\n  /**\n   * Converts an object of STAC Assets into an object of stac-js Assets.\n   * \n   * @param {Object.<string, Object>} assets Assets\n   * @param {Collection|Item|null} context The object that contains the assets\n   * @returns {Object.<string, Asset>} Improved Assets\n   */\n  static fromAssets(assets, context = null) {\n    let newAssets = {};\n    if(isObject(assets)) {\n      for(let i in assets) {\n        const a = assets[i];\n        const newAsset = a instanceof Asset ? a : new Asset(a, i, context);\n        newAssets[i] = newAsset;\n      }\n    }\n    return newAssets;\n  }\n\n}\n\nexport default Asset;\n","// This code is based on https://github.com/cherry-projects/locale-id\r\n// Due to the \"heavy\" dependencies, it has been slimmed down\r\n\r\n// http://userguide.icu-project.org/locale\r\nexport default function parse(locale) {\r\n  if (!locale) {\r\n    return undefined;\r\n  }\r\n\r\n  // extract keyword\r\n  const stringLocale = String(locale);\r\n  const keywordPos = stringLocale.indexOf('@');\r\n\r\n  const keyword = keywordPos !== -1\r\n    ? stringLocale.substr(keywordPos + 1)\r\n    : undefined;\r\n\r\n  const localeWithoutKeyword = keywordPos !== -1\r\n    ? stringLocale.substr(0, keywordPos)\r\n    : stringLocale;\r\n\r\n  // en-us => en_us\r\n  const parts = String(localeWithoutKeyword)\r\n    .replace(/-/g, '_')\r\n    .split('_');\r\n\r\n  if (!parts.length || parts.length > 4) {\r\n    return undefined;\r\n  }\r\n\r\n  const language = parts.shift();\r\n  if (!language) {\r\n    return undefined;\r\n  }\r\n\r\n  const retVar = {\r\n    keyword,\r\n    language: language.toLowerCase(),\r\n  };\r\n\r\n  if (!parts.length) {\r\n    return retVar;\r\n  }\r\n\r\n  if (parts.length === 3) {\r\n    const variant = parts.pop();\r\n    if (variant) {\r\n      retVar.variant = variant.toUpperCase();\r\n    }\r\n  }\r\n\r\n  let country = parts.pop();\r\n  if (country.length > 3) {\r\n    retVar.keyword = country;\r\n\r\n    country = parts.pop();\r\n  }\r\n\r\n  if (country) {\r\n    retVar.country = country.toUpperCase();\r\n  }\r\n\r\n  if (!parts.length) {\r\n    return retVar;\r\n  }\r\n\r\n  const script = parts.pop();\r\n  if (typeof script === 'string' && script.length >= 1) {\r\n    retVar.script = script[0].toUpperCase() + script.substring(1).toLowerCase();\r\n  }\r\n\r\n  return retVar;\r\n}\r\n\r\nexport function normalize(locale, delimeter = '_') {\r\n  const obj = parse(locale);\r\n  if (!obj) {\r\n    return obj;\r\n  }\r\n\r\n  let result = obj.language;\r\n\r\n  if (obj.script) {\r\n    result += `${delimeter}${obj.script}`;\r\n  }\r\n\r\n  if (obj.country) {\r\n    result += `${delimeter}${obj.country}`;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nconst splitAcceptLanguageRegEx = /([a-z]{1,8}(-[a-z]{1,8})?)\\s*(;\\s*q\\s*=\\s*(1|0\\.[0-9]+))?/ig;\r\nconst acceptLanguageItemRegEx = /^([a-z]{1,8}(-[a-z]{1,8})?)/i;\r\n\r\nexport function normalizeAcceptLanguage(acceptLanguage) {\r\n  const returnItems = [];\r\n  if (!acceptLanguage) {\r\n    return returnItems;\r\n  }\r\n\r\n  const items = acceptLanguage.match(splitAcceptLanguageRegEx) || [];\r\n  items.forEach(acceptLanguageItem => {\r\n    const matches = acceptLanguageItem.match(acceptLanguageItemRegEx) || [];\r\n    const locale = normalize(matches[0]);\r\n    if (locale) {\r\n      returnItems.push(locale);\r\n    }\r\n  });\r\n\r\n  return returnItems;\r\n}\r\n\r\nexport function prepareSupported(supported) {\r\n  const lgs = {};\r\n\r\n  supported.forEach(supportedLocale => {\r\n    const { language, country } = parse(supportedLocale);\r\n    if (!language) {\r\n      throw new Error(`Locale ${supportedLocale} is not parsable`);\r\n    }\r\n\r\n    if (!lgs[language]) {\r\n      lgs[language] = {\r\n        countries: {},\r\n        firstCountry: undefined,\r\n        main: undefined,\r\n      };\r\n    }\r\n\r\n    const lg = lgs[language];\r\n    if (country) {\r\n      lg.countries[country] = supportedLocale;\r\n\r\n      if (!lg.firstCountry) {\r\n        lg.firstCountry = supportedLocale;\r\n      }\r\n    } else {\r\n      lg.main = supportedLocale;\r\n    }\r\n  });\r\n\r\n  return lgs;\r\n}\r\n\r\nexport function getBest(supported, locale, defaultLocale, getAnyCountry) {\r\n  const lgs = Array.isArray(supported) ? prepareSupported(supported) : supported;\r\n\r\n  // return defaultLocale if current locale is undefined\r\n  if (!locale && defaultLocale) {\r\n    return getBest(supported, defaultLocale, undefined, getAnyCountry);\r\n  }\r\n\r\n  if (!locale) {\r\n    return undefined;\r\n  }\r\n\r\n  const { language, country } = parse(locale);\r\n  if (!language) {\r\n    return defaultLocale;\r\n  }\r\n\r\n  // selected locale is not supported\r\n  if (!lgs[language]) {\r\n    if (locale === defaultLocale) {\r\n      return undefined;\r\n    }\r\n\r\n    return getBest(supported, defaultLocale, null, getAnyCountry);\r\n  }\r\n\r\n  const { countries, main = defaultLocale, firstCountry } = lgs[language];\r\n  if (!countries || !country) {\r\n    if (getAnyCountry && firstCountry) {\r\n      return firstCountry;\r\n    }\r\n\r\n    return main;\r\n  }\r\n\r\n  if (getAnyCountry && firstCountry) {\r\n    return countries[country] ? countries[country] : firstCountry;\r\n  }\r\n\r\n  return countries[country] ? countries[country] : main;\r\n}\r\n","import { geotiffMediaTypes, isMediaType } from './mediatypes.js';\nimport { isObject, hasText } from './utils.js';\nimport STACHypermedia from './hypermedia.js';\nimport { getBest } from './locales.js';\n\n/**\n * Class for STAC spec entities (Item, Catalog and Collection).\n * \n * Don't instantiate this class!\n * \n * @interface\n * @param {Object} data The STAC object\n * @param {string|null} absoluteUrl Absolute URL of the STAC object\n * @param {Object.<string, function>} keyMap Keys and functions that convert the values to stac-js objects.\n * @param {Array.<string>} privateKeys Keys that are private members of the stac-js objects (for cloning and export).\n */\nclass STAC extends STACHypermedia {\n\n  constructor(data, absoluteUrl = null, keyMap = {}, privateKeys = []) {\n    super(data, absoluteUrl, keyMap, privateKeys);\n  }\n\n  /**\n   * Returns a single temporal extent for the STAC entity.\n   * \n   * @returns {Array.<Date|null>|null}\n   */\n  getTemporalExtent() {\n    return null;\n  }\n\n  /**\n   * Returns the temporal extent(s) for the STAC entity.\n   * \n   * @returns {Array.<Array.<Date|null>>}\n   */\n  getTemporalExtents() {\n    return [];\n  }\n\n  /**\n   * Get the \"best\" link for a specific locale (with fallback).\n   * \n   * @param {string} locale \n   * @param {?string} fallbackLocale \n   * @returns {Link|null} The link with the given locale or null if not found.\n   * @see {@link getBest}\n   */\n  getLocaleLink(locale, fallbackLocale = null) {\n    let links = this.getStacLinksWithRel('alternate')\n      .filter(link => hasText(link.hreflang));\n    \n    let available;\n    if (Array.isArray(this.languages)) {\n      available = this.languages.map(l => l.code);\n    }\n    else {\n      available = links.map(link => link.hreflang);\n    }\n    \n    let best = getBest(available, locale, fallbackLocale);\n    return links.find(link => link.hreflang === best) || null;\n  }\n\n  /**\n   * Get the icons from the links in a STAC entity.\n   * \n   * @param {boolean} allowUndefined \n   * @returns {Array.<Link>}\n   */\n  getIcons(allowUndefined = true) {\n    return this.getLinksWithRels(['icon'])\n      .filter(img => img.canBrowserDisplayImage(allowUndefined));\n  }\n\n  /**\n   * Get the thumbnails from the assets and links in a STAC entity.\n   * \n   * @param {boolean} browserOnly - Return only images that can be shown in a browser natively (PNG/JPG/GIF/WEBP + HTTP/S).\n   * @param {string|null} prefer - If not `null` (default), prefers a role over the other. Either `thumbnail` or `overview`.\n   * @returns {Array.<STACReference>} Asset or Link\n   */\n  getThumbnails(browserOnly = true, prefer = null) {\n    let thumbnails = this.getAssets().filter(asset => asset.isPreview());\n    // Get from links only if no assets are available as they should usually be the same as in assets\n    if (thumbnails.length === 0) {\n      thumbnails = this.getLinks().filter(link => link.isPreview());\n    }\n    // Some old catalogs use just a asset key\n    if (thumbnails.length === 0) {\n      const thumbnail = this.getAsset(\"thumbnail\");\n      if (thumbnail) {\n        thumbnails.push(thumbnail);\n      }\n    }\n    if (browserOnly) {\n      // Remove all images that can't be displayed in a browser\n      thumbnails = thumbnails.filter(img => img.canBrowserDisplayImage());\n    }\n    if (prefer && thumbnails.length > 1) {\n      // Prefer one role over the other.\n      // The two step approach with two filters ensures the same sort bevahiour across all browsers:\n      // see https://github.com/radiantearth/stac-browser/issues/370\n      let filter = img => (Array.isArray(img.roles) && img.roles.includes(prefer)) || (img.getKey() === prefer);\n      thumbnails = thumbnails\n        .filter(filter)\n        .concat(thumbnails.filter(img => !filter(img)));\n    }\n    return thumbnails;\n  }\n\n  /**\n   * Determines the default GeoTiff asset for visualization.\n   * \n   * @param {boolean} httpOnly Return only GeoTiffs that can be accessed via HTTP(S)\n   * @param {boolean} cogOnly Return only COGs\n   * @returns {Asset} Default GeoTiff asset\n   * @see {rankGeoTIFFs}\n   */\n  getDefaultGeoTIFF(httpOnly = true, cogOnly = false) {\n    let scores = this.rankGeoTIFFs(httpOnly, cogOnly);\n    return scores[0]?.asset;\n  }\n\n  /**\n   * Object with an asset and the corresponding score.\n   * \n   * @typedef {Object} AssetScore\n   * @property {Asset} asset\n   * @property {number} score\n   */\n\n  /**\n   * A function that can influence the score.\n   * \n   * Returns a relative addition to the score.\n   * Negative values subtract from the score.\n   * \n   * @callback STAC~rankGeoTIFFs\n   * @param {Asset} asset The asset to calculate the score for.\n   */\n\n  /**\n   * Ranks the GeoTiff assets for visualization purposes.\n   * \n   * The score factors can be found below:\n   * - Roles/Keys (by default) - if multiple roles apply only the highest score is added:\n   *   - overview => +3\n   *   - thumbnail => +2\n   *   - visual => +2\n   *   - data => +1\n   *   - none of the above => no change\n   * - Other factors:\n   *   - media type is COG: +2 (if cogOnly = false)\n   *   - has RGB bands: +1\n   *   - additionalCriteria: +/- a custom value\n   * \n   * @param {boolean} httpOnly Return only GeoTiffs that can be accessed via HTTP(S)\n   * @param {boolean} cogOnly Return only COGs\n   * @param {Object.<string, number>} roleScores Roles (and keys) considered for the scoring. They key is the role name, the value is the score. Higher is better. Defaults to the roles and scores detailed above. An empty object disables role-based scoring.\n   * @param {STAC~rankGeoTIFFs} additionalCriteria A function to customize the score by adding/subtracting.\n   * @returns {Array.<AssetScore>} GeoTiff assets sorted by score in descending order.\n   */\n  rankGeoTIFFs(httpOnly = true, cogOnly = false, roleScores = null, additionalCriteria = null) {\n    if (!isObject(roleScores)) {\n      roleScores = {\n        data: 1, \n        visual: 2,\n        thumbnail: 2,\n        overview: 3\n      };\n    }\n    let scores = [];\n    let assets = this.getAssetsByTypes(geotiffMediaTypes);\n    if (httpOnly) {\n      assets = assets.filter(asset => asset.isHTTP() && (!cogOnly || asset.isCOG()));\n    }\n    let roles = Object.entries(roleScores);\n    for(let asset of assets) {\n      let score = 0;\n      if (roles.length > 0) {\n        let result = roles\n          .filter(([role]) => asset.hasRole(role, true)) // Remove all roles that don't exist in the asset\n          .map(([,value]) => value); // Map to the scores\n        if (result.length > 0) {\n          score += Math.max(...result); // Add the highest of the scores\n        }\n      }\n      if (!cogOnly && asset.isCOG()) {\n        score += 2;\n      }\n      if (asset.findVisualBands()) {\n        score += 1;\n      }\n      if (typeof additionalCriteria === 'function') {\n        score += additionalCriteria(asset);\n      }\n\n      scores.push({asset, score});\n    }\n    scores.sort((a,b) => b.score - a.score);\n    return scores;\n  }\n\n  /**\n   * The single-band assets for RGB composites.\n   * \n  * @typedef {Object} VisualAssets\n  * @property {Band} red The red band with its index\n  * @property {Band} green The green band with its index\n  * @property {Band} blue The blue band with its index\n  */\n\n  /**\n   * Find the single-band assets for RGB.\n   * \n   * @returns {VisualAssets|null} Object with the RGB bands or null\n   */\n  findVisualAssets() {\n    let rgb = {\n      red: null,\n      green: null,\n      blue: null\n    };\n    let names = Object.keys(rgb);\n    let assets = this.getAssets();\n    for(let asset of assets) {\n      let result = asset.findBand(names, 'eo:common_name');\n      if (result) {\n        rgb[result[\"eo:common_name\"]] = asset;\n      }\n    }\n    let complete = Object.values(rgb).every(o => o !== null);\n    return complete ? rgb : null;\n  }\n\n  /**\n   * \n   * @todo\n   * @param {string} key\n   * @returns {Asset|null}\n   */\n  getAsset(key) {\n    if (!isObject(this.assets)) {\n      return null;\n    }\n    return this.assets[key] || null;\n  }\n\n  /**\n   * \n   * @todo\n   * @returns {Array.<Asset>}\n   */\n  getAssets() {\n    if (!isObject(this.assets)) {\n      return [];\n    }\n    return Object.values(this.assets);\n  }\n\n  /**\n   * Returns all assets that contain at least one of the given roles.\n   * \n   * @param {string|Array.<string>} roles One or more roles.\n   * @param {boolean} includeKey Also returns `true` if the asset key equals to one of the given roles.\n   * @returns {Array.<Asset>} The assets with the given roles.\n   */\n  getAssetsWithRoles(roles, includeKey = false) {\n    return this.getAssets().filter(asset => asset.hasRole(roles, includeKey));\n  }\n\n  /**\n   * \n   * @todo\n   * @param {string} role \n   * @param {boolean} includeKey \n   * @returns {Asset|null}\n   */\n  getAssetWithRole(role, includeKey = false) {\n    let assets = this.getAssetsWithRoles([role], includeKey);\n    return assets[0] || null;\n  }\n\n  /**\n   * \n   * @todo\n   * @param {Array.<string>} types \n   * @returns {Array.<Asset>}\n   */\n  getAssetsByTypes(types) {\n    return this.getAssets().filter(asset => isMediaType(asset.type, types));\n  }\n\n  /**\n   * \n   * @todo\n   * @param {*} other \n   * @returns {boolean}\n   */\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof STAC)) {\n      return false;\n    }\n    if (this.getObjectType() !== other.getObjectType()) {\n      return false;\n    }\n    if (this.id && this.id === other.id) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Checks whether a specific extension is implemented.\n   * \n   * The pattern can contain `*` as a wildcard, e.g. for version numbers.\n   * \n   * @param {string} pattern The extension URI to check for.\n   * @returns {boolean} `true` if the extension is implemented, `false` otherwise.\n   */\n  supportsExtension(pattern) {\n    if (!Array.isArray(this.stac_extensions)) {\n      return false;\n    }\n    let regexp = new RegExp('^' + pattern.replaceAll('*', '[^/]+') + '$');\n    return this.stac_extensions.some(uri => regexp.test(uri));\n  }\n\n}\n\nexport default STAC;\n","import STAC from './stac.js';\n\n/**\n * Class for common parts of Catalogs and Collections.\n * \n * Don't instantiate this class!\n * \n * @interface\n * @param {Object} data The STAC Catalog or Collection object\n * @param {string|null} absoluteUrl Absolute URL of the STAC Catalog or Collection\n * @param {Object.<string, function>} keyMap Keys and functions that convert the values to stac-js objects.\n * @param {Array.<string>} privateKeys Keys that are private members of the stac-js objects (for cloning and export).\n */\nclass CatalogLike extends STAC {\n\n  constructor(data, absoluteUrl = null, keyMap = {}, privateKeys = []) {\n    super(data, absoluteUrl, keyMap, privateKeys);\n  }\n\n  /**\n   * Returns the type of the STAC object, here: 'Catalog' or 'Collection'.\n   * \n   * @returns {string}\n   */\n  getObjectType() {\n    return this.type;\n  }\n\n  /**\n   * Returns the search link, if present.\n   * \n   * If a specific method is provied, can exclude other methods from being returned.\n   * \n   * @returns {Link|null} The search link\n   */\n  getSearchLink(method = null) {\n    let links = this.getStacLinksWithRel('search');\n    if (!method) {\n      return links.find(link => link.method === method || (!method && !link.method)) || null;\n    }\n    else {\n      return links[0] || null;\n    }\n  }\n\n  /**\n   * Returns the link for API collections, if present.\n   * \n   * @returns {Link|null} The API collections link\n   */\n  getApiCollectionsLink() {\n    return this.getStacLinkWithRel('data');\n  }\n\n  /**\n   * Returns the link for API items, if present.\n   * \n   * @returns {Link|null} The API items link\n   */\n  getApiItemsLink() {\n    return this.getStacLinkWithRel('items');\n  }\n\n  /**\n   * Returns all child links.\n   * \n   * @returns {Array.<Link>} The child links\n   */\n  getChildLinks() {\n    return this.getStacLinksWithRel('child');\n  }\n\n  /**\n   * Returns all item links.\n   * \n   * @returns {Array.<Link>} The child links\n   */\n  getItemLinks() {\n    return this.getStacLinksWithRel('item');\n  }\n\n}\n\nexport default CatalogLike;\n","import CatalogLike from './cataloglike.js';\n\n/**\n * A STAC Catalog.\n * \n * You can access all properties of the given STAC Catalog object directly, e.g. `catalog.title`.\n * \n * @class\n * @property {string} stac_version\n * @property {?Array.<string>} stac_extensions\n * @property {string} type\n * @property {string} id\n * @property {?string} title\n * @property {string} description\n * @property {Array.<Link>} links\n * \n * @param {Object} data The STAC Catalog object\n * @param {string|null} absoluteUrl Absolute URL of the STAC Catalog\n */\nclass Catalog extends CatalogLike {\n\n  constructor(data, absoluteUrl = null) {\n    super(data, absoluteUrl);\n  }\n\n}\n\nexport default Catalog;\n","import { hasText } from \"./utils.js\";\n\n/**\n * Parses a UTC-based ISO8601 date and time string to a Date object.\n * \n * Does not support timezones as all STAC datetime must be given in UTC.\n * \n * @returns {Date|null}\n */\nexport function isoToDate(str) {\n  if (hasText(str) && str.length >= 10) {\n    try {\n      let strParts = str.match(/^(-?\\d{1,})-(\\d\\d)-(\\d\\d)[T ](\\d\\d):(\\d\\d):(\\d\\d)(?:\\.(\\d*))?(?:Z|[+-]00:00)?$/i);\n      let dt = strParts.slice(1).map(n => parseInt(n, 10));\n      return new Date(Date.UTC(dt[0], dt[1] - 1, dt[2], dt[3], dt[4], dt[5], dt[6] || 0));\n    } catch {\n      return null;\n    }\n  }\n  return null;\n}\n\n/**\n * Computes the center datetime between two datetimes.\n * \n * @param {Date} start start datetime\n * @param {Date} end end datetime\n * @returns {Date} center datetime\n */\nexport function centerDateTime(start, end) {\n  return new Date(start.valueOf() + ((end - start) / 2));\n}\n\n/**\n * Computes a single interval from multiple temporal intervals.\n * \n * @param {Array.<Array.<Date>>} list A list of temporal intervals\n * @returns {Array.<Date>|null} The merged temporal interval\n */\nexport function unionDateTime(list) {\n  if (!Array.isArray(list) || list.length === 0) {\n    return null;\n  }\n\n  let min;\n  let max;\n  const assign = (base, value, fn) => {\n    if (typeof base === 'undefined') {\n      return value;\n    }\n    else if (base === null || value === null) {\n      return null;\n    }\n    else {\n      return fn(base, value);\n    }\n  };\n  list.forEach(([start, end]) => {\n    min = assign(min, start, Math.min);\n    max = assign(max, end, Math.max);\n  });\n  return [\n    min === null ? null : new Date(min),\n    max === null ? null : new Date(max)\n  ];\n}\n","import Asset from './asset.js';\nimport Band from './band.js';\nimport CatalogLike from './cataloglike.js';\nimport { isoToDate } from './datetime.js';\nimport { ensureBoundingBox, toGeoJSON } from './geo.js';\nimport { hasText, isObject } from './utils.js';\n\n/**\n * Extents\n * \n * @typedef {Object} Extent\n * @property {SpatialExtent} spatial Spatial extents\n * @property {TemporalExtent} temporal Temporal extents\n */\n/**\n * Spatial Extents\n * \n * @typedef {Object} SpatialExtent\n * @property {Array.<Array<number>>} bbox Bounding boxes\n */\n/**\n * Temporal Extents\n * \n * @typedef {Object} TemporalExtent\n * @property {Array.<Array<string|null>>} interval Intervals\n */\n\n/**\n * A STAC Collection.\n * \n * You can access all properties of the given STAC Collection object directly, e.g. `collection.title`.\n * \n * @class\n * @property {string} stac_version\n * @property {?Array.<string>} stac_extensions\n * @property {string} type\n * @property {string} id\n * @property {?string} title\n * @property {string} description\n * @property {?Array.<string>} keywords\n * @property {string} license\n * @property {Array.<Provider>} providers\n * @property {Extent} extent\n * @property {Object.<string, Array|Object>} summaries\n * @property {Array.<Link>} links\n * @property {Object.<string, Asset>} assets\n * \n * @param {Object} data The STAC Collection object\n * @param {string|null} absoluteUrl Absolute URL of the STAC Collection\n */\nclass Collection extends CatalogLike {\n\n  constructor(data, absoluteUrl = null) {\n    const keyMap = {\n      assets: Asset.fromAssets,\n      item_assets: Asset.fromAssets\n    };\n    super(data, absoluteUrl, keyMap);\n  }\n\n  /**\n   * Returns a GeoJSON Feature for this STAC Collection.\n   * \n   * The Feature contains a Polygon or MultiPolygon based on the given number of valid bounding boxes.\n   * \n   * @returns {Object|null} GeoJSON object or `null`\n   */\n  toGeoJSON() {\n    let geojson = toGeoJSON(this.getBoundingBoxes());\n    if (geojson) {\n      geojson.id = this.id;\n    }\n    return geojson;\n  }\n\n  /**\n   * Returns a single union 2D bounding box for the whole collection.\n   * \n   * @returns {BoundingBox|null}\n   */\n  getBoundingBox() {\n    let bboxes = this.getRawBoundingBoxes();\n    if (bboxes.length > 0) {\n      return ensureBoundingBox(bboxes[0]);\n    }\n    return null;\n  }\n\n  /**\n   * Returns the individual 2D bounding boxes for the collection,\n   * without the union bounding box if multiple bounding boxes are given.\n   * \n   * @returns {Array.<BoundingBox>}\n   */\n  getBoundingBoxes() {\n    let raw = this.getRawBoundingBoxes();\n    if (raw.length === 1) {\n      return [ensureBoundingBox(raw[0])];\n    }\n    else if (raw.length > 1) {\n      return raw.slice(1).map(ensureBoundingBox);\n    }\n    return null;\n  }\n\n  /**\n   * Returns all bounding boxes from the collection, including the union bounding box.\n   * \n   * @returns {Array.<BoundingBox>}\n   */\n  getRawBoundingBoxes() {\n    let extents = this.extent?.spatial?.bbox;\n    if (Array.isArray(extents) && extents.length > 0) {\n      return extents;\n    }\n    return [];\n  }\n\n  /**\n   * Returns a single temporal extent for the STAC Collection.\n   * \n   * @returns {Array.<Date|null>|null}\n   */\n  getTemporalExtent() {\n    return this.getTemporalExtents()[0] || null;\n  }\n\n  /**\n   * Returns the temporal extent(s) for the STAC Collection.\n   * \n   * @returns {Array.<Array.<Date|null>>}\n   */\n  getTemporalExtents() {\n    let extents = this.extent?.temporal?.interval;\n    if (Array.isArray(extents) && extents.length > 0) {\n      return extents\n        .filter(extent => Array.isArray(extent) && (hasText(extent[0]) || hasText(extent[1])))\n        .map(interval => interval.map(datetime => isoToDate(datetime)));\n    }\n    return [];\n  }\n\n  /**\n   * Returns metadata from the Collection summaries for the given field name.\n   * \n   * @param {string} field Field name\n   * @returns {Array.<*>|Object|undefined} The value of the field\n   */\n  getSummary(field) {\n    if (isObject(this.summaries)) {\n      return this.summaries[field];\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns the bands.\n   * \n   * @returns {Array.<Band>}\n   */\n  getBands() {\n    let bands = this.getMetadata('bands');\n    if (!Array.isArray(bands)) {\n      bands = this.getSummary('bands');\n    }\n    if (!Array.isArray(bands)) {\n      return [];\n    }\n    return Band.fromBands(bands, this);\n  }\n  \n}\n\nexport default Collection;\n","import Collection from './collection.js';\nimport { unionDateTime } from './datetime.js';\nimport { unionBoundingBox } from './geo.js';\nimport APICollection from './apicollection.js';\n\n/**\n * Represents an Collections containing Collections.\n * \n * @class\n * @property {Array.<Collection>} collections\n * @property {Array.<Link>} links\n * \n * @param {Object} data The STAC API Collections object\n * @param {string|null} absoluteUrl Absolute URL of the STAC Item Collection\n */\nclass CollectionCollection extends APICollection {\n\n  constructor(data, absoluteUrl = null) {\n    const keyMap = {\n      collections: collections => collections.map(\n        collection => collection instanceof Collection ? collection : new Collection(collection)\n      )\n    };\n    super(data, absoluteUrl, keyMap);\n  }\n\n  /**\n   * Returns the type of the STAC object, here: 'CollectionCollection'.\n   * \n   * @returns {string}\n   */\n  getObjectType() {\n    return \"CollectionCollection\";\n  }\n\n  /**\n   * Returns all collections.\n   * \n   * @returns {Array.<Collection>} All STAC Collections\n   */\n  getAll() {\n    return this.collections;\n  }\n\n  /**\n   * Check whether this given object is a STAC Collection of Collections (i.e. API Collections).\n   * \n   * @returns {boolean} `true` if the object is a STAC CollectionCollection, `false` otherwise.\n   */\n  isCollectionCollection() {\n    return true;\n  }\n\n  /**\n   * Returns a GeoJSON Feature Collection for this STAC object.\n   * \n   * @returns {Object|null} GeoJSON object or `null`\n   */\n  toGeoJSON() {\n    let features = this.collections\n      .map(collection => collection.toGeoJSON())\n      .filter(geojson => geojson !== null);\n    return {\n      type: \"FeatureCollection\",\n      features\n    };\n  }\n\n  /**\n   * Returns a single 2D bounding box for all the STAC collections.\n   * \n   * @returns {BoundingBox|null}\n   */\n  getBoundingBox() {\n    return unionBoundingBox(this.getBoundingBoxes());\n  }\n\n  /**\n   * Returns a list of 2D bounding boxes for all the STAC collections.\n   * \n   * @returns {Array.<BoundingBox>}\n   */\n  getBoundingBoxes() {\n    return this.collections.map(collection => collection.getBoundingBox());\n  }\n\n  /**\n   * Returns a single temporal extent for the all the STAC collections.\n   * \n   * @returns {Array.<Date|null>|null}\n   */\n  getTemporalExtent() {\n    return unionDateTime(this.getTemporalExtents());\n  }\n\n  /**\n   * Returns the temporal extent(s) for the all the STAC collections.\n   * \n   * @returns {Array.<Array.<Date|null>>}\n   */\n  getTemporalExtents() {\n    return this.collections.map(collection => collection.getTemporalExtent());\n  }\n\n}\n\nexport default CollectionCollection;\n","import Asset from './asset.js';\nimport { centerDateTime, isoToDate } from './datetime.js';\nimport { ensureBoundingBox } from './geo.js';\nimport { hasText } from './utils.js';\nimport STAC from './stac.js';\nimport Band from './band.js';\n\n/**\n * Metadata for an item, the item properties.\n * \n * @typedef {Object} ItemProperties\n * @property {string} datetime Date and Time\n */\n\n/**\n * A STAC Item.\n * \n * You can access all properties of the given STAC Item object directly, e.g. `item.id` or `item.properties.datetime`.\n * \n * @class\n * @property {string} stac_version\n * @property {?Array.<string>} stac_extensions\n * @property {string} type\n * @property {string} id\n * @property {Object|null} geometry\n * @property {?Array.<number>} bbox\n * @property {ItemProperties} properties\n * @property {Array.<Link>} links\n * @property {Object.<string, Asset>} assets\n * @property {?string} collection\n * \n * @param {Object} data The STAC Item object\n * @param {string|null} absoluteUrl Absolute URL of the STAC Item\n */\nclass Item extends STAC {\n  \n  constructor(data, absoluteUrl = null) {\n    super(data, absoluteUrl, { assets: Asset.fromAssets });\n  }\n\n  /**\n   * Returns the type of the STAC object, here: 'Item'.\n   * \n   * @returns {string}\n   */\n  getObjectType() {\n    return \"Item\";\n  }\n\n  /**\n   * Returns a GeoJSON Feature for this STAC object.\n   * \n   * @returns {Object|null} GeoJSON object or `null`\n   */\n  toGeoJSON() {\n    return this.toJSON();\n  }\n\n  /**\n   * Returns a single 2D bounding box for the item.\n   * \n   * @returns {BoundingBox|null}\n   */\n  getBoundingBox() {\n    return ensureBoundingBox(this.bbox);\n  }\n\n  /**\n   * Returns 2D bounding boxes for the item.\n   * \n   * @returns {Array.<BoundingBox>}\n   */\n  getBoundingBoxes() {\n    const bbox = this.getBoundingBox();\n    return bbox ? [bbox] : [];\n  }\n\n  /**\n   * Returns a datetime for the STAC Item.\n   * \n   * If no datetime but start or end datetime are specified, computes a datetime from them.\n   * \n   * @returns {Date|null}\n   */\n  getDateTime() {\n    let dt = isoToDate(this.properties.datetime);\n    if (!dt) {\n      let start = isoToDate(this.properties.start_datetime);\n      let end = isoToDate(this.properties.end_datetime);\n      if (start && end) {\n        return centerDateTime(start, end);\n      }\n      else {\n        return start || end;\n      }\n    }\n    return dt;\n  }\n\n  /**\n   * Returns a single temporal extent for the STAC Item.\n   * \n   * @returns {Array.<Date|null>|null}\n   */\n  getTemporalExtent() {\n    return this.getTemporalExtents()[0] || null;\n  }\n\n  /**\n   * Returns the temporal extent(s) for the STAC Item.\n   * \n   * @returns {Array.<Array.<Date|null>>}\n   */\n  getTemporalExtents() {\n    let dates = [];\n    if (hasText(this.properties.start_datetime) || hasText(this.properties.end_datetime)) {\n      dates = [[this.properties.start_datetime || null, this.properties.end_datetime || null]];\n    }\n    else if (hasText(this.properties.datetime)) {\n      dates = [[this.properties.datetime, this.properties.datetime]];\n    }\n    return dates.map(interval => interval.map(datetime => isoToDate(datetime)));\n  }\n\n  /**\n   * Returns metadata from the Item properties for the given field name.\n   * \n   * @param {string} field Field name\n   * @returns {*} The value of the field\n   */\n  getMetadata(field) {\n    return this.properties[field];\n  }\n\n  /**\n   * Returns the bands.\n   * \n   * @todo Merge bands from assets\n   * @returns {Array.<Band>}\n   */\n  getBands() {\n    const bands = this.getMetadata('bands');\n    if (Array.isArray(bands)) {\n      return Band.fromBands(bands, this);\n    }\n    else {\n      return [];\n    }\n  }\n\n  /**\n   * Returns the collection link, if present.\n   * \n   * @returns {Link|null} The collection link\n   */\n  getCollectionLink() {\n    return this.getStacLinkWithRel('collection');\n  }\n\n}\n\nexport default Item;\n","import { unionDateTime } from './datetime.js';\nimport { unionBoundingBox } from './geo.js';\nimport Item from './item.js';\nimport APICollection from './apicollection.js';\n\n/**\n * Represents an ItemCollection containing Items.\n * \n * @class\n * @property {string} type\n * @property {Array.<Item>} features\n * @property {Array.<Link>} links\n * \n * @param {Object} data The STAC Item Collection object\n * @param {string|null} absoluteUrl Absolute URL of the STAC Item Collection\n */\nclass ItemCollection extends APICollection {\n\n  constructor(data, absoluteUrl = null) {\n    const keyMap = {\n      features: features => features.map(\n        feature => feature instanceof Item ? feature : new Item(feature)\n      )\n    };\n    super(data, absoluteUrl, keyMap);\n  }\n\n  /**\n   * Returns the type of the STAC object, here: 'ItemCollection'.\n   * \n   * @returns {string}\n   */\n  getObjectType() {\n    return \"ItemCollection\";\n  }\n\n  /**\n   * Returns all items.\n   * \n   * @returns {Array.<Item>} All STAC Items\n   */\n  getAll() {\n    return this.features;\n  }\n\n  /**\n   * Returns a GeoJSON FeatureCollection for this STAC object.\n   * \n   * @returns {Object|null} GeoJSON object or `null`\n   */\n  toGeoJSON() {\n    return this.toJSON();\n  }\n\n  /**\n   * Returns a single 2D bounding box for all the STAC items.\n   * \n   * @returns {BoundingBox|null}\n   */\n  getBoundingBox() {\n    return unionBoundingBox(this.getBoundingBoxes());\n  }\n\n  /**\n   * Returns a list of 2D bounding boxes for all the STAC items.\n   * \n   * @returns {Array.<BoundingBox>}\n   */\n  getBoundingBoxes() {\n    return this.features.map(item => item.getBoundingBox());\n  }\n\n  /**\n   * Returns a single temporal extent for all the STAC items.\n   * \n   * @returns {Array.<Date|null>|null}\n   */\n  getTemporalExtent() {\n    return unionDateTime(this.getTemporalExtents());\n  }\n\n  /**\n   * Returns the temporal extent(s) for all the STAC items.\n   * \n   * @returns {Array.<Array.<Date|null>>}\n   */\n  getTemporalExtents() {\n    return this.features.map(item => item.getTemporalExtent());\n  }\n\n}\n\nexport default ItemCollection;\n","import Migrate from '@radiantearth/stac-migrate';\nimport APICollection from './apicollection.js';\nimport Asset from './asset.js';\nimport Catalog from './catalog.js';\nimport CatalogLike from './cataloglike.js';\nimport Collection from './collection.js';\nimport CollectionCollection from './collectioncollection.js';\nimport Item from './item.js';\nimport ItemCollection from './itemcollection.js';\nimport Link from './link.js';\nimport STACHypermedia from './hypermedia.js';\nimport STACObject from './object.js';\nimport STACReference from './reference.js';\nimport STAC from './stac.js';\n\n/**\n * Creates the corresponding object for a object that conforms to the STAC specification.\n * \n * This creates either a Catalog, a Collection or an Item instance.\n * By default it migrates the data to the latest STAC version, but doesn't update the version number.\n * \n * @param {Object} data The STAC object\n * @param {boolean} migrate `true` to migrate to the latest version, `false` otherwise\n * @param {boolean} updateVersionNumber `true` to update the version number (to the latest version), `false` otherwise. Only applies if `migrate` is set to `true`.\n * @returns {Catalog|Collection|CollectionCollection|Item|ItemCollection} The created object instance.\n */\nexport default function create(data, migrate = true, updateVersionNumber = false) {\n  if (migrate) {\n    data = Migrate.stac(data, updateVersionNumber);\n  }\n  if (data.type === 'Feature') {\n    return new Item(data);\n  }\n  else if (data.type === 'FeatureCollection') {\n    return new ItemCollection(data);\n  }\n  else if (data.type === 'Collection'|| (!data.type && typeof data.extent !== 'undefined' && typeof data.license !== 'undefined')) {\n    return new Collection(data);\n  }\n  else if (!data.type && Array.isArray(data.collections)) {\n    return new CollectionCollection(data);\n  }\n  else {\n    return new Catalog(data);\n  }\n}\n\nexport {\n  APICollection,\n  Asset,\n  Catalog,\n  CatalogLike,\n  Collection,\n  CollectionCollection,\n  Item,\n  ItemCollection,\n  Link,\n  STAC,\n  STACHypermedia,\n  STACObject,\n  STACReference\n};\n","/**\n * @module ol/events/ErrorEvent\n */\nimport BaseEvent from 'ol/events/Event.js';\nimport EventType from 'ol/events/EventType.js';\n/**\n * @classdesc\n * Event emitted on configuration or loading error.\n * @api\n */\nclass ErrorEvent extends BaseEvent {\n    /**\n     * @param {Error} error error object.\n     * @api\n     */\n    constructor(error) {\n        super(EventType.ERROR);\n        /**\n         * @type {Error}\n         * @api\n         */\n        this.error = error;\n    }\n}\nexport default ErrorEvent;\n//# sourceMappingURL=ErrorEvent.js.map","/**\n * @module ol/util\n */\nimport VectorLayer from 'ol/layer/Vector.js';\nimport { isRegistered as isProj4Registered } from 'ol/proj/proj4.js';\nimport Circle from 'ol/style/Circle.js';\nimport Fill from 'ol/style/Fill.js';\nimport Stroke from 'ol/style/Stroke.js';\nimport Style from 'ol/style/Style.js';\nimport { STAC } from 'stac-js';\n/**\n * @typedef {import('ol/colorlike.js').ColorLike} ColorLike\n */\n/**\n * @typedef {import('ol/Collection.js').default} Collection\n * @template T\n */\n/**\n * @typedef {import('ol/Feature.js').default} Feature\n */\n/**\n * @typedef {import('ol/proj.js').Projection} Projection\n */\n/**\n * @typedef {import('ol/proj.js').ProjectionLike} ProjectionLike\n */\n/**\n * The pattern for the supported versions of the label extension.\n * @type {string}\n */\nexport const LABEL_EXTENSION = 'https://stac-extensions.github.io/label/v1.*/schema.json';\nconst transparentFill = new Fill({ color: 'rgba(0,0,0,0)' });\n/**\n * Creates a style for visualization.\n *\n * @param {ColorLike} strokeColor Stroke color\n * @param {number} strokeWidth Stroke with\n * @param {ColorLike} fillColor Fill color\n * @param {number} circleRadius Circle/Point radius\n * @return {Style} The style for visualization.\n * @api\n */\nexport function getStyle(strokeColor, strokeWidth, fillColor = 'rgba(255,255,255,0.4)', circleRadius = 5) {\n    let fill = transparentFill;\n    if (fillColor) {\n        fill = new Fill({\n            color: fillColor,\n        });\n    }\n    const stroke = new Stroke({\n        color: strokeColor,\n        width: strokeWidth,\n    });\n    return new Style({\n        image: new Circle({\n            fill,\n            stroke,\n            radius: circleRadius,\n        }),\n        fill,\n        stroke,\n    });\n}\n/**\n * The default style for rendering bounds of the STAC main entities.\n * @type {Style}\n * @api\n */\nexport const defaultBoundsStyle = getStyle('#3399CC', 3);\n/**\n * The default style for rendering collection list children.\n * @type {Style}\n * @api\n */\nexport const defaultCollectionStyle = getStyle('#ff9933', 2, null);\n/**\n * Get the STAC objects associated with this event, if any. Excludes API Collections.\n * @param {import('ol/MapBrowserEvent.js').default} event The asset to read the information from.\n * @param {STAC} [exclude] Excludes the given STAC entity from the list.\n * @param {Collection<Feature>} [selectedFeatures] A collection to add the selected features to.\n * @param {number} [hitTolerance] The hit tolerance in pixels.\n * @return {Promise<Array<STAC>>} A list of STAC objects\n * @api\n */\nexport async function getStacObjectsForEvent(event, exclude = null, selectedFeatures = null, hitTolerance = 0) {\n    const objects = new Set();\n    event.map.forEachFeatureAtPixel(event.pixel, \n    // Callback for all features that were found\n    (feature, layer) => {\n        if (selectedFeatures) {\n            selectedFeatures.push(feature);\n        }\n        objects.add(layer.get('stac'));\n    }, {\n        // Options for forEachFeatureAtPixel\n        hitTolerance,\n        // Filter the layers upfront, this ensures the presence of a STAC object\n        // so that we don't need to check in the callback above\n        layerFilter(layer) {\n            if (layer instanceof VectorLayer && layer.get('bounds') === true) {\n                const stac = layer.get('stac');\n                if (stac instanceof STAC && (!exclude || !stac.equals(exclude))) {\n                    return true;\n                }\n            }\n            return false;\n        },\n    });\n    return [...objects];\n}\n/**\n * Get the source info for the GeoTiff from the asset.\n * @param {import('stac-js').Asset} asset The asset to read the information from.\n * @param {Array<number>} selectedBands The (one-based) bands to show.\n * @return {import('ol/source/GeoTIFF.js').SourceInfo} The source info for the GeoTiff asset\n */\nexport function getGeoTiffSourceInfoFromAsset(asset, selectedBands) {\n    const sourceInfo = {\n        url: asset.getAbsoluteUrl(),\n    };\n    let source = asset;\n    let bands = asset.getBands();\n    // If there's just one band, we can also read the information from there.\n    if (bands.length === 1) {\n        source = bands[0];\n        bands = [];\n    }\n    // TODO: It would be useful if OL would allow min/max values per band\n    const { minimum, maximum } = source.getMinMaxValues();\n    if (typeof minimum === 'number') {\n        sourceInfo.min = minimum;\n    }\n    if (typeof maximum === 'number') {\n        sourceInfo.max = maximum;\n    }\n    if (typeof sourceInfo.min !== 'number' &&\n        typeof sourceInfo.max !== 'number' &&\n        bands.length > 1) {\n        // Read from bands as fallback and if available\n        for (const band of bands) {\n            const { minimum, maximum } = band.getMinMaxValues();\n            if (typeof minimum === 'number' &&\n                (typeof sourceInfo.min === 'undefined' || minimum < sourceInfo.min)) {\n                sourceInfo.min = minimum;\n            }\n            if (typeof maximum === 'number' &&\n                (typeof sourceInfo.max === 'undefined' || maximum > sourceInfo.max)) {\n                sourceInfo.max = maximum;\n            }\n        }\n    }\n    // TODO: It would be useful if OL would allow multiple no-data values\n    const nodata = source.getNoDataValues();\n    if (nodata.length > 0) {\n        sourceInfo.nodata = nodata[0];\n    }\n    else if (bands.length > 1) {\n        // Read from bands as fallback and if available\n        let nodata = undefined;\n        for (const band of bands) {\n            const bandNoData = band.getNoDataValues();\n            if (bandNoData.length > 0) {\n                if (typeof nodata === 'undefined') {\n                    nodata = bandNoData[0];\n                }\n                else if (nodata !== bandNoData[0]) {\n                    nodata = undefined;\n                    break;\n                }\n            }\n        }\n        if (typeof nodata !== 'undefined') {\n            sourceInfo.nodata = nodata;\n        }\n    }\n    if (selectedBands.length > 0) {\n        sourceInfo.bands = selectedBands;\n    }\n    else {\n        const visualBands = asset.findVisualBands();\n        if (visualBands) {\n            sourceInfo.bands = [\n                visualBands.red.getIndex() + 1,\n                visualBands.green.getIndex() + 1,\n                visualBands.blue.getIndex() + 1,\n            ];\n        }\n    }\n    return sourceInfo;\n}\n/**\n * Load the projection for the given projection code from the internet.\n *\n * @param {string} code Projection code, e.g. 'EPSG:1234'\n * @return {Promise<Projection|null>} The loaded projection\n */\nexport async function loadProjection(code) {\n    try {\n        // @ts-ignore - Support both old and new OpenLayers versions\n        const { fromProjectionCode, fromEPSGCode } = await import('ol/proj/proj4.js');\n        if (typeof fromProjectionCode === 'function') {\n            // Supported since ol v10.8.0\n            return await fromProjectionCode(code);\n        }\n        // Supported until ol v11.0.0\n        return await fromEPSGCode(code);\n    }\n    catch (_) {\n        return null;\n    }\n}\n/**\n * Gets the projection from the asset or link.\n * @param {import('stac-js').STACReference} reference The asset or link to read the information from.\n * @param {ProjectionLike} defaultProjection A default projection to use.\n * @return {Promise<ProjectionLike>} The projection, if any.\n */\nexport async function getProjection(reference, defaultProjection = undefined) {\n    let projection;\n    if (isProj4Registered()) {\n        // TODO: It would be great to handle WKT2 and PROJJSON, but is not supported yet by proj4js.\n        const code = reference.getMetadata('proj:code');\n        if (code) {\n            projection = await loadProjection(code);\n        }\n    }\n    return projection || defaultProjection;\n}\n/**\n * Returns the style for the footprint.\n * Removes the fill if anything is meant to be shown in the bounds.\n *\n * @param {Style} [originalStyle] The original style for the footprint.\n * @param {import('./layer/STAC.js').default} [layerGroup] The associated STAC layergroup to check.\n * @return {Style} The adapted style for the footprint.\n * @api\n */\nexport function getBoundsStyle(originalStyle, layerGroup) {\n    const style = originalStyle.clone();\n    if (!layerGroup.hasOnlyBounds()) {\n        style.setFill(transparentFill);\n    }\n    return style;\n}\n/**\n * Get a URL from a web-map-link that is specific enough, i.e.\n * replaces any occurances of {s} if possible, otherwise returns null.\n * @param {import('./layer/STAC.js').Link} link The web map link.\n * @return {string|null} Specific URL\n */\nexport function getSpecificWebMapUrl(link) {\n    let url = link.href;\n    if (url.includes('{s}')) {\n        if (Array.isArray(link['href:servers']) &&\n            link['href:servers'].length > 0) {\n            const i = (Math.random() * link['href:servers'].length) | 0;\n            url = url.replace('{s}', link['href:servers'][i]);\n        }\n        else {\n            return null;\n        }\n    }\n    return url;\n}\n/**\n * Checks whether the given value is a scalar (string, number, boolean).\n * @param {*} value The value to check\n * @return {boolean} `true` is the value is a scalar, `false` otherwise\n */\nexport function isScalar(value) {\n    return (typeof value === 'string' ||\n        typeof value === 'number' ||\n        typeof value === 'boolean');\n}\n//# sourceMappingURL=util.js.map","/**\n * @module ol/source/GeoTIFF\n */\nimport { Pool, fromBlob as tiffFromBlob, fromUrl as tiffFromUrl, fromUrls as tiffFromUrls, globals as geotiffGlobals, } from 'geotiff';\nimport { error as logError } from 'ol/console.js';\nimport { applyTransform, getCenter, getIntersection } from 'ol/extent.js';\nimport { clamp } from 'ol/math.js';\nimport { fromCode as unitsFromCode } from 'ol/proj/Units.js';\nimport { Projection, createTransformFromCoordinateTransform, get as getCachedProjection, toUserCoordinate, toUserExtent, } from 'ol/proj.js';\nimport DataTile from 'ol/source/DataTile.js';\nimport TileGrid from 'ol/tilegrid/TileGrid.js';\nimport { apply as applyMatrix, create as createMatrix, makeInverse, multiply as multiplyTransform, } from 'ol/transform.js';\nimport { loadProjection } from '../util.js';\n/**\n * Determine if an image type is a mask.\n * See https://www.awaresystems.be/imaging/tiff/tifftags/newsubfiletype.html\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} The image is a mask.\n */\nfunction isMask(image) {\n    const fileDirectory = image.fileDirectory;\n    const type = fileDirectory.NewSubfileType || 0;\n    return (type & 4) === 4;\n}\n/**\n * @param {true|false|'auto'} preference The convertToRGB option.\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} Use the `image.readRGB()` method.\n */\nfunction readRGB(preference, image) {\n    if (!preference) {\n        return false;\n    }\n    if (preference === true) {\n        return true;\n    }\n    if (image.getSamplesPerPixel() !== 3) {\n        return false;\n    }\n    const interpretation = image.fileDirectory.PhotometricInterpretation;\n    const interpretations = geotiffGlobals.photometricInterpretations;\n    return (interpretation === interpretations.CMYK ||\n        interpretation === interpretations.YCbCr ||\n        interpretation === interpretations.CIELab ||\n        interpretation === interpretations.ICCLab);\n}\n/**\n * @typedef {Object} SourceInfo\n * @property {string} [url] URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.\n * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n/**\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\n */\n/**\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\n */\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\nconst STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nconst STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\nconst defaultTileSize = 256;\n/**\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\n */\nlet workerPool;\nfunction getWorkerPool() {\n    if (!workerPool) {\n        workerPool = new Pool();\n    }\n    return workerPool;\n}\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\nfunction getBoundingBox(image) {\n    try {\n        return image.getBoundingBox(true);\n    }\n    catch (_a) {\n        return [0, 0, image.getWidth(), image.getHeight()];\n    }\n}\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\nfunction getOrigin(image) {\n    try {\n        return image.getOrigin().slice(0, 2);\n    }\n    catch (_a) {\n        return [0, image.getHeight()];\n    }\n}\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {Array<number>} The map x and y units per pixel.\n */\nfunction getResolutions(image, referenceImage) {\n    try {\n        return image.getResolution(referenceImage);\n    }\n    catch (_a) {\n        return [\n            referenceImage.getWidth() / image.getWidth(),\n            referenceImage.getHeight() / image.getHeight(),\n        ];\n    }\n}\n/**\n * @async\n * @param {Object<string, any>} geoKeys Geo keys object.\n * @param {string} geoKey The geo key to lookup.\n * @param {string} unitKey The unit key to lookup.\n * @param {boolean} loadMissingProjection Whether to load missing projections.\n * @return {Promise<Projection|null>} The projection.\n */\nasync function getProjectionFromKeys(geoKeys, geoKey, unitKey, loadMissingProjection) {\n    const value = geoKeys[geoKey];\n    if (value && value !== 32767) {\n        const code = 'EPSG:' + value;\n        let projection = getCachedProjection(code);\n        if (!projection && loadMissingProjection) {\n            projection = await loadProjection(code);\n        }\n        if (!projection) {\n            const units = unitsFromCode(geoKeys[unitKey]);\n            if (units) {\n                projection = new Projection({\n                    code: code,\n                    units: units,\n                });\n            }\n        }\n        return projection || null;\n    }\n}\n/**\n * @async\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @param {boolean} loadMissingProjection Whether to load missing projections.\n * @return {Promise<Projection|null>} The image projection.\n */\nasync function getProjection(image, loadMissingProjection) {\n    const geoKeys = image.geoKeys;\n    if (!geoKeys) {\n        return null;\n    }\n    const projection = await getProjectionFromKeys(geoKeys, 'ProjectedCSTypeGeoKey', 'ProjLinearUnitsGeoKey', loadMissingProjection);\n    if (projection) {\n        return projection;\n    }\n    return await getProjectionFromKeys(geoKeys, 'GeographicTypeGeoKey', 'GeogAngularUnitsGeoKey', loadMissingProjection);\n}\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForTIFF(tiff) {\n    return tiff.getImageCount().then(function (count) {\n        const requests = new Array(count);\n        for (let i = 0; i < count; ++i) {\n            requests[i] = tiff.getImage(i);\n        }\n        return Promise.all(requests);\n    });\n}\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @param {Object} options Options for the GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForSource(source, options) {\n    let request;\n    if (source.blob) {\n        request = tiffFromBlob(source.blob);\n    }\n    else if (source.overviews) {\n        request = tiffFromUrls(source.url, source.overviews, options);\n    }\n    else {\n        request = tiffFromUrl(source.url, options);\n    }\n    return request.then(getImagesForTIFF);\n}\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n    if (Array.isArray(expected)) {\n        const length = expected.length;\n        if (!Array.isArray(got) || length != got.length) {\n            const error = new Error(message);\n            rejector(error);\n            throw error;\n        }\n        for (let i = 0; i < length; ++i) {\n            assertEqual(expected[i], got[i], tolerance, message, rejector);\n        }\n        return;\n    }\n    got = /** @type {number} */ (got);\n    if (Math.abs(expected - got) > tolerance * expected) {\n        throw new Error(message);\n    }\n}\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\nfunction getMinForDataType(array) {\n    if (array instanceof Int8Array) {\n        return -128;\n    }\n    if (array instanceof Int16Array) {\n        return -32768;\n    }\n    if (array instanceof Int32Array) {\n        return -2147483648;\n    }\n    if (array instanceof Float32Array) {\n        return 1.2e-38;\n    }\n    return 0;\n}\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\nfunction getMaxForDataType(array) {\n    if (array instanceof Int8Array) {\n        return 127;\n    }\n    if (array instanceof Uint8Array) {\n        return 255;\n    }\n    if (array instanceof Uint8ClampedArray) {\n        return 255;\n    }\n    if (array instanceof Int16Array) {\n        return 32767;\n    }\n    if (array instanceof Uint16Array) {\n        return 65535;\n    }\n    if (array instanceof Int32Array) {\n        return 2147483647;\n    }\n    if (array instanceof Uint32Array) {\n        return 4294967295;\n    }\n    if (array instanceof Float32Array) {\n        return 3.4e38;\n    }\n    return 255;\n}\n/**\n * @typedef {Object} GeoTIFFSourceOptions\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\n * @property {string} [credentials] How credentials shall be handled. See\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\n * By default only a single range is used.\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\n * requested. Only use this when you know the source image to be small enough to fit in memory.\n * @property {number} [blockSize=65536] The block size to use.\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\n */\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\n * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,\n * CIELab, and ICCLab images will automatically be converted to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {import(\"ol/proj.js\").ProjectionLike} [projection] Source projection.  If not provided, the GeoTIFF metadata\n * will be read for projection information.\n * @property {boolean} [loadMissingProjection=false] Whether to attempt to load missing projection definitions.\n * Uses the configured EPSG lookup function, which can be set with {@link module:ol/proj/proj4.setEPSGLookup}.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * **Note for users of the full build**: The `GeoTIFF` source requires the\n * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.\n *\n * @api\n */\nclass GeoTIFFSource extends DataTile {\n    /**\n     * @param {Options} options Data tile options.\n     */\n    constructor(options) {\n        super({\n            state: 'loading',\n            tileGrid: null,\n            projection: options.projection || null,\n            transition: options.transition,\n            interpolate: options.interpolate !== false,\n            wrapX: options.wrapX,\n        });\n        /**\n         * @type {Array<SourceInfo>}\n         * @private\n         */\n        this.sourceInfo_ = options.sources;\n        const numSources = this.sourceInfo_.length;\n        /**\n         * @type {Object}\n         * @private\n         */\n        this.sourceOptions_ = options.sourceOptions;\n        /**\n         * @type {Array<Array<GeoTIFFImage>>}\n         * @private\n         */\n        this.sourceImagery_ = new Array(numSources);\n        /**\n         * @type {Array<Array<GeoTIFFImage>>}\n         * @private\n         */\n        this.sourceMasks_ = new Array(numSources);\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        this.resolutionFactors_ = new Array(numSources);\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        this.samplesPerPixel_;\n        /**\n         * @type {Array<Array<number>>}\n         * @private\n         */\n        this.nodataValues_;\n        /**\n         * @type {Array<Array<GDALMetadata>>}\n         * @private\n         */\n        this.metadata_;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.normalize_ = options.normalize !== false;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.addAlpha_ = false;\n        /**\n         * @type {Error}\n         * @private\n         */\n        this.error_ = null;\n        /**\n         * @type {true|false|'auto'}\n         * @private\n         */\n        this.convertToRGB_ = options.convertToRGB || false;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.loadMissingProjection_ = options.loadMissingProjection || false;\n        this.setKey(this.sourceInfo_.map((source) => source.url).join(','));\n        const self = this;\n        const requests = new Array(numSources);\n        for (let i = 0; i < numSources; ++i) {\n            requests[i] = getImagesForSource(this.sourceInfo_[i], this.sourceOptions_);\n        }\n        Promise.all(requests)\n            .then(function (sources) {\n            return self.configure_(sources);\n        })\n            .catch(function (error) {\n            logError(error);\n            self.error_ = error;\n            self.setState('error');\n        });\n    }\n    /**\n     * @return {Error} A source loading error. When the source state is `error`, use this function\n     * to get more information about the error. To debug a faulty configuration, you may want to use\n     * a listener like\n     * ```js\n     * geotiffSource.on('change', () => {\n     *   if (geotiffSource.getState() === 'error') {\n     *     console.error(geotiffSource.getError());\n     *   }\n     * });\n     * ```\n     */\n    getError() {\n        return this.error_;\n    }\n    /**\n     * Determine the projection of the images in this GeoTIFF.\n     * The default implementation looks at the ProjectedCSTypeGeoKey and the GeographicTypeGeoKey\n     * of each image in turn.\n     * You can override this method in a subclass to support more projections.\n     *\n     * @async\n     * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n     * from a single GeoTIFF.\n     */\n    async determineProjection(sources) {\n        const firstSource = sources[0];\n        for (let i = firstSource.length - 1; i >= 0; --i) {\n            const image = firstSource[i];\n            const projection = await getProjection(image, this.loadMissingProjection_);\n            if (projection) {\n                this.projection = projection;\n                break;\n            }\n        }\n    }\n    /**\n     * Determine any transform matrix for the images in this GeoTIFF.\n     *\n     * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n     * from a single GeoTIFF.\n     */\n    determineTransformMatrix(sources) {\n        const firstSource = sources[0];\n        for (let i = firstSource.length - 1; i >= 0; --i) {\n            const image = firstSource[i];\n            const modelTransformation = image.fileDirectory.ModelTransformation;\n            if (modelTransformation) {\n                // eslint-disable-next-line no-unused-vars\n                const [a, b, c, d, e, f, g, h] = modelTransformation;\n                const matrix = multiplyTransform(multiplyTransform([\n                    1 / Math.sqrt(a * a + e * e),\n                    0,\n                    0,\n                    -1 / Math.sqrt(b * b + f * f),\n                    d,\n                    h,\n                ], [a, e, b, f, 0, 0]), [1, 0, 0, 1, -d, -h]);\n                this.transformMatrix = matrix;\n                this.addAlpha_ = true;\n                break;\n            }\n        }\n    }\n    /**\n     * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n     * must have the same internal tiled structure.\n     * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n     * from a single GeoTIFF.\n     * @private\n     * @async\n     */\n    async configure_(sources) {\n        let extent;\n        let origin;\n        let commonRenderTileSizes;\n        let commonSourceTileSizes;\n        let resolutions;\n        const samplesPerPixel = new Array(sources.length);\n        const nodataValues = new Array(sources.length);\n        const metadata = new Array(sources.length);\n        let minZoom = 0;\n        const sourceCount = sources.length;\n        for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n            const images = [];\n            const masks = [];\n            sources[sourceIndex].forEach((item) => {\n                if (isMask(item)) {\n                    masks.push(item);\n                }\n                else {\n                    images.push(item);\n                }\n            });\n            const imageCount = images.length;\n            if (masks.length > 0 && masks.length !== imageCount) {\n                throw new Error(`Expected one mask per image found ${masks.length} masks and ${imageCount} images`);\n            }\n            let sourceExtent;\n            let sourceOrigin;\n            const sourceTileSizes = new Array(imageCount);\n            const renderTileSizes = new Array(imageCount);\n            const sourceResolutions = new Array(imageCount);\n            nodataValues[sourceIndex] = new Array(imageCount);\n            metadata[sourceIndex] = new Array(imageCount);\n            for (let imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\n                const image = images[imageIndex];\n                const nodataValue = image.getGDALNoData();\n                metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\n                nodataValues[sourceIndex][imageIndex] = nodataValue;\n                const wantedSamples = this.sourceInfo_[sourceIndex].bands;\n                samplesPerPixel[sourceIndex] = wantedSamples\n                    ? wantedSamples.length\n                    : image.getSamplesPerPixel();\n                const level = imageCount - (imageIndex + 1);\n                if (!sourceExtent) {\n                    sourceExtent = getBoundingBox(image);\n                }\n                if (!sourceOrigin) {\n                    sourceOrigin = getOrigin(image);\n                }\n                const imageResolutions = getResolutions(image, images[0]);\n                sourceResolutions[level] = imageResolutions[0];\n                const sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\n                // request larger blocks for untiled layouts\n                if (sourceTileSize[0] !== sourceTileSize[1] &&\n                    sourceTileSize[1] < defaultTileSize) {\n                    sourceTileSize[0] = defaultTileSize;\n                    sourceTileSize[1] = defaultTileSize;\n                }\n                sourceTileSizes[level] = sourceTileSize;\n                const aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\n                renderTileSizes[level] = [\n                    sourceTileSize[0],\n                    sourceTileSize[1] / aspectRatio,\n                ];\n            }\n            if (!extent) {\n                extent = sourceExtent;\n            }\n            else {\n                getIntersection(extent, sourceExtent, extent);\n            }\n            if (!origin) {\n                origin = sourceOrigin;\n            }\n            else {\n                const message = `Origin mismatch for source ${sourceIndex}, got [${sourceOrigin}] but expected [${origin}]`;\n                assertEqual(origin, sourceOrigin, 0, message, this.viewRejector);\n            }\n            if (!resolutions) {\n                resolutions = sourceResolutions;\n                this.resolutionFactors_[sourceIndex] = 1;\n            }\n            else {\n                if (resolutions.length - minZoom > sourceResolutions.length) {\n                    minZoom = resolutions.length - sourceResolutions.length;\n                }\n                const resolutionFactor = resolutions[resolutions.length - 1] /\n                    sourceResolutions[sourceResolutions.length - 1];\n                this.resolutionFactors_[sourceIndex] = resolutionFactor;\n                const scaledSourceResolutions = sourceResolutions.map((resolution) => (resolution *= resolutionFactor));\n                const message = `Resolution mismatch for source ${sourceIndex}, got [${scaledSourceResolutions}] but expected [${resolutions}]`;\n                assertEqual(resolutions.slice(minZoom, resolutions.length), scaledSourceResolutions, 0.02, message, this.viewRejector);\n            }\n            if (!commonRenderTileSizes) {\n                commonRenderTileSizes = renderTileSizes;\n            }\n            else {\n                assertEqual(commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length), renderTileSizes, 0.01, `Tile size mismatch for source ${sourceIndex}`, this.viewRejector);\n            }\n            if (!commonSourceTileSizes) {\n                commonSourceTileSizes = sourceTileSizes;\n            }\n            else {\n                assertEqual(commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length), sourceTileSizes, 0, `Tile size mismatch for source ${sourceIndex}`, this.viewRejector);\n            }\n            this.sourceImagery_[sourceIndex] = images.reverse();\n            this.sourceMasks_[sourceIndex] = masks.reverse();\n        }\n        for (let i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n            const sourceImagery = this.sourceImagery_[i];\n            while (sourceImagery.length < resolutions.length) {\n                sourceImagery.unshift(undefined);\n            }\n        }\n        if (!this.getProjection()) {\n            await this.determineProjection(sources);\n        }\n        this.determineTransformMatrix(sources);\n        this.samplesPerPixel_ = samplesPerPixel;\n        this.nodataValues_ = nodataValues;\n        this.metadata_ = metadata;\n        // decide if we need to add an alpha band to handle nodata\n        outer: for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n            // option 1: source is configured with a nodata value\n            if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\n                this.addAlpha_ = true;\n                break;\n            }\n            if (this.sourceMasks_[sourceIndex].length) {\n                this.addAlpha_ = true;\n                break;\n            }\n            const values = nodataValues[sourceIndex];\n            // option 2: check image metadata for limited bands\n            const bands = this.sourceInfo_[sourceIndex].bands;\n            if (bands) {\n                for (let i = 0; i < bands.length; ++i) {\n                    if (values[bands[i] - 1] !== null) {\n                        this.addAlpha_ = true;\n                        break outer;\n                    }\n                }\n                continue;\n            }\n            // option 3: check image metadata for all bands\n            for (let imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n                if (values[imageIndex] !== null) {\n                    this.addAlpha_ = true;\n                    break outer;\n                }\n            }\n        }\n        let bandCount = this.addAlpha_ ? 1 : 0;\n        for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n            bandCount += samplesPerPixel[sourceIndex];\n        }\n        this.bandCount = bandCount;\n        const tileGrid = new TileGrid({\n            extent: extent,\n            minZoom: minZoom,\n            origin: origin,\n            resolutions: resolutions,\n            tileSizes: commonRenderTileSizes,\n        });\n        this.tileGrid = tileGrid;\n        this.setTileSizes(commonSourceTileSizes);\n        this.setLoader(this.loadTile_.bind(this));\n        this.setState('ready');\n        const zoom = 1;\n        if (resolutions.length === 2) {\n            resolutions = [resolutions[0], resolutions[1], resolutions[1] / 2];\n        }\n        else if (resolutions.length === 1) {\n            resolutions = [resolutions[0] * 2, resolutions[0], resolutions[0] / 2];\n        }\n        let viewExtent = extent;\n        if (this.transformMatrix) {\n            const matrix = makeInverse(createMatrix(), this.transformMatrix.slice());\n            const transformFn = createTransformFromCoordinateTransform((input) => applyMatrix(matrix, input));\n            viewExtent = applyTransform(extent, transformFn);\n        }\n        this.viewResolver({\n            showFullExtent: true,\n            projection: this.projection,\n            resolutions: resolutions,\n            center: toUserCoordinate(getCenter(viewExtent), this.projection),\n            extent: toUserExtent(viewExtent, this.projection),\n            zoom: zoom,\n        });\n    }\n    /**\n     * @param {number} z The z tile index.\n     * @param {number} x The x tile index.\n     * @param {number} y The y tile index.\n     * @param {import('ol/source/DataTile.js').LoaderOptions} options The loader options.\n     * @return {Promise} The composed tile data.\n     * @private\n     */\n    loadTile_(z, x, y, options) {\n        const sourceTileSize = this.getTileSize(z);\n        const sourceCount = this.sourceImagery_.length;\n        const requests = new Array(sourceCount * 2);\n        const nodataValues = this.nodataValues_;\n        const sourceInfo = this.sourceInfo_;\n        const pool = getWorkerPool();\n        for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n            const source = sourceInfo[sourceIndex];\n            const resolutionFactor = this.resolutionFactors_[sourceIndex];\n            const pixelBounds = [\n                Math.round(x * (sourceTileSize[0] * resolutionFactor)),\n                Math.round(y * (sourceTileSize[1] * resolutionFactor)),\n                Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)),\n                Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor)),\n            ];\n            const image = this.sourceImagery_[sourceIndex][z];\n            let samples;\n            if (source.bands) {\n                samples = source.bands.map(function (bandNumber) {\n                    return bandNumber - 1;\n                });\n            }\n            /** @type {number|Array<number>} */\n            let fillValue;\n            if ('nodata' in source && source.nodata !== null) {\n                fillValue = source.nodata;\n            }\n            else {\n                if (!samples) {\n                    fillValue = nodataValues[sourceIndex];\n                }\n                else {\n                    fillValue = samples.map(function (sampleIndex) {\n                        return nodataValues[sourceIndex][sampleIndex];\n                    });\n                }\n            }\n            const readOptions = {\n                window: pixelBounds,\n                width: sourceTileSize[0],\n                height: sourceTileSize[1],\n                samples: samples,\n                fillValue: fillValue,\n                pool: pool,\n                interleave: false,\n                signal: options.signal,\n            };\n            if (readRGB(this.convertToRGB_, image)) {\n                requests[sourceIndex] = image.readRGB(readOptions);\n            }\n            else {\n                requests[sourceIndex] = image.readRasters(readOptions);\n            }\n            // requests after `sourceCount` are for mask data (if any)\n            const maskIndex = sourceCount + sourceIndex;\n            const mask = this.sourceMasks_[sourceIndex][z];\n            if (!mask) {\n                requests[maskIndex] = Promise.resolve(null);\n                continue;\n            }\n            requests[maskIndex] = mask.readRasters({\n                window: pixelBounds,\n                width: sourceTileSize[0],\n                height: sourceTileSize[1],\n                samples: [0],\n                pool: pool,\n                interleave: false,\n            });\n        }\n        return Promise.all(requests)\n            .then(this.composeTile_.bind(this, sourceTileSize))\n            .catch(function (error) {\n            logError(error);\n            throw error;\n        });\n    }\n    /**\n     * @param {import(\"ol/size.js\").Size} sourceTileSize The source tile size.\n     * @param {Array} sourceSamples The source samples.\n     * @return {import(\"ol/DataTile.js\").Data} The composed tile data.\n     * @private\n     */\n    composeTile_(sourceTileSize, sourceSamples) {\n        const metadata = this.metadata_;\n        const sourceInfo = this.sourceInfo_;\n        const sourceCount = this.sourceImagery_.length;\n        const bandCount = this.bandCount;\n        const samplesPerPixel = this.samplesPerPixel_;\n        const nodataValues = this.nodataValues_;\n        const normalize = this.normalize_;\n        const addAlpha = this.addAlpha_;\n        const pixelCount = sourceTileSize[0] * sourceTileSize[1];\n        const dataLength = pixelCount * bandCount;\n        /** @type {Uint8Array|Float32Array} */\n        let data;\n        if (normalize) {\n            data = new Uint8Array(dataLength);\n        }\n        else {\n            data = new Float32Array(dataLength);\n        }\n        let dataIndex = 0;\n        for (let pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n            let transparent = addAlpha;\n            for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n                const source = sourceInfo[sourceIndex];\n                let min = source.min;\n                let max = source.max;\n                let gain, bias;\n                if (normalize) {\n                    const stats = metadata[sourceIndex][0];\n                    if (min === undefined) {\n                        if (stats && STATISTICS_MINIMUM in stats) {\n                            min = parseFloat(stats[STATISTICS_MINIMUM]);\n                        }\n                        else {\n                            min = getMinForDataType(sourceSamples[sourceIndex][0]);\n                        }\n                    }\n                    if (max === undefined) {\n                        if (stats && STATISTICS_MAXIMUM in stats) {\n                            max = parseFloat(stats[STATISTICS_MAXIMUM]);\n                        }\n                        else {\n                            max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n                        }\n                    }\n                    gain = 255 / (max - min);\n                    bias = -min * gain;\n                }\n                for (let sampleIndex = 0; sampleIndex < samplesPerPixel[sourceIndex]; ++sampleIndex) {\n                    const sourceValue = sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n                    let value;\n                    if (normalize) {\n                        value = clamp(gain * sourceValue + bias, 0, 255);\n                    }\n                    else {\n                        value = sourceValue;\n                    }\n                    if (!addAlpha) {\n                        data[dataIndex] = value;\n                    }\n                    else {\n                        let nodata = source.nodata;\n                        if (nodata === undefined) {\n                            let bandIndex;\n                            if (source.bands) {\n                                bandIndex = source.bands[sampleIndex] - 1;\n                            }\n                            else {\n                                bandIndex = sampleIndex;\n                            }\n                            nodata = nodataValues[sourceIndex][bandIndex];\n                        }\n                        const nodataIsNaN = isNaN(nodata);\n                        if ((!nodataIsNaN && sourceValue !== nodata) ||\n                            (nodataIsNaN && !isNaN(sourceValue))) {\n                            transparent = false;\n                            data[dataIndex] = value;\n                        }\n                    }\n                    dataIndex++;\n                }\n                if (!transparent) {\n                    const maskIndex = sourceCount + sourceIndex;\n                    const mask = sourceSamples[maskIndex];\n                    if (mask && !mask[0][pixelIndex]) {\n                        transparent = true;\n                    }\n                }\n            }\n            if (addAlpha) {\n                if (!transparent) {\n                    data[dataIndex] = 255;\n                }\n                dataIndex++;\n            }\n        }\n        return data;\n    }\n}\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"ol/View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\nGeoTIFFSource.prototype.getView;\nexport default GeoTIFFSource;\n//# sourceMappingURL=GeoTIFF.js.map","/**\n * @module ol/source/type\n */\n/**\n * @typedef {import(\"ol/source/GeoTIFF.js\").Options} GeoTIFFOptions\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_GeoTIFF-GeoTIFFSource.html}\n */\n/**\n * @typedef {import(\"ol/source/ImageStatic.js\").Options} ImageStaticOptions\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_ImageStatic-Static.html}\n */\n/**\n * @typedef {import(\"ol/source/TileJSON.js\").Options} TileJSONOptions\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_TileJSON-TileJSON.html}\n */\n/**\n * @typedef {import(\"ol/source/TileWMS.js\").Options} TileWMSOptions\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_TileWMS-TileWMS.html}\n */\n/**\n * @typedef {import(\"ol/source/WMTS.js\").Options} WMTSOptions\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_WMTS-WMTS.html}\n */\n/**\n * @typedef {import(\"ol/source/XYZ.js\").Options} XYZOptions\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_XYZ-XYZ.html}\n */\n/**\n * @typedef {GeoTIFFOptions|ImageStaticOptions|TileJSONOptions|TileWMSOptions|WMTSOptions|XYZOptions|Object<string, *>} SourceOptions\n */\n/**\n * @classdesc\n * The source type for `getSourceOptions`.\n * @api\n */\nclass SourceType {\n    /**\n     * Creates a new SourceType.\n     * @param {string} name The internal string identifier.\n     * @protected\n     * @api\n     */\n    constructor(name) {\n        this.name = name;\n    }\n    /**\n     * Converts to a string.\n     * @return {string} The internal string identifier.\n     * @api\n     */\n    toString() {\n        return this.name;\n    }\n}\n/**\n * GeoTiff\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_GeoTIFF.html}\n * @api\n */\nSourceType.GeoTIFF = new SourceType('GeoTIFF');\n/**\n * Static Image (`ImageStatic`)\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_ImageStatic.html}\n * @api\n */\nSourceType.ImageStatic = new SourceType('ImageStatic');\n/**\n * PMTilesRaster\n * @see {@link https://protomaps.com/docs/pmtiles/}\n * @api\n */\nSourceType.PMTilesRaster = new SourceType('PMTilesRaster');\n/**\n * GeoTiff\n * @see {@link https://protomaps.com/docs/pmtiles/}\n * @api\n */\nSourceType.PMTilesVector = new SourceType('PMTilesVector');\n/**\n * TileJSON\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_TileJSON.html}\n * @api\n */\nSourceType.TileJSON = new SourceType('TileJSON');\n/**\n * WMS (`TileWMS`)\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_TileWMS.html}\n * @api\n */\nSourceType.TileWMS = new SourceType('TileWMS');\n/**\n * WMTS\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_WMTS.html}\n * @api\n */\nSourceType.WMTS = new SourceType('WMTS');\n/**\n * XYZ\n * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_source_XYZ.html}\n * @api\n */\nSourceType.XYZ = new SourceType('XYZ');\nexport default SourceType;\n//# sourceMappingURL=type.js.map","/**\n * @module ol/layer/STAC\n */\nimport { isEmpty } from 'ol/extent.js';\nimport GeoJSON from 'ol/format/GeoJSON.js';\nimport WMTSCapabilities from 'ol/format/WMTSCapabilities.js';\nimport LayerGroup from 'ol/layer/Group.js';\nimport ImageLayer from 'ol/layer/Image.js';\nimport TileLayer from 'ol/layer/Tile.js';\nimport VectorLayer from 'ol/layer/Vector.js';\nimport VectorTileLayer from 'ol/layer/VectorTile.js';\nimport WebGLTileLayer from 'ol/layer/WebGLTile.js';\nimport { transformExtent } from 'ol/proj.js';\n// import GeoTIFF from 'ol/source/GeoTIFF.js';\nimport StaticImage from 'ol/source/ImageStatic.js';\nimport TileJSON from 'ol/source/TileJSON.js';\nimport WMS from 'ol/source/TileWMS.js';\nimport VectorSource from 'ol/source/Vector.js';\nimport VectorTileSource from 'ol/source/VectorTile.js';\nimport WMTS, { optionsFromCapabilities } from 'ol/source/WMTS.js';\nimport XYZ from 'ol/source/XYZ.js';\nimport { PMTilesRasterSource, PMTilesVectorSource } from 'ol-pmtiles';\nimport * as pmtiles from 'pmtiles';\nimport create, { APICollection, Asset, CollectionCollection, Item, ItemCollection, STAC, } from 'stac-js';\nimport { fixGeoJson, toGeoJSON, unionBoundingBox } from 'stac-js/src/geo.js';\nimport { geojsonMediaType } from 'stac-js/src/mediatypes.js';\nimport { isObject } from 'stac-js/src/utils.js';\nimport ErrorEvent from '../events/ErrorEvent.js';\n// todo: temporary fix for https://github.com/openlayers/openlayers/issues/17153\nimport GeoTIFF from '../source/GeoTIFF.js';\nimport SourceType from '../source/type.js';\nimport { LABEL_EXTENSION, defaultBoundsStyle, defaultCollectionStyle, getBoundsStyle, getGeoTiffSourceInfoFromAsset, getProjection, getSpecificWebMapUrl, isScalar, } from '../util.js';\n/**\n * @typedef {import(\"ol/extent.js\").Extent} Extent\n */\n/**\n * @typedef {import(\"ol/layer/Layer.js\").default} Layer\n */\n/**\n * @typedef {import(\"stac-js\").Link} Link\n */\n/**\n * @typedef {import(\"ol/Map.js\").default} Map\n */\n/**\n * @typedef {import('ol/style/Style.js').default} Style\n */\n/**\n * @typedef {import('../source/type.js').SourceOptions} SourceOptions\n */\n/**\n * @typedef {Object} Options\n * @property {string} [url] The STAC URL. Any of `url` and `data` must be provided.\n * Can also be used as url for data, if it is absolute and doesn't contain a self link.\n * Don't use this is you pass in a stac-js object as `data`, set the url manually through\n * `setAbsoluteUrl` on the stac-js object before passing it in.\n * @property {STAC|Asset|Object} [data] The STAC metadata. Any of `url` and `data` must be provided.\n * `data` take precedence over `url`.\n * @property {APICollection|Object|Array<STAC|Object>|null} [children=null] For STAC Catalogs and Collections, any child entites\n * to show. Can be STAC ItemCollections (as ItemCollection or GeoJSON FeatureCollection) or a list of STAC entities.\n * @property {Options} [childrenOptions={}] The the given children, apply the given options.\n * @property {Array<string|Asset>|null} [assets=null] The selector for the assets to be rendered,\n * only for STAC Items and Collections.\n * This can be an array of strings corresponding to asset keys or Asset objects.\n * null shows the default asset, an empty array shows no asset.\n * @property {Array<number>} [bands] The (one-based) bands to show.\n * @property {function(SourceType, SourceOptions, (Asset|Link)):(SourceOptions|Promise<SourceOptions>)} [getSourceOptions]\n * Optional function that can be used to configure the underlying sources. The function can do any additional work\n * and return the completed options or a promise for the same. The function will be called with the current source options\n * and the STAC Asset or Link.\n * This can be useful for adding auth information such as an API token, either via query parameter or HTTP headers.\n * Please be aware that sending HTTP headers may not be supported by all sources.\n * @property {boolean} [displayFootprint=true] Allows to hide the footprints (bounding box/geometry) of the STAC object\n * by default.\n * @property {boolean} [displayGeoTiffByDefault=false] Allow to choose non-cloud-optimized GeoTiffs as default image to show,\n * which might not work well for larger files or larger amounts of files.\n * @property {boolean} [displayPreview=false] Allow to display preview images that a browser can display (e.g. PNG, JPEG),\n * i.e. assets with any of the roles `thumbnail`, `overview`, or a link with relation type `preview`.\n * The previews are usually not covering the full extents and as such may be placed incorrectly on the map.\n * For performance reasons, it is recommended to enable this option if you pass in STAC API Items instead of `displayOverview`.\n * @property {boolean} [displayOverview=true] Allow to display COGs and, if `displayGeoTiffByDefault` is enabled, GeoTiffs,\n * usually an asset with role `overview` or `visual`.\n * @property {string|boolean|Array<Link|string>} [displayWebMapLink=false] Allow to display a layer\n * based on the information provided through the web map links extension.\n * If an array of links or link ids (property `id` in a Link Object) is provided, all corresponding layers will be shown.\n * If set to true or to a specific type of web map link (`pmtiles`, `tilejson`, `wms`, `wmts`, `xyz`),\n * it lets this library choose a web map link to show, but only if no other data is shown.\n * To disable the functionality set this to `false`.\n * @property {Style} [boundsStyle] The style for the overall bounds / footprint.\n * @property {Style} [collectionStyle] The style for individual children in a list of STAC Items or Collections.\n * @property {null|string} [crossOrigin] For thumbnails: The `crossOrigin` attribute for loaded images / tiles.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {function((Asset|Link)):Promise<string>|string|null} [buildTileUrlTemplate=null] A function that generates a URL template for a tile server (XYZ),\n * which will be used instead of the client-side GeoTIFF rendering (except if `useTileLayerAsFallback` is `true`).\n * The function provided can return a promise (i.e. be async) or a string.\n * @property {boolean} [useTileLayerAsFallback=false] Uses the given URL template only when the client-side GeoTIFF rendering fails.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`. `stac` and `bounds` are reserved and may be overridden.\n * @property {boolean} [disableMigration=false] Disable the migration of the STAC object to the latest version.\n * Only enable this if you are sure that the STAC object is already in the latest version.\n * @property {function(string,string):(*)} [httpRequestFn=null] Sets a custom function to make HTTP requests with.\n * The first parameter is the URL to request and the output is a promise that resolves with the response body.\n * The second parameter is the return type, either `json` (default) or `text`.\n */\n/**\n * @classdesc\n * Renders STAC entities such as STAC Items, Collectons or lists of them as returned by APIs.\n * The layers created by this LayerGroup all have a 'stac' value that can be retrieved using `layer.get('stac')`.\n *\n * @extends LayerGroup\n * @fires sourceready\n * @fires layersready\n * @fires ErorEvent#event:error\n * @api\n */\nclass STACLayer extends LayerGroup {\n    /**\n     * @param {Options} options Layer options.\n     * @api\n     */\n    constructor(options) {\n        const superOptions = {};\n        [\n            'opacity',\n            'visible',\n            'zIndex',\n            'minResolution',\n            'maxResolution',\n            'minZoom',\n            'maxZoom',\n            'properties',\n        ].forEach((key) => (superOptions[key] = options[key]));\n        super(superOptions);\n        /**\n         * @type {function(SourceType, SourceOptions, (Asset|Link)):(SourceOptions|Promise<SourceOptions>)}\n         * @private\n         */\n        this.getSourceOptions_ = options.getSourceOptions;\n        /**\n         * @type {Array<STAC>|null}\n         * @private\n         */\n        this.children_ = null;\n        /**\n         * @type {Options}\n         * @private\n         */\n        this.childrenOptions_ = options.childrenOptions || {};\n        /**\n         * @type {Array<Asset>|null}\n         * @private\n         */\n        this.assets_ = null;\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        this.bands_ = [];\n        /**\n         * @type {string|null}\n         * @private\n         */\n        this.crossOrigin_ = options.crossOrigin || null;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.displayFootprint_ = options.displayFootprint === false ? false : true;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.displayGeoTiffByDefault_ = Boolean(options.displayGeoTiffByDefault);\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.displayPreview_ = Boolean(options.displayPreview);\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.displayOverview_ = options.displayOverview === false ? false : true;\n        /**\n         * @type {string|boolean|Array<Link|string>}\n         */\n        this.displayWebMapLink_ = options.displayWebMapLink || false;\n        /**\n         * @type {function((Asset|Link)):Promise<string>|string|null}\n         * @private\n         */\n        this.buildTileUrlTemplate_ = options.buildTileUrlTemplate || null;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.useTileLayerAsFallback_ = options.useTileLayerAsFallback || false;\n        /**\n         * @type {Style}\n         * @private\n         */\n        this.boundsStyle_ = options.boundsStyle || defaultBoundsStyle;\n        /**\n         * @type {Style}\n         * @private\n         */\n        this.collectionStyle_ = options.collectionStyle || defaultCollectionStyle;\n        /**\n         * @type {VectorLayer|null}\n         * @private\n         */\n        this.boundsLayer_ = null;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.disableMigration_ = options.disableMigration || false;\n        /**\n         * @type {Map|null}\n         * @private\n         */\n        this.map_ = null;\n        /**\n         * @type {Array<string|ErrorEvent>}\n         * @private\n         */\n        this.eventQueue_ = [];\n        if (options.httpRequestFn) {\n            this.fetch_ = options.httpRequestFn;\n        }\n        if (options.data) {\n            try {\n                this.configure_(options.data, options.url, options.children, options.assets, options.bands);\n            }\n            catch (error) {\n                this.handleError_(error);\n            }\n            return;\n        }\n        if (!options.url) {\n            throw new Error('Either url or data must be provided');\n        }\n        this.fetch_(options.url)\n            .then((data) => this.configure_(data, options.url, options.children, options.assets, options.bands))\n            .catch((error) => this.handleError_(error));\n    }\n    /**\n     * Default function make HTTP requests with.\n     *\n     * @param {string} url The URL to request and the output is a promise that resolves with the response body.\n     * @param {string} responseType The return type, either `json` (default) or `text`.\n     * @return {Promise<*>} The (parsed) response body.\n     */\n    async fetch_(url, responseType = 'json') {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`Unexpected response from ${url}: ${response.status}`);\n        }\n        if (responseType === 'json') {\n            return await response.json();\n        }\n        if (responseType === 'text') {\n            return await response.text();\n        }\n        return null;\n    }\n    /**\n     * Returns the vector layer that visualizes the bounds / footprint.\n     * @return {VectorLayer|null} The vector layer for the bounds\n     * @api\n     */\n    getBoundsLayer() {\n        return this.boundsLayer_;\n    }\n    /**\n     * Returns `true` if the layer shows nothing.\n     *\n     * This method should be called after the layersready event only.\n     *\n     * @return {boolean} Is the layer empty?\n     * @api\n     */\n    isEmpty() {\n        var _a;\n        const count = this.getLayers().getLength();\n        if (count > 1) {\n            return false;\n        }\n        const bbox = (_a = this.getData()) === null || _a === void 0 ? void 0 : _a.getBoundingBox();\n        if (!bbox || isEmpty(bbox)) {\n            return true;\n        }\n        return !this.boundsLayer_ || !this.displayFootprint_;\n    }\n    /**\n     * @param {Error} error The error.\n     * @private\n     */\n    handleError_(error) {\n        /**\n         * Error event.\n         *\n         * @event ErorEvent#event:error\n         * @type {Object}\n         * @property {Error} error - Provides the original error.\n         */\n        this.dispatch_(new ErrorEvent(error));\n    }\n    /**\n     * @param {STAC|Asset|Object} data The STAC data.\n     * @param {string} url The url to the data.\n     * @param {APICollection|Object|Array<STAC>|string|null} children The child STAC entities to show.\n     * @param {Array<Asset|string>|null} assets The assets to show.\n     * @param {Array<number>} bands The (one-based) bands to show.\n     * @private\n     */\n    configure_(data, url = null, children = null, assets = null, bands = []) {\n        let stac;\n        if (data instanceof Asset || data instanceof STAC) {\n            stac = data;\n        }\n        else {\n            stac = create(data, !this.disableMigration_);\n            if (url && url.includes('://')) {\n                stac.setAbsoluteUrl(url);\n            }\n        }\n        this.set('stac', stac);\n        this.bands_ = bands;\n        this.boundsLayer_ = this.addFootprint_();\n        const updateBoundsStyle = () => {\n            if (this.boundsLayer_) {\n                this.boundsLayer_.setStyle(getBoundsStyle(this.boundsStyle_, this));\n            }\n        };\n        this.getLayers().on('add', updateBoundsStyle);\n        this.getLayers().on('remove', updateBoundsStyle);\n        const errorHandler = (error) => this.handleError_(error);\n        const promises = [];\n        if (children) {\n            promises.push(this.setChildren(children, null, false).catch(errorHandler));\n        }\n        if (assets) {\n            promises.push(this.setAssets(assets, false).catch(errorHandler));\n        }\n        Promise.all(promises).then(() => this.updateLayers().catch(errorHandler));\n        /**\n         * Invoked once the STAC entity is loaded and available.\n         *\n         * @event sourceready\n         */\n        this.dispatch_('sourceready');\n    }\n    /**\n     * Dispatch an event.\n     * Move it to the queue if the map is not yet set.\n     * This is necessary as otherwise some events would be\n     * dispatched before someone could listen to them.\n     *\n     * @param {string|ErrorEvent} event The event.\n     * @private\n     */\n    dispatch_(event) {\n        this.eventQueue_.push(event);\n        this.flush_();\n    }\n    /**\n     * Flush all events.\n     * @private\n     */\n    flush_() {\n        if (this.map_) {\n            for (const event of this.eventQueue_) {\n                this.dispatchEvent(event);\n            }\n            this.eventQueue_ = [];\n        }\n    }\n    /**\n     * Set the map and flush all events.\n     * The events should only be flushed once the map is set, otherwise some\n     * functions such as getExtent() return no meaningul values.\n     *\n     * @param {Map} map The map\n     */\n    setMap_(map) {\n        if (this.map_ === map) {\n            return;\n        }\n        this.map_ = map;\n        this.flush_();\n    }\n    /**\n     * @param {Array<STAC>} collection The list of STAC entities to show.\n     * @param {Options} [options] Options for the children.\n     * @return {Promise} Resolves when complete.\n     * @private\n     */\n    async addChildren_(collection, options = {}) {\n        const promises = collection.map((obj) => {\n            const defaultOptions = {\n                data: obj,\n                crossOrigin: this.crossOrigin_,\n                boundsStyle: this.collectionStyle_,\n                displayGeoTiffByDefault: this.displayGeoTiffByDefault_,\n                displayOverview: this.displayOverview_,\n                displayPreview: this.displayPreview_,\n                displayFootprint: this.displayFootprint_,\n                useTileLayerAsFallback: this.useTileLayerAsFallback_,\n                buildTileUrlTemplate: this.buildTileUrlTemplate_,\n            };\n            const subgroup = new STACLayer(Object.assign(defaultOptions, options));\n            // If no data is given, but items are provided, then we don't get a map from the\n            // footprint layer so we need to get it from this new STAC Layer so that extent\n            // calculations etc. work.\n            // @ts-ignore\n            subgroup.on('sourceready', () => {\n                if (subgroup.map_) {\n                    this.setMap_(subgroup.map_);\n                }\n            });\n            this.addLayer_(subgroup, null);\n            return subgroup;\n        });\n        return await Promise.all(promises);\n    }\n    /**\n     * @param {Asset|Link} [image] A STAC Link or Asset\n     * @return {Promise<ImageLayer|undefined>} Resolves with am ImageLayer or udnefined when complete.\n     * @private\n     */\n    async addPreviewImage_(image) {\n        const projection = await getProjection(image, 'EPSG:4326');\n        const bboxes = image.getContext().getBoundingBoxes();\n        if (bboxes.length !== 1) {\n            return;\n        }\n        const bbox = bboxes[0];\n        /**\n         * @type {import(\"ol/source/ImageStatic.js\").Options}\n         */\n        let options = {\n            url: image.getAbsoluteUrl(),\n            projection,\n            imageExtent: transformExtent(bbox, 'EPSG:4326', projection),\n            crossOrigin: this.crossOrigin_,\n        };\n        if (this.getSourceOptions_) {\n            // @ts-ignore\n            options = await this.getSourceOptions_(SourceType.ImageStatic, options, image);\n        }\n        const layer = new ImageLayer({\n            source: new StaticImage(options),\n        });\n        this.addLayer_(layer, image);\n        return layer;\n    }\n    /**\n     * Adds a layer for a link that implements the web-map-links extension.\n     * Supports: PMTiles, TileJSON, WMS, WMTS, XYZ\n     * @see https://github.com/stac-extensions/web-map-links\n     * @param {Link} link A web map link\n     * @return {Promise<Array<Layer>|undefined>} Resolves with a list of layers or undefined when complete.\n     * @api\n     */\n    async addLayerForLink(link) {\n        // Replace any occurances of {s} if possible, otherwise return\n        const url = getSpecificWebMapUrl(link);\n        if (!url) {\n            return;\n        }\n        const options = {\n            attributions: link.getMetadata('attribution') ||\n                this.getData().getMetadata('attribution'),\n            crossOrigin: this.crossOrigin_,\n            url,\n        };\n        const updateOptions = async (type, options) => {\n            if (this.getSourceOptions_) {\n                options = await this.getSourceOptions_(type, options, link);\n            }\n            return options;\n        };\n        const sources = [];\n        switch (link.rel) {\n            case 'pmtiles':\n                const p = new pmtiles.PMTiles(options.url);\n                const headers = await p.getHeader();\n                let source;\n                switch (headers.tileType) {\n                    case pmtiles.TileType.Mvt:\n                        source = new PMTilesVectorSource(await updateOptions(SourceType.PMTilesVector, options));\n                        break;\n                    case pmtiles.TileType.Avif:\n                    case pmtiles.TileType.Jpeg:\n                    case pmtiles.TileType.Png:\n                    case pmtiles.TileType.Webp:\n                        source = new PMTilesRasterSource(await updateOptions(SourceType.PMTilesRaster, options));\n                        break;\n                    default:\n                        return; // Unsupported\n                }\n                sources.push(source);\n                break;\n            case 'tilejson':\n                sources.push(new TileJSON(await updateOptions(SourceType.TileJSON, options)));\n                break;\n            case 'wms':\n                if (!Array.isArray(link['wms:layers'])) {\n                    break;\n                }\n                for (const i in link['wms:layers']) {\n                    const layers = link['wms:layers'][i] || '';\n                    let styles = '';\n                    if (Array.isArray(link['wms:styles']) &&\n                        typeof link['wms:styles'][i] === 'string') {\n                        styles = link['wms:styles'][i];\n                    }\n                    const params = Object.assign({\n                        LAYERS: layers,\n                        STYLES: styles,\n                    }, link['wms:dimensions']);\n                    if (typeof link['wms:transparent'] === 'boolean') {\n                        params.TRANSPARENT = String(link['wms:transparent']);\n                    }\n                    if (typeof link.type === 'string' && link.type.startsWith('image/')) {\n                        params.FORMAT = link.type;\n                    }\n                    const wmsOptions = await updateOptions(SourceType.TileWMS, Object.assign({}, options, { params }));\n                    sources.push(new WMS(wmsOptions));\n                }\n                break;\n            case 'wmts':\n                const wmtsCapabilities = await this.getWmtsCapabilities_(url, link['wmts:encoding']);\n                if (!wmtsCapabilities) {\n                    return;\n                }\n                let layers = [];\n                if (Array.isArray(link['wmts:layer'])) {\n                    layers = link['wmts:layer'];\n                }\n                else if (typeof link['wmts:layer'] === 'string') {\n                    layers = [link['wmts:layer']];\n                }\n                for (const layer of layers) {\n                    let wmtsOptions = Object.assign({}, options, {\n                        layer,\n                        requestEncoding: link['wmts:encoding'] === 'rest' ? 'REST' : 'KVP',\n                    });\n                    if (typeof link.type === 'string' && link.type.startsWith('image/')) {\n                        wmtsOptions.format = link.type;\n                    }\n                    wmtsOptions = await updateOptions(SourceType.WMTS, wmtsOptions);\n                    const opts = optionsFromCapabilities(wmtsCapabilities, wmtsOptions);\n                    if (opts === null) {\n                        continue;\n                    }\n                    if (typeof link.uriTemplate === 'string') {\n                        let uriTemplate = link.uriTemplate;\n                        const vars = isObject(link.variables) ? link.variables : {};\n                        for (const key in vars) {\n                            const schema = vars[key];\n                            let value;\n                            if (isScalar(schema.const)) {\n                                value = schema.const;\n                            }\n                            else if (isScalar(schema.default)) {\n                                value = schema.default;\n                            }\n                            else if (Array.isArray(schema.enum) && schema.enum.length > 0) {\n                                value = schema.enum[0];\n                            }\n                            if (typeof value !== 'undefined') {\n                                uriTemplate = uriTemplate.replaceAll(`{${key}}`, String(value));\n                            }\n                            else {\n                                continue; // We don't know which value to use, so we can't visualize the layer\n                            }\n                        }\n                        delete opts.urls;\n                        opts.url = uriTemplate;\n                    }\n                    sources.push(new WMTS(opts));\n                }\n                break;\n            case 'xyz':\n                sources.push(new XYZ(await updateOptions(SourceType.XYZ, options)));\n                break;\n            default:\n                return;\n        }\n        return sources.map((source) => {\n            let layer;\n            if (source instanceof VectorTileSource) {\n                layer = new VectorTileLayer({\n                    source,\n                    declutter: true,\n                });\n            }\n            else if (source instanceof PMTilesRasterSource) {\n                layer = new WebGLTileLayer({ source });\n            }\n            else {\n                layer = new TileLayer({ source });\n            }\n            this.addLayer_(layer, link);\n            return layer;\n        });\n    }\n    /**\n     * @param {Asset} [asset] A STAC Asset\n     * @return {Promise<Layer|undefined>} Resolves with a Layer or undefined when complete.\n     * @private\n     */\n    async addGeoTiff_(asset) {\n        if (this.buildTileUrlTemplate_ && !this.useTileLayerAsFallback_) {\n            return await this.addTileLayerForImagery_(asset);\n        }\n        const sourceInfo = getGeoTiffSourceInfoFromAsset(asset, this.bands_);\n        /**\n         * todo: temporary fix for https://github.com/openlayers/openlayers/issues/17153\n         * @type {import(\"../source/GeoTIFF.js\").Options}\n         */\n        let options = {\n            sources: [sourceInfo],\n            convertToRGB: 'auto',\n            loadMissingProjection: true,\n        };\n        const projection = await getProjection(asset);\n        if (projection) {\n            options.projection = projection;\n        }\n        if (this.getSourceOptions_) {\n            // @ts-ignore\n            options = await this.getSourceOptions_(SourceType.GeoTIFF, options, asset);\n        }\n        const source = new GeoTIFF(options);\n        const status = new Promise((resolve, reject) => {\n            source.on('error', reject);\n            source.on('change', () => {\n                // see https://github.com/openlayers/openlayers/issues/14926\n                if (source.getState() === 'error') {\n                    reject(source.getError());\n                }\n                else {\n                    resolve();\n                }\n            });\n        });\n        try {\n            await status;\n            const layer = new WebGLTileLayer({ source });\n            this.addLayer_(layer, asset);\n            return layer;\n        }\n        catch (error) {\n            if (this.useTileLayerAsFallback_) {\n                return await this.addTileLayerForImagery_(asset);\n            }\n            this.handleError_(error);\n        }\n    }\n    /**\n     * @param {Asset|Link} [data] A STAC Asset or Link\n     * @return {Promise<TileLayer>} Resolves with a TileLayer when complete.\n     * @private\n     */\n    async addTileLayerForImagery_(data) {\n        let url = this.buildTileUrlTemplate_(data);\n        if (url instanceof Promise) {\n            url = await url;\n        }\n        /**\n         * @type {import(\"ol/source/XYZ.js\").Options}\n         */\n        let options = {\n            crossOrigin: this.crossOrigin_,\n            url,\n        };\n        if (this.getSourceOptions_) {\n            options = await this.getSourceOptions_(SourceType.XYZ, options, data);\n        }\n        const layer = new TileLayer({\n            source: new XYZ(options),\n        });\n        this.addLayer_(layer, data);\n        return layer;\n    }\n    /**\n     * @param {Layer|LayerGroup} [layer] A Layer to add to the LayerGroup\n     * @param {import(\"stac-js\").STACObject} [data] The STAC object, can be any class exposed by stac-js\n     * @param {number} [zIndex] The z-index for the layer\n     * @private\n     */\n    addLayer_(layer, data = null, zIndex = 0) {\n        if (data) {\n            layer.set('stac', data);\n        }\n        layer.setZIndex(zIndex);\n        this.getLayers().push(layer);\n    }\n    /**\n     * @return {VectorLayer|null} The vector layer showing the geometry/bbox.\n     * @private\n     */\n    addFootprint_() {\n        let geojson = null;\n        const data = this.getData();\n        if (data.isItemCollection() || data.isCollectionCollection()) {\n            geojson = toGeoJSON(data.getBoundingBox());\n        }\n        else {\n            geojson = data.toGeoJSON();\n        }\n        if (geojson) {\n            const layer = this.createGeoJsonLayer_(geojson, getBoundsStyle(this.boundsStyle_, this), this.displayFootprint_);\n            layer.set('bounds', true);\n            layer.on('change', () => this.setMap_(layer.getMapInternal()));\n            this.addLayer_(layer, data, 1);\n            return layer;\n        }\n        return null;\n    }\n    /**\n     * @param {Asset} [asset] A STAC Asset\n     * @return {Promise<Layer|undefined>} Resolves with a Layer or undefined when complete.\n     * @private\n     */\n    async addGeoJson_(asset) {\n        try {\n            const geojson = await this.fetch_(asset.getAbsoluteUrl());\n            const layer = this.createGeoJsonLayer_(geojson);\n            this.addLayer_(layer, asset);\n            return layer;\n        }\n        catch (error) {\n            this.handleError_(error);\n        }\n    }\n    /**\n     * Creates a GeoJSON vector layer from the given GeoJSON object.\n     *\n     * @param {GeoJSON} [geojson] The GeoJSON object.\n     * @param {Style} [style] The style for the layer.\n     * @param {boolean} [visible] Whether the layer is visible.\n     * @return {VectorLayer} The new vector layer.\n     * @private\n     */\n    createGeoJsonLayer_(geojson, style = null, visible = true) {\n        const format = new GeoJSON();\n        const source = new VectorSource({\n            format,\n            loader: (extent, resolution, projection) => {\n                geojson = fixGeoJson(geojson);\n                const features = format.readFeatures(geojson, {\n                    featureProjection: projection,\n                });\n                source.addFeatures(features);\n            },\n        });\n        if (!style) {\n            style = defaultCollectionStyle;\n        }\n        return new VectorLayer({ source, style, visible });\n    }\n    /**\n     * Adds GeoJSON labels and GeoTIFF source imagery to the map based on the label extension.\n     *\n     * @return {Promise<Layer|undefined>} The layer added to the map.\n     * @private\n     */\n    async addLabelExtension_() {\n        const data = this.getData();\n        if (!(data instanceof Item)) {\n            return;\n        }\n        // determine the asset with the geojson labels\n        let assets = data.getAssetsWithRoles(['labels', 'labels-vector'], true);\n        let labelAsset;\n        if (assets.length > 1) {\n            labelAsset = assets.find((asset) => asset.roles.includes('labels-vector'));\n        }\n        if (!labelAsset) {\n            labelAsset = data.getAsset('vector_labels');\n        }\n        if (!labelAsset) {\n            assets = data\n                .getAssets()\n                .filter((asset) => asset.type === geojsonMediaType && !asset.roles);\n            if (assets.length === 1) {\n                labelAsset = assets[0];\n            }\n        }\n        // Add the source imagery\n        const sourceLinks = data.getLinksWithRels(['source']);\n        if (labelAsset && sourceLinks.length > 0) {\n            const promises = sourceLinks.map(async (link) => {\n                try {\n                    const response = await this.fetch_(link.getAbsoluteUrl());\n                    const stac = create(response);\n                    return stac;\n                }\n                catch (error) {\n                    this.handleError_(error);\n                    return null;\n                }\n            });\n            const items = (await Promise.all(promises)).filter((item) => item instanceof STAC);\n            await this.addChildren_(items, { displayFootprint: false });\n        }\n        // Add the GeoJSON labels\n        try {\n            await this.addGeoJson_(labelAsset);\n        }\n        catch (error) {\n            this.handleError_(error);\n        }\n    }\n    /**\n     * Update the layers shown manually based on the current configuration.\n     * Usually this doesn't need to be called manually.\n     * @param {boolean} [emit] Whether to emit the `layersready` event once the layers are updated.\n     * @return {Promise} Resolves once the layers are updated.\n     * @api\n     */\n    async updateLayers(emit = true) {\n        // Remove old layers\n        const oldLayers = this.getLayers();\n        for (let i = oldLayers.getLength() - 1; i >= 0; i--) {\n            const layer = oldLayers.item(i);\n            if (layer.get('stac') && !layer.get('bounds')) {\n                oldLayers.removeAt(i);\n            }\n        }\n        // Add layers by priority\n        const data = this.getData();\n        // Show the web map links provided by the user\n        if (Array.isArray(this.displayWebMapLink_)) {\n            const promises = this.getWebMapLinks().map(async (link) => await this.addLayerForLink(link));\n            await Promise.all(promises);\n        }\n        // Show children if provided\n        if (this.children_) {\n            await this.addChildren_(this.children_, this.childrenOptions_);\n        }\n        // Show the assets provided by the user\n        const assets = this.getAssets();\n        if (assets) {\n            const promises = assets.map(async (ref) => {\n                if (!ref) {\n                    return;\n                }\n                if (ref.type === geojsonMediaType) {\n                    return await this.addGeoJson_(ref);\n                }\n                if (ref.isGeoTIFF()) {\n                    return await this.addGeoTiff_(ref);\n                }\n                if (ref.canBrowserDisplayImage()) {\n                    return await this.addPreviewImage_(ref);\n                }\n            });\n            await Promise.all(promises);\n        }\n        // If the user didn't provide any specific asset/map link/children to show,\n        // choose a sensible default visualization\n        if (this.hasOnlyBounds()) {\n            // Show the ItemCollection/CollectionCollection entries\n            if (data instanceof APICollection) {\n                await this.addChildren_(data.getAll(), this.childrenOptions_);\n            }\n            else if (data instanceof STAC) {\n                // Show label extension\n                if (data.isItem() &&\n                    data.supportsExtension(LABEL_EXTENSION) &&\n                    data.getMetadata('label:type') === 'vector') {\n                    await this.addLabelExtension_();\n                    if (emit) {\n                        this.dispatch_('layersready');\n                    }\n                    return;\n                }\n                // Show web map links\n                const links = this.getWebMapLinks();\n                if (links.length > 0) {\n                    await this.addLayerForLink(links[0]);\n                }\n                else {\n                    // Find an asset that we can visualize\n                    const geotiff = data.getDefaultGeoTIFF(true, !this.displayGeoTiffByDefault_);\n                    let layer;\n                    // Try to visualize the default GeoTIFF first\n                    if (geotiff && this.displayOverview_) {\n                        layer = await this.addGeoTiff_(geotiff);\n                    }\n                    // If no GeoTIFF is available or it can't be shown (e.g. error),\n                    // try to visualize the default thumbnail\n                    if (this.displayPreview_ && (!geotiff || !layer)) {\n                        // This may return Links or Assets\n                        const thumbnails = data.getThumbnails(true, 'overview');\n                        if (thumbnails.length > 0) {\n                            await this.addPreviewImage_(thumbnails[0]);\n                        }\n                    }\n                }\n            }\n        }\n        if (emit) {\n            this.dispatch_('layersready');\n        }\n    }\n    /**\n     * Indicates whether the LayerGroup shows only the bounds layer (i.e. no imagery/tile layers).\n     * @return {boolean} `true` if only the bounds layer is shown, `false` otherwise.\n     * @api\n     */\n    hasOnlyBounds() {\n        const boundsLayer = this.getBoundsLayer();\n        const imgLayer = this.getLayersArray().find((layer) => layer !== boundsLayer);\n        return typeof imgLayer === 'undefined';\n    }\n    /**\n     * Returns all potential web map links based on the given value for `displayWebMapLink`.\n     * @return {Array<Link>} An array of links.\n     * @api\n     */\n    getWebMapLinks() {\n        const data = this.getData();\n        if (data instanceof Asset) {\n            return [];\n        }\n        let types = ['xyz', 'tilejson', 'pmtiles', 'wmts', 'wms']; // This also defines the priority\n        if (typeof this.displayWebMapLink_ === 'string') {\n            types = [this.displayWebMapLink_];\n        }\n        let mapLinks = data.getLinksWithRels(types);\n        if (Array.isArray(this.displayWebMapLink_)) {\n            mapLinks = this.displayWebMapLink_\n                .map((link) => {\n                if (typeof link === 'string') {\n                    const match = mapLinks.find((candidate) => candidate.id === link);\n                    if (match) {\n                        return match;\n                    }\n                    return null;\n                }\n                return link;\n            })\n                .filter((link) => !!link);\n        }\n        else {\n            mapLinks.sort((a, b) => {\n                const prioA = types.indexOf(a.rel);\n                const prioB = types.indexOf(b.rel);\n                return prioA - prioB;\n            });\n        }\n        return mapLinks;\n    }\n    /**\n     * Update the assets to be rendered.\n     * @param {Array<string|Asset>|null} assets The assets to show.\n     * @param {boolean} [updateLayers] Whether to update the layers right away.\n     * @return {Promise} Resolves when all assets are rendered.\n     * @api\n     */\n    async setAssets(assets, updateLayers = true) {\n        if (assets === this.assets_) {\n            return;\n        }\n        if (Array.isArray(assets)) {\n            const data = this.getData();\n            this.assets_ = assets.map((asset) => {\n                if (data instanceof STAC && typeof asset === 'string') {\n                    return data.getAsset(asset);\n                }\n                if (!(asset instanceof Asset)) {\n                    return new Asset(asset);\n                }\n                return asset;\n            });\n        }\n        else {\n            this.assets_ = null;\n        }\n        if (updateLayers) {\n            await this.updateLayers();\n        }\n    }\n    /**\n     * Updates the children STAC entities to be rendered.\n     *\n     * If an object is passed, it must be a GeoJSON FeatureCollection.\n     *\n     * @param {APICollection|Object|Array<STAC|Object>|null} childs The children to show.\n     * @param {Options|null} [options] Optionally, new STACLayer options for the children. Only applies if `children` are given.\n     * @param {boolean} [updateLayers] Whether to update the layers right away.\n     * @return {Promise} Resolves when all items are rendered.\n     * @api\n     */\n    async setChildren(childs, options = null, updateLayers = true) {\n        if (childs instanceof ItemCollection) {\n            this.children_ = childs.getAll();\n        }\n        else if (childs instanceof CollectionCollection) {\n            this.children_ = childs.getAll();\n        }\n        else if (isObject(childs) && childs.type === 'FeatureCollection') {\n            this.children_ = create(childs, !this.disableMigration_).getAll();\n        }\n        else if (Array.isArray(childs)) {\n            this.children_ = childs.map((child) => {\n                if (child instanceof STAC) {\n                    return child;\n                }\n                return create(child, !this.disableMigration_);\n            });\n        }\n        else {\n            this.children_ = null; // Invalid input\n        }\n        if (this.children_ && this.children_.length === 0) {\n            this.children_ = null;\n        }\n        if (this.children_ && isObject(options)) {\n            this.childrenOptions_ = options;\n        }\n        if (updateLayers) {\n            await this.updateLayers();\n        }\n    }\n    /**\n     * Get the STAC object.\n     *\n     * @return {STAC|Asset} The STAC object.\n     * @api\n     */\n    getData() {\n        return this.get('stac');\n    }\n    /**\n     * Get the children STAC entities.\n     *\n     * @return {Array<STAC>} The STAC child entities.\n     * @api\n     */\n    getChildren() {\n        return this.children_;\n    }\n    /**\n     * Get the STAC assets shown.\n     *\n     * @return {Array<Asset>} The STAC assets.\n     * @api\n     */\n    getAssets() {\n        return this.assets_;\n    }\n    /**\n     * Get the extent of the layer.\n     * If `displayFootprint` is set to `false`, the extent is always returned in\n     * EPSG:4326 instead of the map projection. Make sure to transform it with the\n     * ol.proj.transformExtent function if needed.\n     *\n     * @return {Extent|undefined} The layer extent.\n     * @api\n     */\n    getExtent() {\n        if (!this.map_) {\n            return;\n        }\n        const view = this.map_.getView();\n        if (!view) {\n            return;\n        }\n        // todo: In general it might be better to get the actual extent of the layers/sources.\n        // Unfortunately, the extent is requested before it is available\n        // at least for the footprint layer due to the use of the GeoJSON loader.\n        // So we stick to the bounding box of the STAC entity for now,\n        // which sometimes is too small.\n        // See https://github.com/radiantearth/stac-browser/issues/634 for details.\n        let bbox;\n        const data = this.getData();\n        if (data) {\n            bbox = data.getBoundingBox();\n        }\n        const items = this.getChildren();\n        if (items) {\n            const bboxes = items.map((item) => item.getBoundingBox());\n            bbox = unionBoundingBox(bboxes);\n        }\n        if (bbox) {\n            return transformExtent(bbox, 'EPSG:4326', view.getProjection());\n        }\n    }\n    getLayerState() {\n        const state = super.getLayerState();\n        // Fixes the issue that the view is clipped based on the extent of the layer.\n        // The extent is usually the bbox, but sometimes there are even items outside of the bbox.\n        // See https://github.com/radiantearth/stac-browser/issues/634 for details.\n        state.extent = undefined;\n        return state;\n    }\n    /**\n     * Get the attributions of the STAC entity assigned to this layer.\n     *\n     * @return {Array<string>} Attributions for this layer.\n     * @api\n     */\n    getAttributions() {\n        const attribution = [];\n        const stac = this.getData();\n        if (stac) {\n            const attribution = stac.getMetadata('attribution');\n            if (attribution) {\n                attribution.push(attribution);\n            }\n        }\n        return attribution;\n    }\n    /**\n     * Get the layer source.\n     * @return {SourceType|null} The layer source (or `null` if not yet set).\n     */\n    getSource() {\n        return null;\n    }\n    /**\n     * Gets the WMTS capabilities from the given web-map-links URL.\n     * @param {string} url Base URL for the WMTS\n     * @param {string} [encoding] The request encoding, either `kvp` (default) or `rest`.\n     * @return {Promise<Object|null>} Resolves with the WMTS Capabilities object\n     * @private\n     */\n    async getWmtsCapabilities_(url, encoding = 'kvp') {\n        try {\n            const urlObj = new URL(url);\n            if (encoding !== 'rest') {\n                urlObj.searchParams.set('service', 'wmts');\n                urlObj.searchParams.set('request', 'GetCapabilities');\n            }\n            const response = await this.fetch_(urlObj.toString(), 'text');\n            return new WMTSCapabilities().read(response);\n        }\n        catch (_) {\n            return null;\n        }\n    }\n}\nexport default STACLayer;\n//# sourceMappingURL=STAC.js.map","<template>\n  <div class=\"map-container\">\n    <div ref=\"map\" class=\"map\" :id=\"mapId\">\n      <!-- this will be filled by OpenLayers -->\n      <LayerControl :map=\"map\" :maxZoom=\"maxZoom\" />\n      <TextControl v-if=\"empty\" :map=\"map\" :text=\"$t('mapping.nodata')\" />\n      <TextControl v-else-if=\"!hasBasemap\" :map=\"map\" :text=\"$t('mapping.nobasemap')\" />\n    </div>\n    <div ref=\"target\" class=\"popover-target\" />\n    <b-popover\n      v-if=\"popover && selection\" show manual placement=\"auto\"\n      :target=\"selection.target\" :teleport-to=\"container\" class=\"map-popover\"\n      :boundary-padding=\"10\"\n    >\n      <section class=\"popover-children\">\n        <Items v-if=\"selection.type === 'items'\" :stac=\"stac\" :items=\"selection.children\" />\n        <Catalogs v-else-if=\"selection.type === 'collections'\" collectionsOnly enforceCards hideControls :stac=\"stac\" :catalogs=\"selection.children\" />\n        <Features v-else :features=\"selection.children\" />\n      </section>\n      <div class=\"text-center\">\n        <b-button variant=\"danger\" @click=\"resetSelection\">{{ $t('mapping.close') }}</b-button>\n      </div>\n    </b-popover>\n  </div>\n</template>\n\n<script>\nimport { defineAsyncComponent } from 'vue';\nimport MapMixin from './maps/MapMixin.js';\nimport LayerControl from './maps/LayerControl.vue';\nimport TextControl from './maps/TextControl.vue';\nimport { mapGetters } from 'vuex';\nimport Select from 'ol/interaction/Select';\nimport StacLayer from 'ol-stac';\nimport { getStacObjectsForEvent, getStyle } from 'ol-stac/util.js';\nimport { STACReference } from 'stac-js';\nimport MapUtils from './maps/mapUtils.js';\nimport GeoJSON from 'ol/format/GeoJSON.js';\n\nconst selectStyle = getStyle('#ff0000', 2, null);\nlet mapId = 0;\n\nexport default {\n  name: 'MapView',\n  components: {\n    BPopover: defineAsyncComponent(() => import('bootstrap-vue-next').then(m => m.BPopover)),\n    Features: defineAsyncComponent(() => import('../components/Features.vue')),\n    Catalogs: defineAsyncComponent(() => import('../components/Catalogs.vue')),\n    Items: defineAsyncComponent(() => import('../components/Items.vue')),\n    LayerControl,\n    TextControl\n  },\n  mixins: [\n    MapMixin\n  ],\n  props: {\n    stac: {\n      type: Object,\n      default: null\n    },\n    assets: {\n      type: Array,\n      default: null\n    },\n    children: {\n      type: Object,\n      default: null\n    },\n    onfocusOnly: {\n      type: Boolean,\n      default: false\n    },\n    popover: {\n      type: Boolean,\n      default: false\n    }\n  },\n  emits: ['empty', 'changed'],\n  data() {\n    return {\n      selection: null,\n      clickPosition: { x: 0, y: 0 },\n      empty: false,\n      selector: null,\n      mapId: `map-${++mapId}`,\n    };\n  },\n  computed: {\n    ...mapGetters(['getStac']),\n    container() {\n      if (this.isFullScreen) {\n        return '#' + this.mapId;\n      }\n      else {\n        return '#stac-browser';\n      }\n    },\n    childrenOptions() {\n      return {\n        displayPreview: this.children && this.children.isItemCollection()\n      };\n    }\n  },\n  watch: {\n    async stac() {\n      await this.showStacLayer();\n    },\n    async assets() {\n      if (!this.stacLayer) {\n        return;\n      }\n      await this.stacLayer.setAssets(this.assets);\n    },\n    async children() {\n      if (!this.stacLayer) {\n        return;\n      }\n      await this.stacLayer.setAssets(null, false);\n      await this.stacLayer.setChildren(this.children, this.childrenOptions, false);\n      await this.stacLayer.updateLayers();\n      this.fit();\n    },\n    empty(empty) {\n      if (empty) {\n        this.$emit('empty');\n      }\n    },\n    selection(selection) {\n      if (!selection && this.selector) {\n        this.selector.getFeatures().clear();\n      }\n    }\n  },\n  created() {\n    // This is created here and not in data() to avoid it being reactive\n    this.stacLayer = null;\n  },\n  async mounted() {\n    await this.showStacLayer();\n  },\n  methods: {\n    async showStacLayer() {\n      this.map = null;\n      this.stacLayer = null;\n\n      await this.createMap(this.$refs.map, this.stac, this.onfocusOnly);\n\n      if (this.stac) {\n        await this.addStacLayer();\n      }\n    },\n    async addStacLayer() {\n      let options = Object.assign({}, this.stacLayerOptions, {\n        // Don't set the URL here, as it is already set in the STAC object and is read-only.\n        // url: this.stac.getAbsoluteUrl(),\n        data: this.stac,\n        children: this.children,\n        assets: this.assets || null,\n        displayWebMapLink: true,\n        disableMigration: true,\n        childrenOptions: this.childrenOptions\n      });\n      this.stacLayer = new StacLayer(options);\n      this.stacLayer.on('error', error => {\n        console.warn(error);\n        this.fit();\n      });\n      this.stacLayer.on('sourceready', this.fit);\n      this.stacLayer.on('layersready', () => {\n        this.empty = this.stacLayer.isEmpty();\n        this.$emit('changed', this.getShownData());\n      });\n      this.map.addLayer(this.stacLayer);\n\n      if (this.popover) {\n        this.selector = new Select({\n          multi: true,\n          style: selectStyle,\n          layers: (layer) => {\n            if (this.children) {\n              // For item selection\n              return false;\n            }\n            else {\n              // For feature selection\n              const stac = layer.get('stac');\n              return stac && stac.isAsset();\n            }\n          }\n        });\n        this.selector.on('select', (event) => {\n          // For feature selection\n          this.selection = null;\n          this.setTargetPosition(event.mapBrowserEvent);\n          const features = this.selector.getFeatures();\n          if (features.getLength() > 0) {\n            const writer = new GeoJSON();\n            this.selection = {\n              target: this.$refs.target,\n              type: 'features',\n              items: features.getArray().map(f => writer.writeFeatureObject(f))\n            };\n          }\n        });\n        this.map.addInteraction(this.selector);\n        this.map.on('singleclick', async (event) => {\n          // For item selection\n          this.selection = null;\n          if (this.children) {\n            this.setTargetPosition(event);\n            this.selector.getFeatures().clear();\n            const features = this.selector.getFeatures();\n            const container = this.stacLayer.getData();\n            const objects = await getStacObjectsForEvent(event, container, features, 5);\n            if (objects.length > 0) {\n              this.selection = {\n                target: this.$refs.target,\n                type: this.children.isCollectionCollection() ? 'collections': 'items',\n                children: objects\n              };\n            }\n          }\n        });\n        this.map.on('change', () => this.selection = null);\n        this.map.on('movestart', () => this.selection = null);\n      }\n    },\n    setTargetPosition(event) {\n      // The event doesn't contain a target element for the popover to attach to.\n      // Thus we move a hidden target element to the click position and attach the popover to it.\n      // See also https://github.com/bootstrap-vue/bootstrap-vue/issues/5285\n      this.$refs.target.style.left = event.pixel[0] + 'px';\n      this.$refs.target.style.top = event.pixel[1] + 'px';\n    },\n    fit() {\n      const extent = this.stacLayer.getExtent();\n      if (extent) {\n        // Update the sizes, otherwise the fit will not work properly and compute a wrong zoom level\n        this.map.updateSize();\n        this.map.getView().fit(extent, { padding: [50,50,50,50], maxZoom: this.maxZoom });\n      }\n    },\n    resetSelection() {\n      this.selection = null;\n    },\n    getShownData() {\n      if (!this.stacLayer) {\n        return null;\n      }\n      return this.stacLayer.getLayers().getArray()\n        .filter(layer => MapUtils.isLayerVisible(layer))\n        .map(layer => layer.get('stac'))\n        .filter(stac => stac instanceof STACReference);\n    }\n  }\n};\n</script>\n\n<style lang=\"scss\">\n@import \"ol/ol.css\";\n\n#stac-browser {\n  .map-popover {\n    max-width: 400px;\n  }\n\n  .popover-target {\n    width: 1px;\n    height: 1px;\n    opacity: 0;\n    position: absolute;\n    top: -1px;\n    left: -1px;\n  }\n  \n  .popover-children {\n    max-height: 500px;\n    overflow: auto;\n    margin-top: -0.5rem;\n    margin-left: -0.75rem;\n    margin-right: -0.75rem;\n    padding: 0.5rem 0.75rem 0  0.75rem;\n\n    .items, .features, .catalogs {\n      margin-bottom: 0 !important;\n    }\n\n    .card-columns {\n      column-count: 1;\n    }\n  }\n}\n</style>\n"],"file":"MapView-CNAdJ2HL.js"}